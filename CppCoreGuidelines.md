# C++核心指南

2018年3月26日

主编：
* Bjarne Stroustrup
* Herb Sutter

本文档是一份初期草案。我们知道它是不完整的，不正确的，以及有许多不好的格式。假如这是一个开源（代码）项目的话，那么它已经发布了0.8版本。复制，使用，修改以及从这个项目衍生的创作行为都在MIT类型的许可证下获得许可。对这个项目做贡献需要同意贡献者许可证。参考随附的LISENCE文件获取详情。我们让“友好的用户”可以使用，复制，修改以及从本项目衍生，以期望获得有建设性的贡献。

出于改进目的的评论和建议总是受欢迎的。我们计划在我们增进理解，以及语言和可用的程序库集改善的时候，修改和扩展这份文档。当你评论的时候，请注意这个勾勒出我们的目标和整体方法的介绍。贡献者的名单在这里。

问题：
* 准则集还没有彻底地检查完整性，一致性和可行性。
* 三个问号（???）标记表示缺失信息。
* 更新引用部分；许多C++11之前的来源太老了。
* 一份或多或少是最新的待办列表，可以看：待办: 未归类的原始准则。

你可以阅读关于这份指南的适用范围和组织结构的解释，或者直接跳转到：
* In: 前言
* P: 哲学
* I: 接口
* F: 函数
* C: 类和类层次结构
* Enum: 枚举
* R: 资源管理
* ES: 表达式和语句
* Per: 性能
* CP: 并发与并行
* E: 错误处理
* Con: 常量和不变性
* T: 模板和泛型编程
* CPL: C风格编程
* SF: 源文件
* SL: 标准库

支持部分：
* A: 设计意图
* NR: 无准则与神话
* RF: 参考
* Pro: 配置
* GSL: 指南支持库
* NL: 命名和排版规则
* FAQ: 常见问题的回答
* 附录A: 程序库
* 附录B: 现代化代码
* 附录C: 讨论
* 附录D: 支持工具
* 词汇表
* 待办: 未归类的原始准则

你可以针对特定的语言特性选取准则来查看：
* 赋值：常规类型—优先初始化—复制—移动—其它操作—默认值
* 类：数据—不变式—成员—辅助工具—具体类型—构造函数，赋值函数和析构函数—层次结构—操作符
* 概念：规则—在泛型编程中—模板参数—语义
* 构造函数：不变式—建立不变式—`throw`—默认值—不需要的—`explicit`—委托——`virtual`
* 派生类：何时用—作为接口—析构函数—复制—获取器和设置器—多重继承—重载—切割—`dynamic_cast`
* 析构函数：和构造函数—何时需要？—可能不失败
* 异常：错误—`throw`—只为了错误—`noexcept`—最小化`try`—没有异常会怎样？
* `for`：基于范围的`for`与`for`—`for`与`while`—`for`初始化器—空循环体—循环变量—循环变量类型???
* 函数：命名—单一操作—不抛异常—参数—参数传递—多个返回值—指针—lambda
* 内联：小函数—在头文件中
* 初始化：总是—最好用`{}`—lambda—类内初始化器—类成员—工厂函数
* lambda表达式：何时使用
* 操作符：墨守成规的—避免转换操作符—与lambda
* `public`，`private`和`protected`：信息隐藏—一致性—`protected`
* 静态断言：编译时检查—与概念
* 结构体：为了组织数据—没有不变式时使用—没有私有成员
* 模板：抽象—容器—概念
* 无符号：与有符号—位操作
* 虚拟：接口—非虚拟—析构函数—永不失败

你可以查看用来解释准则的设计概念：
* 断言：???
* 错误：???
* 异常：异常保证（???）
* 失败：???
* 不变式：???
* 泄露：???
* 库：???
* 前置条件：???
* 后置条件：???
* 资源：???

## 概要
这份文档是为正确使用C++的指南合集。这份文档的目的是帮助人们有效地使用现代C++。对于“现代C++”，我们指C++17，C++14，以及C++11。换句话说，假设你可以从现在开始，你希望你的代码在5年后看起来是怎样的呢？在10年后呢？

这些指南专注于相对高层级的议题，例如接口，资源管理，内存管理，以及并发。这些准则影响到程序架构和程序库设计。遵守这些准则将会让代码静态类型安全，没有资源泄露，以及比现在的代码捕捉到更多编程逻辑错误。而且它会运行得快——你有能力把事情做好。

我们较少关注低层级的议题，例如命名规范和缩进风格。当然，可以帮助程序员的话题是不算越界的。

我们最初的准则合集强调（各种形式的）安全性和简洁性。它们很可能太严格。我们预计不得不引入更多的例外情况来更好地适应实际的需要。我们也需要更多的准则。

你可能会发现一些准则与你的期望相反，或者甚至与你的经验相反。如果我们没有建议你在任一方面改变你的编码风格，那么我们就失败了！请尝试去证实或者反证准则！特别是，我们真的希望我们的一些准则能得到测量数据或者更好例子的支持。

你可能会发现一些准则是显然的，甚至是无关紧要的。请记住这个指南的其中一个目的是帮助那些缺乏经验，或者来自其它不同背景或语言的人尽快上手。

许多准则设计为可以用分析工具来支持。违反准则的地方会被标记，用引用（或者链接）指向相关的准则。我们不希望你在写代码之前记住所有准则。思考这些指南的一个途径是，作为一个人们偶尔能阅读到的工具规格说明。

这些准则将会逐渐引入到一个代码库中。我们计划为其构建工具，并且希望其他人也这么做。

出于改进目的的评论和建议总是受欢迎的。我们计划在我们增进理解，以及语言和可用的程序库集改善的时候，修改和扩展这份文档。

## In: 前言
这是一份现代C++，即C++17，C++14和C++11的核心指南合集，同时把可能在未来实现的增强和ISO技术规范（TS）也考虑进去。它的目标是帮助C++程序员写出更简洁，更高效，更可维护的代码。

前言概要：
* In.taget: 目标读者
* In.aims: 目的
* In.not: 非目的
* In.force: 实施
* In.struct: 这份文档的结构
* In.sec: 主要章节

### In.target: 目标读者
所有C++程序员。这包括那些可能想用C的程序员。

### In.aims: 目标
这份文档的意图是帮助开发者采用现代C++（C++17，C++14和C++11）以及在代码库之间获得更加统一的风格。

我们不会被每一条准则都可以适用于每一个代码库的错觉欺骗。升级老的系统是困难的。然而，我们确实相信应用了准则的程序比不应用的程序更不容易出错而且更加可维护。通常，准则会让初期开发阶段更快速/更简单。在我们看来，这些准则产出的代码与更老更传统的技术运行得一样，或者更好；它们本身遵循零开销原则（“你不需要为你不使用的东西付出代价”或者“当你合理地使用一个抽象机制时，你会得到跟你用低级语言构件写过的东西一样好的性能”）。在旧代码上工作时，为新的代码思考这些准则的理念，找机会去利用，同时尽可能让这些理念得到实践。记住：

#### Ln.0: 不要惊慌！
花一点时间在你的程序中理解指南准则的含义。

这些指南是根据“超集的子集”原则（Stroustrup05）设计的。它们不是简单地定义一份C++的子集来使用（为了可读性，安全性，性能，或者其它别的）。相反，它们强烈建议使用一些简单的“扩展”（库组件），这些“扩展”使大部分容易出错的C++特性变得冗余，所以它们可以被禁止使用（在我们的准则合集中）。

这些准则强调静态类型安全和资源安全。出于这个原因，它们强调范围检查，避免解引用`nullptr`，避免悬挂指针，以及合理地使用异常（通过RAII）的可能性。部分为了达成目标，部分为了最小化作为错误来源的复杂代码，这些准则也强调简单性，以及把必要的复杂性隐藏在良好规范的接口下。

许多准则是规范的。我们对那些只是说“不要那样做！”而没有提供可代替方案的准则感到不安。这样的一个后果是一些准则只能通过试探法来支持，而不是通过明确和机械性可证实的检查。其它准则清晰地表达了普遍的原则。对于这些更普遍的准则，更详细和具体的准则会提供部分检查。

这些指南针对C++的核心和它的用法。我们预计大部分大型机构，特定应用领域，以及甚至是大型项目会需要更多的准则，可能是更多的限制，以及更多的库支持。例如，硬式实时程序员通常不能随意地使用自由存储（动态内存），而且会在他们选择程序库上收到限制。我们鼓励开发这类更特定的准则作为这些核心指南的补遗。创建你自己理想的小型基础程序库然后使用它，而不是降低你的编程层级来赞美汇编代码。

这些准则被设计来允许渐进采用。

一些准则的目的是增加各种形式的安全性，而另一些准则的目的是减少发生事故的可能性，许多准则两者都有。这些旨在防止事故的指南通常会禁止完全合法的C++。不管怎样，当有两种方式表达一个想法，并且其中一种已经展现出自己是错误的常见来源，而另一种不会的时候，我们会尽量把程序员引导到后者。

### In.not: 非目标
这些准则并非打算要最小化或互不相干。特别是，通用的准则可以是简单的，但不是不可实行的。同样，理解一个通用准则的含义是困难的。更专门的准则通常更容易理解和实行，但如果没有通用准则，它们仅仅是一长串的特殊案例。我们提供旨在帮助新手的准则以及支持专业用法的准则。一些准则可以完全实行，但其它的则基于试探法。

这些准则并不打算像书本一样要按顺序阅读。你可以使用链接在它们之间浏览。当然，它们的主要使用意图是作为工具的目标。也就是说，一个工具查找违规的地方，然后这个工具返回指向违反准则的链接。然后这些准则提供原因，违规的潜在后果的例子，以及建议的改进方法。

这些指南并不打算取代任何C++教程。如果你需要针对一些指定经验等级的教程，参考这里。

这不是一个如何把旧的C++代码转变成更现代的代码的指引。它以具体的方式来表达对新代码清晰的想法。当然，参考现代化章节来看看一些可能的方法来现代化/活力化/升级。重要的是，这些准则支持渐进采用：通常一次性完全转变一个大的代码库是不可能的。

这些指南并不打算在每一个语言技术细节上都做到完整的和准确的。它们也绝对不打算定义一个像Java那样的C++子集。它们不打算定义一个单一的“真正的C++”语言。我们重视表达能力和不妥协的性能。

这些准则不是价值中性的。它们的意图是在不损失性能的前提下，使代码比大部分已有的C++代码更简洁和更正确/安全。它们的意图是防止完美合理的C++代码与错误，不必要的复杂性以及低下的性能有关联。

这些准则不是完美的。一个准则可能由于禁止了一些在给定场景下有用的东西而导致损害。一个准则可能由于没有禁止一些在给定场景下会带来严重错误的东西而导致损害。一个准则可能由于模糊不清，有歧义，不可实行，或者对一个问题给出了每一种解决方法而带来很多损害。完全吻合“没有损害”的标准是不可能的。相反，我们的目标没有那么雄心勃勃：“为大部分程序员做大部分好事”；如果你不能与一个准则共存，反对它，忽略它，但是不要冲淡它直到它变得毫无意义。此外，要提出改进建议。

### In.force: 实施
不能强制实施的准则对于大型代码库来说是不可管理的。强制实施所有准则只对小型的弱准则集合或者一个特定用户社区是可能的。
* 但是我们想要大量准则，而且我们想要那些每个人都可以使用的准则。
* 但是不同的人有不同的需求。
* 但是人们不喜欢阅读大量准则。
* 但是人们不能记住很多准则。

所以，我们需要取子集来满足不同的需求。
* 但是随意的取子集会导致混乱。

我们想要可以帮助很多人，让代码更统一，以及强烈鼓励人们去现代化它们的代码的指南。我们想要鼓励最好的实践，而不是把一切都留给个人选择和管理压力。这里的想法是使用所有的准则；这会带来最大的好处。

这增加了相当多的困境。我们试图用工具来解决那些问题。每个准则有一个强制实施的部分列出了强制实施的想法。强制实施可以通过代码审查，静态分析，编译器或者运行时检查来执行。在尽可能的情况下，我们更喜欢“机械式”检查（人类是缓慢的，不准确地，以及容易厌烦）和静态检查。运行时检查只建议在不存在其它替代方法的情况下使用；我们不想引入“分散的脂肪”。在合适的地方，我们会（在实施部分）用相关准则组合（称为档案）的名字给一个准则加标注。一个准则可以是多个档案的一部分，或者不属于任何档案。作为开头，我们有一些档案对应常见的需求（要求，想法）：
* 类型（type）：没有类型违规（通过转换，联合体或者可变参数将一个类型`T`解析成类型`U`）
* 边界（bounds）：没有边界违规（访问超出数组范围）
* 生命周期（lifttime）：没有泄露（没有调用`delete`或者多重`delete`）以及不访问无效的对象（解引用`nullptr`，使用悬空引用）。

这些档案的意图是在工具中使用，但同时也可以为人类读者提供帮助。我们不会把我们在实施部分的评论限制在我们知道如何实施的东西上；一些评论仅仅是可能会激发一些工具作者的希望。

实现这些准则的工具应该遵守下面的语法来显式地禁止一个准则：
```
[[gsl::suppress(tag)]]
```

这里“tag”是实施规则所在项的锚点名字（例如，对于C.134是“Rh-public”），是准则组合档案的名字（“type”，“bounds”，或者“lifttime”），或者是档案中的一个特定准则（type.4，或者bounds.2）。

### In.struct: 这份文档的结构
每个准则（指南，建议）会有几个部分：
* 准则本身——例如，不使用裸露的`new`
* 一个准则的引用数字——例如C.7（相对于分类的第7条准则）。由于主要部分没有内在的排序，我们使用字母作为一个准则引用“数字”的第一部分。为了最小化在我们添加或移除准则时的“干扰”，我们在数字之间留下空隙。
* 理由（依据）——因为程序员难以遵守他们不理解的准则。
* 示例——因为准则在抽象层面上难以理解；可能是正面的或反面的
* 替代方案——给那些“不要这样做”的准则
* 例外——我们想要简单普遍的准则。然而，许多准则虽然应用广泛，但并不是任何时候都适用，因此例外情况必须要列出来
* 实施——关于准则如何可以被“机械性”检查的想法
* 参见——相关准则的引用，以及/或者进一步的讨论（在本文档或者其它地方）
* 注意（备注）——一些需要说明的，不符合其它类别的东西。
* 讨论——对更广泛的依据的引用，以及/或者放置在准则主列表外的示例。

有一些准则难以机械性地检查，但它们都符合最低的标准，让专业程序员可以发现许多违规而不用太多麻烦。我们希望“机械性”的工具可以改善时间花费来接近一个专业程序员注意到的东西。同样，我们假定随着时间的推移准则会变得精炼，让它们更精确和可检查的。

一个准则旨在简单，而不是用仔细的措辞来提及每一个替代方案和特殊情况。这些信息可以在替代方案段落和讨论部分找到。如果你不理解规则或者不同意它，请查看它的讨论。如果你觉得一个讨论缺失或者不完整，输入一个问题来解释你关注的事情以及一个可能的对应的公关。

这不是一个语言手册。它旨在有帮助的，而不是完整的，完全在技术细节上精确的，或者一个已有代码的指南。推荐信息的来源可以在引用找到。

### In.sec: 主要部分
* In: 前言
* P: 哲学
* I: 接口
* F: 函数
* C: 类和类层次结构
* Enum: 枚举
* R: 资源管理
* ES: 表达式和语句
* Per: 性能
* CP: 并发和并行
* E: 错误处理
* Con: 常量和不变性
* T: 模板和泛型编程
* CPL: C风格编程
* SF: 源代码文件
* SL: 标准库

支持部分：
* A: 设计意图
* NR: 无准则与神话
* RF: 参考
* Pro: 配置
* GSL: 指南支持库
* NL: 命名和排版规则
* FAQ: 常见问题的回答
* 附录A: 程序库
* 附录B: 现代化代码
* 附录C: 讨论
* 附录D: 支持工具
* 词汇表
* 待办: 未归类的原始准则

这些部分不是正交的。

每个部分（例如，“哲学”的“P”）和每个子部分（例如，“类层次结构（OOP）”的“C.hier”）都有一个为了易于搜索和引用的缩写。主要部分的缩写同样用在准则数字上（例如，“使具体类型常规化”的“C.11”）。

## P: 哲学
这部分的准则是非常普遍的。

哲学准则概要：
* P.1: 在代码中表达想法
* P.2: 基于ISO标准C++来写代码
* P.3: 表达意图
* P.4: 理想情况下，一个程序应该是静态类型安全的
* P.5: 宁可使用编译时检查而不是运行时检查
* P.6: 不能在编译时检查的东西应该可在运行时检查
* P.7: 尽早捕获运行时错误
* P.8: 不要泄露任何资源
* P.9: 不要浪费时间或空间
* P.10: 宁可使用不可变数据而不是可变数据
* P.11: 封装凌乱的结构，而不是在代码中扩散
* P.12: 酌情使用支持工具
* P.13: 酌情使用支持库

哲学性的准则一般不能被机械性地检查。然而，个别映射到这些哲学性准则的准则是可以的。如果缺少哲学性的基础，那些更具体/详细/可检查的准则会缺乏依据。

### P.1: 直接在代码中表达想法
##### 理由
编译器不会阅读注释（或者设计文档），很多程序员也（始终）不会。在代码中表达的东西有已定义好的语义，而且（在理论上）可以被编译器和其它工具检查。

##### 示例
```cpp
class Date {
    // ...
public:
    Month month() const;  // 可以这样做
    int month();          // 不要这样做
    // ...
};
```
`month`的第一个声明明确地说明了会返回一个`Month`，而且不会修改`Date`对象的状态。而第二个版本让读者自己去猜测，以及为捕捉不到的缺陷敞开了更多的可能性。

##### 示例；不好的
这个循环是`std::find`的一个有限制的形式：
```
void f(vector<string>& v)
{
    string val;
    cin >> val;
    // ...
    int index = -1;                    // 不好，而且应该使用gsl::index
    for (int i = 0; i < v.size(); ++i) {
        if (v[i] == val) {
            index = i;
            break;
        }
    }
    // ...
}
```

##### 示例；好的
一个更清晰的意图表达可能是：
```cpp
void f(vector<string>& v)
{
    string val;
    cin >> val;
    // ...
    auto p = find(begin(v), end(v), val);  // 好多了
    // ...
}
```
一个设计良好的库比直接使用语言特性更好地表达意图（做了什么事情，而不只是如何做）。

一个C++程序员应该了解标准库的基础知识，并且适当地使用它。任何程序员都应该了解项目中的基础库的基础知识，并且适当地使用它们。任何使用这些指南的程序员都应该了解指南支持库，并且适当地使用它。

##### 示例
```cpp
change_speed(double s);   // 不好：s表示什么？
// ...
change_speed(2.3);
```
一个更好的方法是显式说明double的含义（新的速度还是旧速度的增量？）和它使用的单位：
```cpp
change_speed(Speed s);    // 好多了：指定了s的含义
// ...
change_speed(2.3);        // 错误：没有单位
change_speed(23m / 10s);  // 米每秒
```
我们本可以接受将一个纯（无单位的）`double`作为增量，但那将会是容易出错的。如果我们同时想要绝对速度和增量，那么我们会定义一个`Delta`类型。

##### 实施
通常非常困难。
* 始终使用`const`（检查成员函数是否修改它们的对象；检查函数是否修改以指针或引用传递的参数）
* 标记类型转换的使用（类型转换会使类型系统失去作用）
* 检测与标准库相似的代码（困难）

### P.2: 使用ISO标准C++
##### 理由
这是一份关于ISO标准C++的指南合集。

##### 注意
有些环境下扩展是必要的，例如，访问系统资源。在这些情况下，局部化必要扩展的使用以及用非核心编码指南控制它们的使用。如果可能的话，创建接口来封装扩展以使它们能够被关闭，或者在不支持那些扩展的系统上从编译去掉。

扩展通常没有严格定义的语义。作为没有严格标准定义的直接后果，甚至那些常见的以及被多种编译器实现的扩展会有略微不同的行为和边界行为。当任何这些扩展使用得足够多的时候，期望得到的可移植性会受到冲击。

##### 注意
使用有效的ISO C++不能保证可移植性（更不用说正确性）。避免依赖未定义的行为（例如未定义的估值顺序），以及了解由实现定义意思的构件（例如`sizeof(int)`）。

##### 注意
有些环境下限制标准C++语言或者程序库特性的使用是必要的，例如，由于飞行器控制软件标准的需要而避免动态内存分配。在这些情况下，使用给这些特定环境定制的编码指南的扩展来控制它们的使用与否。

##### 实施
使用最新的C++编译器（目前的C++17，C++14，或者C++11），并且打开不接受扩展的选项。

### P.3: 表达意图
##### 理由
除非一些代码的意图已经被说明了（例如，在名字或者注释中），否则无从知道这些代码是否做了它应该做的事情。

##### 示例
```cpp
gsl::index i = 0;
while (i < v.size()) {
    // ... 用 v[i] 做一些事情 ...
}
```
遍历`v`的元素的意图没有在这里表达出来。使用索引的实现细节被暴露出来（因而它可能会被误用），`i`超出了循环的作用域，这可能是也可能不是预期的。只从这个代码片段读者不能了解到什么。

更好的写法：
```cpp
for (const auto& x : v) { /* 用 x 的值做一些事情 */ }
```
现在，没有显式提到迭代机制，而且循环的操作基于元素的`const`引用，因此不会出现意外的修改。如果想要进行修改，要这样：
```cpp
for (auto& x : v) { /* 修改 x */ }
```

关于for语句的更多细节，参见ES.71。有时还有更好的做法，使用具名的算法：
```cpp
for_each(v, [](int x) { /* 用 x 的值做一些事情 */ });
for_each(par, v, [](int x) { /* 用 x 的值做一些事情 */ });
```
最后一个变体版本表明我们对`v`的元素的处理顺序不感兴趣。

程序员应该熟悉：
* 指南支持库
* ISO C++标准库
* 任何用于当前项目的基础库

##### 注意
另一种表述：说明应该做什么，而不只是应该怎么做。

##### 注意
有些语言构件比其它构件更好地表达意图。

##### 示例
如果以两个`int`作为一个2D点的坐标，那么：
```cpp
draw_line(int, int, int, int);  // 晦涩的
draw_line(Point, Point);        // 更清晰
```

##### 实施
为常见的模式寻找是否有更好的选择。
* 单纯的`for`循环与基于范围的`for`循环
* `f(T*, int)`接口与`f(span<T>)`接口
* 作用域太大的循环变量
* 裸露的`new`和`delete`
* 具有许多内置类型参数的函数
智能和半自动程序转换是一个巨大的领域。

### P.4: 理想情况下，一个程序应该是静态类型安全的
##### 理由
理想情况下，一个程序是完全静态（编译时）类型安全的。不幸的是，这是不可能的。产生问题的地方：
* 联合体
* 类型转换
* 数组衰变
* 范围错误
* 收缩转换

##### 注意
这些地方是严重问题（例如，崩溃和安全违规）的来源。我们会尝试提供替代的技术。

##### 实施
根据不同程序的需求和可行性，我们可以分别禁止，限制或者检测每一种问题。总是提供替代方案的建议。例如：
* 联合体——使用`variant`（在C++17中）
* 类型转换——尽量减少使用；模板可以提供帮助
* 数组衰变——使用`span`（在GSL中）
* 范围错误——使用`span`
* 收缩转换——尽量减少使用，以及在必要的时候使用`narrow`或者`narrow_cast`（在GSL中）。

### P.5: 宁愿使用编译时检查而不是运行时检查
##### 理由
代码清晰性和性能。你不需要为在编译时捕获到的错误写错误处理代码。

##### 示例
```cpp
// Int 是整型的别名
int bits = 0;         // 不要这样做：可避免的代码
for (Int i = 1; i; i <<= 1)
    ++bits;
if (bits < 32)
    cerr << "Int too small\n";
```
这个例子不能完成它想要完成的事情（因为溢出是未定义的），而且应该用一个简单的`static_assert`来替换：
```cpp
// Int 是整型的别名
static_assert(sizeof(Int) >= 4);    // 要这样做：编译时检查
```
或者还有更好的做法，只使用类型系统，以及用`int32_t`替换`Int`。

##### 示例
```cpp
void read(int* p, int n);   // 读取最多n个整数到*p中

int a[100];
read(a, 1000);    // 不好，越界了
```
更好的做法
```cpp
void read(span<int> r); // 读取到整数范围r中

int a[100];
read(a);        // 好多了：让编译器找出元素的个数
```

另一种表述：不要把可以在编译时做的事情推迟到运行时。

##### 实施
* 查找指针参数。
* 查找运行时的范围违规检查。

### P.6: 可以在编译时检查的也应该可以在运行时检查
##### 理由
在程序中留下难以检测的错误是在要求崩溃和坏结果。

##### 注意
理想情况下，我们捕获所有编译时错误和运行时错误（不包括程序员逻辑中的错误）。捕获所有编译时错误是不可能的，而且通常不值得在运行时捕获所有剩下的错误。但是，我们应该努力写出理论上可以被检查，提供足够资源（分析程序，运行时检查，机器资源，时间）的程序。

##### 示例，不好的
```cpp
// 单独编译，可能是动态加载的
extern void f(int* p);

void g(int n)
{
    // 不好：元素的个数没有传递给f()
    f(new int[n]);
}
```
在这里，一个关键的信息（元素的个数）被如此彻底地“掩盖”，以至于静态分析可能不可行，而且当`f()`是ABI的一部分时动态检查可能非常困难，因此我们不能“检测”那个指针。我们可以嵌入有用的信息到自由存储中，但那样需要对一个系统或者可能对编译器进行全局修改。我们这里拥有的是一个让错误非常难被检测的设计。

##### 示例，不好的
我们当然可以跟指针一起传递元素的个数：
```cpp
// 单独编译，可能是动态加载的
extern void f2(int* p, int n);

void g2(int n)
{
    f2(new int[n], m);  // 不好：一个错误的元素个数可能被传递给f()
}
```
传递元素的个数作为参数比仅仅传递指针和依赖一些（假设的）约定来知道或发现元素的个数更好（而且更常见得多）。然而（如上所示），一个简单的输入错误可能会引起一个严重的错误。`f2()`两个参数之间的关联是约定的，而不是显式的。

而且，这里隐含了`f2()`应该用`delete`删除它的参数（否则调用者是否犯了第二个错误？）。

##### 示例，不好的
当标准库的资源管理指针指向一个对象的时候，不能传递大小：
```cpp
// 单独编译，可能是动态加载的
// 注意：这里假定调用代码是ABI兼容的，使用了一个兼容的C++编译器和相同的标准库实现
extern void f3(unique_ptr<int[]>, int n);

void g3(int n)
{
    f3(make_unique<int[]>(n), m);    // 不好：分开传递所有权和大小
}
```

##### 示例
我们需要将指针和元素的个数作为整体对象来传递：
```cpp
extern void f4(vector<int>&);   // 单独编译，可能是动态加载的
extern void f4(span<int>);      // 单独编译，可能是动态加载的
                                // 注意：这里假定调用代码是ABI兼容的，
                                // 使用了一个兼容的C++编译器和相同的标准库实现

void g3(int n)
{
    vector<int> v(n);
    f4(v);                     // 传递一个引用，维持所有权
    f4(span<int>{v});          // 传递一个视图，维持所有权
}
```
这个设计将元素个数作为一个对象的完整部分来传递，因此不大可能出现错误，而且动态（运行时）检查总是可行的，如果不总是值得的话。

##### 示例
为了有效地使用，我们如何同时传输所有权和所有需要的信息？
```cpp
vector<int> f5(int n)    // 好：移动
{
    vector<int> v(n);
    // ... 初始化 v ...
    return v;
}

unique_ptr<int[]> f6(int n)    // 不好：丢失了n
{
    auto p = make_unique<int[]>(n);
    // ... 初始化 *p ...
    return p;
}

owner<int*> f7(int n)    // 不好：丢失了n而且我们可能忘记删除
{
    owner<int*> p = new int[n];
    // ... 初始化 *p ...
    return p;
}
```

##### 示例
* ???
* 演示如何通过传递多态基类的接口来避免可能检查，当它们实际知道它们需要什么的时候？或者字符串作为“自由样式”选项

##### 实施
* 标记（指针，数量）风格的接口（这会标记很多由于兼容原因不能被修正的例子）
* ???

### P.7: 尽早捕获运行时错误
##### 理由
避免“神秘的”崩溃。避免导致（可能不被察觉的）不正确结果的错误。

##### 示例
```cpp
void increment1(int* p, int n)    // 不好：容易出错
{
    for (int i = 0; i < n; ++i) ++p[i];
}

void use1(int m)
{
    const int n = 10;
    int a[n] = {};
    // ...
    increment1(a, m);   // 可能是输入错误，可能应该 m <= n 
                        // 但假设 m == 20
    // ...
}
```
这里我们在`use1`中犯了一个小错误，可能会导致数据被破坏或者崩溃。（指针，数量）风格的接口让`increment1()`没有切实可行的方法来让自己防御超出范围错误。如果我们可以检查下标来发现超出范围的访问，那么直到访问`p[10]`之前错误都不会被发现。我们可以更早地检查以及改善代码：
```cpp
void increment2(span<int> p)
{
    for (int& x : p) ++x;
}

void use2(int m)
{
    const int n = 10;
    int a[n] = {};
    // ...
    increment2({a, m});    // 可能输入错误，可能应该 m <= n
    // ...
}
```
现在，`m <= n`可以在调用点（提早）来检查，而不是在更晚的点。如果我们只是输入错误，那么我们的意思是使用`n`作为边界，代码可以更简单（排除了出错的可能）：
```cpp
void use3(int m)
{
    const int n = 10;
    int a[n] = {};
    // ...
    increment2(a);   // 不需要重复元素的数量
    // ...
}
```

##### 示例，不好的
不要重复检查同一个值。不要以字符串传递结构化数据：
```cpp
Date read_date(istream& is);    // 从istream读取日期

Date extract_date(const string& s);    // 从string提取日期

void user1(const string& date)    // 处理日期
{
    auto d = extract_date(date);
    // ...
}

void user2()
{
    Date d = read_date(cin);
    // ...
    user1(d.to_string());
    // ...
}
```
日期被验证了两次（通过`Date`的构造函数）而且作为一个字符串（非结构化数据）被传递。

##### 示例
过度检查可能会代价高昂。有些时候提前检查是愚蠢的，因为你可能永远不需要这个值，或者可能只是需要这个值的一部分，而检查这部分比检查整个值简单得多。类似的，不要添加会改变你接口的渐进行为的有效性检查（例如，不要添加一个`O(n)`的检查到一个平均复杂度为`O(1)`的接口）。
```cpp
class Jet {    // 物理学说明：e * e < x * x + y * y + z * z
    float x;
    float y;
    float z;
    float e;
public:
    Jet(float x, float y, float z, float e)
        :x(x), y(y), z(z), e(e)
    {
        // 我应该在这里检查这些值是否具有物理意义吗？
    }

    float m() const
    {
        // 我应该在这里处理退化的情况吗？
        return sqrt(x * x + y * y + z * z - e * e);
    }

    ???
};
```
喷气式飞机的物理定律（`e * e < x * x + y * y + z * z`）不是一个不变式，因为可能存在测量错误。

##### 实施
* 查看指针和数组：提早做范围检查而且不重复
* 查看转换：排除或者标记收缩转换
* 查找来自输入的未被检查的值。
* 查找被转换成字符串的结构化数据（具有不变式）的类对象
* ???

### P.8: 不要泄露任何资源
##### 理由
即使资源缓慢增长，随着时间推移，也会耗尽这些资源的可用性。对于长时间运行的程序来说这特别重要，但这也是一个负责任的编程行为的必要部分。

##### 示例，不好的
```cpp
void f(char* name)
{
    FILE* input = fopen(name, "r");
    // ...
    if (something) return;   // 不好：如果 something == true，文件句柄被泄露了
    // ...
    fclose(input);
}
```
应该使用RAII：
```cpp
void f(char* name)
{
    ifstream input {name};
    // ...
    if (something) return;   // 好：没有泄露
    // ...
}
```

##### 参见：资源管理部分

##### 注意
用口语化的表述，泄露是指“任何没有清理的东西”。更重要的分类是“任何不能再清理的东西”。例如，在堆上分配一个对象，然后丢失了最后一个指向这个分配的指针。这个准则不应该被视为要求长生命周期对象中的分配必须在程序结束过程中返还。例如，依赖系统在进程结束时保证的清理，如关闭文件和释放内存，可以简化代码。当然，依赖隐含清理的抽象可以同样简单，通常也更安全。

##### 注意
强制使用生命周期配置来消除泄露。当结合了RAII提供的资源安全时，它消除了“垃圾回收”的需要（通过不生成垃圾）。把它与强制使用类型和边界配置结合，你会得到由工具保证的完整的类型和资源安全。

##### 实施
* 查看指针：把它们分成非所有者（默认）和所有者。可行的时候，把所有者替换成标准库的资源句柄（就像上面的示例那样）。或者，标记出所有者来使用来自GSL的`owner`。
* 查找裸露的`new`和`delete`
* 查找已知的会返回原始指针的资源分配函数（例如`fopen`，`malloc`以及`strdup`）

### P.9: 不要浪费时间或空间
##### 理由
这是C++。

##### 注意
为了达成目标（例如，开发速度，资源安全，或者简化测试），你利用得好的时间和空间并不算浪费。“争取效率的另一个好处是这个过程迫使你更深入地了解问题。”——Alex Stepanov

##### 示例，不好
```cpp
struct X {
    char ch;
    int i;
    string s;
    char ch2;

    X& operator=(const X& a);
    X(const X&);
};

X waste(const char* p)
{
    if (!p) throw Nullptr_error{};
    int n = strlen(p);
    auto buf = new char[n];
    if (!buf) throw Allocation_error{};
    for (int i = 0; i < n; ++i) buf[i] = p[i];
    // ... 处理buffer ...
    X x;
    x.ch = 'a';
    x.s = string(n);    // 把*p的空间赋予x.s
    for (gsl::index i = 0; i < x.s.size(); ++i) x.s[i] = buf[i];  // 把buf复制到x.s
    delete[] buf;
    return x;
}

void driver()
{
    X x = waste("Typical argument");
    // ...
}
```
是的，这是一个夸张的示例，但我们已经在产品代码中分别见过每个错误，甚至更糟糕。注意`x`的布局确保了至少有6个字节（而且很可能会更多）是浪费的。虚构的复制操作符定义禁止了移动语义，因此返回操作是缓慢的（请注意返回值优化，RVO，在这里是不保证生效的）。对`buf`的`new`和`delete`的使用时多余的；如果我们确实需要一个局部字符串，我们应该使用一个局部的`string`。还有几个性能缺陷和不必要的复杂性。

##### 示例，不好
```cpp
void lower(zstring s)
{
    for (int i = 0; i < strlen(s); ++i) s[i] = tolower(s[i]);
}
```
是的，这是一个来自产品代码的示例。我们把它留给读者去发现浪费了什么。

##### 注意
一个单独的浪费示例不怎么严重，当它严重，通常可以被专家轻松地消除。然而，在代码库中大量扩散的浪费容易变得严重，而且专家不是我们想要的那样总是可用。这个准则（以及支持它的更具体的准则）的目标是在大部分与C++用法有关的浪费发生之前消除它们。在这之后，我们可以看看与算法和需求相关的浪费，但这超出了这些指南的范围。

##### 实施
许多更具体的准则旨在实现简化和消除不必要浪费的总体目标。

### P.10: 宁可使用不可变数据而不是可变数据
##### 理由
说出常量比变量好的理由容易得多。不可改变的东西不会被意外修改。有时候不变性可以带来更好的优化。对于一个常量你不会有数据竞争的问题。

参见Con: 常量和不变性

### P.11: 封装混乱的构件，而不是在代码中扩散
##### 理由
混乱的代码更可能隐藏缺陷，而且更难写。好的接口可以更容易更安全地使用。混乱，低层级的代码滋生了更多这样的代码。

##### 示例
```cpp
int sz = 100;
int* p = (int*) malloc(sizeof(int) * sz);
int count = 0;
// ...
for (;;) {
    // ... 读取一个int到x，如果到达了文件的末尾则退出循环 ...
    // ... 检查x是否有效 ...
    if (count == sz)
        p = (int*) realloc(p, sizeof(int) * sz * 2);
    p[count++] = x;
    // ...
}
```
这是低层级的，啰嗦的，以及容易出错的。例如，我们“忘记”去检查内存耗尽。相反，我们可以使用`vector` ：
```cpp
vector<int> v;
v.reserve(100);
// ...
for (int x; cin >> x; ) {
    // ... 检查x是否有效 ...
    v.push_back(x);
}
```

##### 注意
标准库和GSL是这条哲学的例子。例如，为了不被数组，联合体，转换，棘手的生命周期问题，`gsl::owner`等扰乱，有必要实现关键的抽象，例如`vector`，`span`，`lock_guard`，以及`future`，我们使用这些比我们花费更多时间和专长的人设计和实现的库。类似的，我们应该设计和实现更专用的库，而不是给用户（通常是我们自己）留下重复获取低层级代码的挑战。这是超集的子集原则在这些指南下的变体。

##### 实施
* 查找“混乱的代码”，例如复杂的指针维护，以及在抽象实现外部的转换。

### P.12: 适当地使用辅助工具
##### 理由
有许多事情可以“被机器”做得更好。计算机不会疲劳或者对重复任务感到厌倦。我们一般有更好的事情要做，而不是重复做常规的任务。

##### 示例
运行一个静态检查器来验证你的代码是否遵守你想要的指南。

##### 注意
参见
* 静态分析工具
* 并发工具
* 测试工具
有很多其它类型的工具，例如源代码仓库，构建工具，等等，但那超出了这些指南的范围。

##### 注意
小心不要陷入对太精细或者太专用的工具链的依赖。那些东西会使你的可移植代码变得不可移植。

### P.13: 适当地使用辅助库
##### 理由
使用一个有良好设计，良好文档，以及良好支持的库节省时间和精力；如果你的主要时间必须花在实现上，那么它的质量和文档可能会比你能做到的更好。一个库的开销（时间，精力，金钱等）可以在许多用户之间共享。比起一个单独的程序，一个被广泛使用的库更可能保持最新，并且移植到新的操作系统。对一个被广泛使用的库的认识可以在其它/将来的项目中节省时间。所以，如果在你的程序领域中有一个合适的库，使用它。

##### 示例
```cpp
std::sort(begin(v), end(v), std::greater<>());
```
除非你是一个排序专家而且有很多时间，这很可能比你为特定程序写的任何东西更加准确以及运行得更快。你需要一个不使用标准库（或者其它你的程序使用的基础库）的理由，而不是使用它的理由。

##### 注意
默认使用
* ISO C++标准库
* 指南支持库

##### 注意
如果在一个重要的领域中缺少一个有良好设计，良好文档，和良好支持的库，那么可能你应该设计和实现它，然后使用它。

## I: 接口
接口是程序两个部分之间的合同。准确地说明服务供应商和该服务的用户所期望的内容是必要的。具有良好（易于理解，鼓励高效使用，不容易出错，支持测试等）的接口很可能是代码结构中最重要的一个方面。

接口准则总览：
* I.1: 使接口清晰
* I.2: 避免非const全局变量
* I.3: 避免单件
* I.4: 使接口精确和强类型化
* I.5: 声明前置条件（如果有的话）
* I.6: 使用`Expects()`表达前置条件
* I.7: 声明后置条件
* I.8: 使用`Ensures()`表达后置条件
* I.9: 如果接口是模板，使用概念将它的参数文档化
* I.10: 使用异常来指示执行所需任务的失败
* I.11: 永不通过原始指针（`T*`）或引用（`T&`）转移所有权
* I.12: 将不能为空的指针声明成`not_null`
* I.13: 不要将数组作为一个指针来传递
* I.22: 避免全局对象的复杂初始化
* I.23: 将函数参数的数量保持在少量
* I.24: 避免相同类型的相邻的无关系参数
* I.25: 首选抽象类作为接口，而不是类层次结构
* I.26: 如果你想要跨编译器的ABI，使用C风格子集
* I.27: 为了得到稳定的库ABI，考虑使用Pimpl技巧
* I.30: 封装准则违规

##### 另见：
* F: 函数
* C.Concrete: 具体类型
* C.hier: 类层次结构
* C.over: 重载和重写操作符
* C.con: 容器和其它资源句柄
* E: 错误处理
* T: 模板和泛型编程

### I.1: 使接口清晰
##### 理由
正确性。没有在接口说明的假设容易被忽略而且难以测试。

##### 示例，不好的
通过全局（名称空间作用域）变量（调用模式）来控制函数的行为是隐蔽的，以及潜在的令人困惑。例如：
```cpp
int round(double d)
{
    return (round_up) ? ceil(d) : d;    // 不要这样做：“不可见”的依赖
}
```
两次`round(7.2)`调用可能会得到不同结果，这对调用者来说是不明确的。

##### 例外
有时候我们通过环境变量来控制一系列操作的细节，例如，普通与详细输出，或者调试与优化。使用非局部的控制有潜在的困惑性，但它只控制了固定语义下其它方面的实现细节。

##### 示例，不好的
通过非局部变量（例如`errno`）来返回信息容易被忽略。例如：
```cpp
// 不要这样做：没有检查printf的返回值
fprintf(connection, "logging: %d %d %d\n", x, y, s);
```
如果连接被关闭以至于没有产生日志输出怎么办？参见I.???。

*替代方案*：抛异常。异常不能被忽略。

*替代方案*：避免通过非局部或者隐式状态跨接口传递信息。注意非`const`成员函数通过它们所在对象的状态来传递信息给其它成员变量。

*替代方案*：接口应该是一个函数或者一系列函数集合。函数可以是模板函数，函数集合可以是类或者类模板。

##### 实施
* （简单）函数不应该基于在名称空间作用域中声明的变量的值来做控制流决策。
* （简单）函数不应该修改在名称空间作用域中声明的变量。

### I.2: 避免非`const`全局变量
##### 理由
非`const`全局变量隐藏依赖，并且使依赖受到不可预知的修改的影响。

##### 示例
```cpp
struct Data {
    // ... 许多东西 ...
} data;            // 非const的data

void compute()     // 不要这样做
{
    // ... 使用data ...
}

void output()     // 不要这样做
{
    // ... 使用data ...
}
```
还有谁会修改`data`？

##### 注意
全局常量是有用的。

##### 注意
本准则针对全局变量，同时也适用于名称空间作用域变量。

*替代方案*：如果你使用全局（更多的是名称空间作用域）数据来避免复制，考虑将数据作为对象，以`const`引用来传递。其一个方案是将数据定义为一些对象的状态，将操作定义为成员函数。

*警告*：谨防数据竞争：如果一个线程在访问非局部数据（或者通过引用传递的数据），同时另一个线程在执行被调用函数，我们就会遇到数据竞争。每一个对可变数据的指针或引用都有潜在的数据竞争问题。

##### 注意
你不会在不可变数据上遇到竞争状态。

*参考*：参见调用函数的规则。

##### 实施
（简单）报告所有在名称空间作用域声明的非`const`变量。

### I.3: 避免单件
##### 理由
从根本上来说，单件是经过伪装的复杂的全局对象。

##### 示例
```cpp
class Singleton {
    // ... 许多东西来保证只有一个单件对象会被创建，
    // 以及正确地初始化，等等。
};
```
单件的概念有许多变体。这也是问题的一部分。

##### 注意
如果你不想一个全局对象被修改，把它声明为`const`或者`constexpr`。

##### 例外
你可以使用最简单的“单件”（它简单到通常不被认为是单件）来在首次使用的时候得到初始化，如果需要的话：
```cpp
X& myX()
{
    static X my_x {3};
    return my_x;
}
```
这是关于初始化顺序的其中一个最有效的解决方法。在多线程环境下，静态对象的初始化不会导致竞争状态（除非你不小心从一个共享对象的构造函数中访问了它自己）。

注意局部`static`的初始化并不意味着竞争状态。当然，如果`x`的析构发起了一个需要同步的操作，那么我们必须使用更简单的方案。例如：
```cpp
X& myX()
{
    static auto p = new X {3};
    return *p;  // 潜在的泄露
}
```
现在必须有人以合适的线程安全的方式，用`delete`删除对象。这是容易出错的，所以我们不使用这种技术，除非
* `myX`是在多线程执行的代码中，
* `X`对象需要销毁（例如，由于它要释放一个资源），而且
* `X`的析构函数的代码需要同步。

如果你像许多人做的那样，为了只有一个对象被创建而把单件定义成类，那么像`myX`这样的函数就不是单件，而且这个有用的技术不是无单件准则的例外。

##### 实施
通常非常困难。
* 查找名称包含`singleton`的类。
* 查找那些只有一个对象被创建的类（通过计算对象个数或者通过检查构造函数）。
* 如果类X有一个公有静态函数，包含一个类类型为X的函数局部静态变量，并且返回指向它的指针或者引用，那么禁止它。

### I.4: 使接口精确和强类型化
##### 理由
类型是最简单和最好的文档，具有良好定义的含义，而且可以保证在编译时被检查。同时，精确类型化的代码通常可以更好地优化。

##### 示例，不要这样做
考虑以下代码：
```cpp
void pass(void* data);    // void*是可疑的
```
现在被调用者必须将data指针转换回正确的类型来使用。这是容易出错的，而且通常是冗余的。避免`void*`，特别是在接口上。考虑使用`variant`或者指向基类的指针来代替。

*替代方案*：通常，模板参数可以消除`void*`，将它转成`T*`或者`T&`。对于泛型代码，这些`T`可以是普通的或者由概念约束的模板参数。

##### 示例，不好的
考虑以下代码：
```cpp
void draw_rect(int, int, int, int);   // 出错的好机会

draw_rect(p.x, p.y, 10, 20);          // 10, 20是什么意思？
```
`int`可以携带任意形式的信息，因此我们必须猜测四个`int`的含义。最有可能的是，前面两个是`x`，`y`坐标对，但后面两个是什么呢？注释和参数名称可以提供帮助，但我们可以让它更清晰：
```cpp
void draw_rectangle(Point top_left, Point bottom_right);
void draw_rectangle(Point top_left, Size height_width);

draw_rectangle(p, Point{10, 20});  // 两个角
draw_rectangle(p, Size{10, 20});   // 一个角和一对（高度，宽度）
```
显然，我们不能通过静态类型系统捕获到所有错误（例如，第一个参数应该是左上角的点，这个事实留给了约定（通过命名和注释））。

##### 示例，不好的
在下面的例子中，`time_to_blink`的含义从接口来看是不清晰的：是秒？还是毫秒？
```cpp
void blink_led(int time_to_blink) // 不好——单位不明确
{
    // ...
    // 用time_to_blink做些事情
    // ...
}

void use()
{
    blink_led(2);
}
```

##### 示例，好的
`std::chrono::duration`类型（C++11）有助于使时间段的单位清晰。
```cpp
void blink_led(milliseconds time_to_blink) // 好——单位清晰
{
    // ...
    // 用time_to_blink做些事情
    // ...
}

void use()
{
    blink_led(1500ms);
}
```
这个函数也可以按以下方式写成能够接受任意时间段单位。
```cpp
template<class rep, class period>
void blink_led(duration<rep, period> time_to_blink) // 好——接受任意单位
{
    // 假设毫秒是最小的相关单位
    auto milliseconds_to_blink = duration_cast<milliseconds>(time_to_blink);
    // ...
    // 用time_to_blink做些事情
    // ...
}

void use()
{
    blink_led(2s);
    blink_led(1500ms);
}
```

##### 实施
* （简单）报告使用`void*`作为参数或者返回值。
* （难以做好）查找用许多内置类型作为参数的成员函数。

### I.5: 声明前置条件（如果有的话）
##### 理由
参数有一些含义可能会限制它们在被调用者中正确的使用。

##### 示例
考虑以下代码：
```cpp
double sqrt(double x);
```
在这里`x`必须为非负数。类型系统不能（简单和自然地）表达这个含义，因此我们必须使用其它方法。例如：
```cpp
double sqrt(double x); // x必须为非负数
```
有些前置条件可以用断言来表达。例如：
```cpp
double sqrt(double x) { Expects(x >= 0); /* ... */ }
```
理想情况下，`Expects(x >= 0)`应该作为`sqrt()`接口的一部分，但这不容易做到。目前，我们把它放在定义（函数体）中。

*参考资料*：`Expects()`在GSL中描述。

##### 注意
优先使用需求的正式说明，例如`Expects(p);`。如果这不可行，在注释中使用文本说明，例如`// [p:q) 序列使用了<排序`。

##### 注意
大多数成员函数都是某些类不变式持有的前置条件。那些不变式通过构造函数来建立，而且必须通过每个被类外部调用的成员函数在退出之前重新建立。我们不需要为每个成员函数提到这一点。

##### 实施
（不可实施）

*参见*：传递指针的准则。???

### I.6: 优先使用`Expects()`来表达前置条件
##### 理由
清楚地说明这是前置条件，以及可以使用工具。

##### 示例
```cpp
int area(int height, int width)
{
    Expects(height > 0 && width > 0);            // 好的
    if (height <= 0 || width <= 0) my_error();   // 复杂的
    // ...
}
```

##### 注意
前置条件可以通过许多方式来声明，包括注释，`if`语句，以及`assert()`。这会使它们难以从普通代码中区分，难以更新，难以用工具维护，而且可能有错误的语义（你总是想要在调试模式下终止程序而在正式产品运行时不做任何检查吗？）。

##### 注意
前置条件应该是接口的一部分，而不是实现的一部分，但我们还没有语言设施来做到这点。一旦语言的支持变为可用（例如，参见合同提案），我们会采用标准版本的前置条件，后置条件和断言。

##### 注意
`Expects()`也可以在算法的中间用来检查条件。

##### 注意
不，使用`unsigned`并不是一个好方法来绕过保证值为非负数的问题。

##### 实施
（不可实施）查找可以用断言的各种形式的前置条件是不可行的。在缺少语言设施的情况下，对那些可以容易识别出来的断言（`assert()`）进行警告有可怀疑的价值。

### I.7: 声明后置条件
##### 理由
用以发现关于结果的误解，以及可能捕捉到错误的实现。

##### 示例，不好的
考虑以下代码：
```cpp
int area(int height, int width) { return height * width; }  // 不好的
```
在这里，我们（不小心）遗漏了前置条件的规范说明，因此高度和宽度必须为正数是不清晰的。我们也遗漏了后置条件的规范说明，因此这个算法（`height * width`）对那些大于最大整数的区域是错误的。可能会发生溢出。考虑使用以下做法：
```cpp
int area(int height, int width)
{
    auto res = height * width;
    Ensures(res > 0);
    return res;
}
```

##### 示例，不好的
考虑以下著名的安全缺陷：
```cpp
void f()    // 有问题的
{
    char buffer[MAX];
    // ...
    memset(buffer, 0, sizeof(buffer));
}
```
这里没有后置条件来声明缓冲区应该被擦除，优化器会去掉明显冗余的`memset()`调用：
```cpp
void f()    // 好多了
{
    char buffer[MAX];
    // ...
    memset(buffer, 0, sizeof(buffer));
    Ensures(buffer[0] == 0);
}
```

##### 注意
后置条件通常非正式地在声明函数目的的注释中声明；`Ensures()`可以用来使这更加系统，明显以及可被检查。

##### 注意
当后置条件提到的一些东西在返回结果中没有直接反映出来时，它尤其重要，例如用到的数据结构的状态。

##### 示例
考虑以下函数，该函数操作一个`Record`，使用`mutex`来避免竞争状态：
```cpp
mutex m;

void manipulate(Record& r)    // 不要这样做
{
    m.lock();
    // ... 缺少 m.unlock() ...
}
```
在这里，我们“忘记”声明`mutex`应该被释放，因此我们不知道没有确保释放`mutex`是缺陷还是特性。声明后置条件会使其清晰：
```cpp
void manipulate(Record& r)    // 后置条件：m在退出之前解锁
{
    m.lock();
    // ... 缺少 m.unlock() ...
}
```
这个缺陷现在变得明显了（但只对于人们可读的注释）。

还有更好的方法，使用RAII来确保后置条件（“锁必须释放”）在代码中被实行。
```cpp
void manipulate(Record& r)    // 最好的
{
    lock_guard<mutex> _ {m};
    // ...
}
```

##### 注意
理想情况下，后置条件在接口/声明中声明，因此用户可以容易地看到它们。只有跟用户相关的后置条件可以在接口中声明。只跟内部相关的后置条件在定义/实现中声明。

##### 实施
（不可实施）这是一个哲学的指南，在一般情况下直接检查是不可行的。领域特定的检查器（像持锁检查器）在许多工具链中存在。

### I.8: 优先使用`Ensures()`来表达后置条件
##### 理由
清楚地说明这是后置条件，以及可以使用工具。

##### 示例
```cpp
void f()
{
    char buffer[MAX];
    // ...
    memset(buffer, 0, MAX);
    Ensures(buffer[0] == 0);
}
```

##### 注意
后置条件可以通过许多方式声明，包括注释，`if`语句以及`assert()`。这使得它们难以从普通代码中区分，难以更新，难以通过工具维护，以及可能会有错误的语义。

*替代方案*：“该资源必须释放”形式的后置条件可以通过RAII来最好的表达。

##### 注意
理想情况下，`Ensures`应该是接口的一部分，但这不容易做到。目前，我们把它放在了定义（函数体）中。一旦语言的支持变为可用（例如，参见合同提案）我们会采用标准版本的前置条件，后置条件以及断言。

##### 实施
（不可实施）查找可以用断言的各种形式的后置条件是不可行的。在缺少语言设施的情况下，对那些可以容易识别出来的断言（`assert()`）进行警告有可怀疑的价值。

### I.9: 如果接口是模板，使用概念将它的参数文档化
##### 理由
使接口有精确的说明，以及在（不远的）将来可在编译时检查。

##### 示例
使用需求说明的ISO概念TS风格。例如：
```cpp
template<typename Iter, typename Val>
// requires InputIterator<Iter> && EqualityComparable<ValueType<Iter>>, Val>
Iter find(Iter first, Iter last, Val v)
{
    // ...
}
```

##### 注意
不久之后（可能在2018年），一旦`//`被移除，大多数编译器将能够检查`requires`语句。概念在GCC 6.1及之后的版本提供支持。

*另见*：泛型编程和概念。

##### 实施
（还不能实施）语言设施正在进行规范化。当语言设施可用时，如果任何非可变模板参数不受概念（在它的声明或者`requires`语句中提到的）约束时进行警告。

### I.10: 使用异常来指示执行所需任务的失败
##### 理由
不能忽略错误，因为这会导致系统或者计算处于未定义（或者意外）的状态。这是错误的主要来源。

##### 示例
```cpp
int printf(const char* ...);    // 不好：如果输出失败，返回负数

template <class F, class ...Args>
// 好：如果不能开启新线程，抛出system_error
explicit thread(F&& f, Args&&... args);
```

##### 注意
什么是错误？

错误意味着函数不能实现它所宣称目的（包括建立后置条件）。调用忽略错误的代码会导致不正确的结果或者未定义的系统状态。例如，不能连接到远程服务器本身不算是错误：服务器可能出于各种原因拒绝连接，因此自然的做法是返回一个调用者应该总是检查的结果。当然，如果连接失败被认为是错误，那么这个失败应该抛出异常。

##### 例外
许多传统接口函数（例如UNIX信号处理器）使用错误码（例如`errno`）来报告的事实上是状态码，而不是错误。你没有好的替代方案来使用这些接口，因此调用这些接口不违反本准则。

##### 替代方案
如果你不能使用异常（例如，因为你的代码满是旧式原始指针的使用，或者因为存在硬实时的限制），考虑使用返回一对值的方法：
```cpp
int val;
int error_code;
tie(val, error_code) = do_something();
if (error_code) {
    // ... 处理错误或者退出 ...
}
// ... 使用val ...
```
不幸的是，这种方法会导致未初始化的变量。一个用来处理该问题的结构绑定设施将会在C++17变为可用。
```cpp
auto [val, error_code] = do_something();
if (error_code) {
    // ... 处理错误或者退出 ...
}
// ... 使用val ...
```

##### 注意
我们不认为“性能”是不使用异常的有效理由。
* 通常，显式的错误检查和处理会消耗与异常处理一样多的时间和空间。
* 通常，更简洁的代码在异常下会有更好的性能（简化了在程序中跟踪路径及其优化）。
* 对于注重性能的代码来说，一个良好的准则是把检查从代码的关键部分转移出去（检查）。
* 从长远来看，更规范的代码会得到更好的优化。
* 在做出性能要求之前, 总是要仔细地测量。

*另见*：I.5和I.7对前置条件和后置条件违规的报告。

##### 实施
* （不可实施）这是一个哲学指南，直接检查是不可行的。
* 查找`errno`。

### I.11: 永不通过原始指针（`T*`）或引用（`T&`）转移所有权
##### 理由
如果对是否调用者或被调用者拥有对象存有任何疑问，泄露或者过早的销毁就会发生。

##### 示例
考虑以下代码：
```cpp
X* compute(args)    // 不要这样做
{
    X* res = new X{};
    // ...
    return res;
}
```
谁来释放返回的`x`？如果`compute`返回一个引用，这个问题会更难确认。考虑通过值来返回结果（如果结果庞大的话，使用移动语义）：
```cpp
vector<double> compute(args)  // 好
{
    vector<double> res(10000);
    // ...
    return res;
}
```

*替代方案*：使用“智能指针”传递所有权，例如`unique_ptr`（对独占所有权）和`shared_ptr`（对共享所有权）。当然，与返回对象自己相比，这是更不优雅的，而且通常效率更低，因此只有在需要引用语义的时候才使用智能指针。

*替代方案*：有时由于ABI兼容需要或者缺乏资源而不能修改旧代码。在这种情况下，使用来自指南支持库的`owner`来标记所拥有的指针。
```cpp
owner<X*> compute(args)    // 现在清楚地表明所有权被转移了
{
    owner<X*> res = new X{};
    // ...
    return res;
}
```
这告诉分析工具`res`是一个所有者。也就是说，它的值必须被`delete`删除或者转移给其它所有者，就像这里的`return`所做的那样。

在资源句柄的实现中，`owner`被类似地使用。

##### 注意
每个作为原始指针（或迭代器）传递的对象都假设由调用者拥有，因此它的生命周期由调用者来处理。用另一种方式来看：与传递指针的API相比，所有权转移的API相对更少见，因此默认是“没有所有权转移”。

*另见*：参数传递，智能指针参数的使用，以及值返回。

##### 实施
* （简单）如果用`delete`删除的原始指针不是一个`owner<T>`，发出警告。建议使用标准库的资源句柄或者使用`owner<T>`。
* （简单）在每个代码路径上，如果没有调用`reset`或者显式用`delete`删除一个`owner`指针，发出警告。
* （简单）如果`new`的返回值或者返回`owner`的函数调用赋值给一个原始指针或者非`owner`引用，发出警告。

### I.12: 把必须不能为空的指针声明成`not_null`
##### 理由
帮助避免解引用`nullptr`错误。通过避免冗余的检查`nullptr`来提高性能。

##### 示例
```cpp
int length(const char* p);            // 不清楚length(nullptr)是否有效

length(nullptr);                      // OK?

int length(not_null<const char*> p);  // 好多了：我们可以假设p不能为nullptr

int length(const char* p);            // 我们必须假设p可以为nullptr
```
通过在源代码中声明意图，实现者和工具可以提供更好的诊断，例如通过静态分析发现一些类型的错误，以及更好的优化，例如移除分支和空值检查。

##### 注意
`not_null`在指南支持库中定义。

##### 注意
假设指向`char`的指针是指向C风格字符串（以0结尾的字符串）仍然是隐式的，而且是困惑和错误的潜在来源。优先使用`czstring`来代替`const char*`。
```cpp
// 我们可以假定p不能为nullptr
// 我们可以假定p指向以0结尾的字符数组
int length(not_null<zstring> p);
```
注意：当然，`length()`是`std::strlen()`的伪装。

##### 实施
* （简单）（（基础））如果一个函数在所有控制流路径上，在访问一个指针参数之前都要与`nullptr`检查，那么以应该声明为`not_null`进行警告。
* （复杂）如果一个具有指针返回值的函数保证在所有返回路径上都不为`nullptr`，那么以返回类型应该声明为`not_null`进行警告。

### I.13: 不要把数组作为单一指针来传递
##### 理由
（指针，大小）风格的接口容易出错。而且，（指向数组的）单一指针必须依赖于一些约定来允许被调用者确定大小。

##### 示例
考虑以下代码：
```cpp
void copy_n(const T* p, T* q, int n); // 从 [p:p+n) 复制到 [q:q+n)
```
如果`q`指向的数组有少于`n`个的元素会怎么样？这样的话，我们覆写了一些很可能不相关的内存。如果`p`指向的数组有少于`n`个的元素会怎么样？这样的话，我们读取了一些很可能不相关的内存。这两种情况都是未定义行为，以及潜在的糟糕的缺陷。

##### 替代方案
考虑使用显示的片段：
```cpp
void copy(span<const T> r, span<T> r2); // 复制 r 到 r2
```

##### 示例，不好的
考虑以下代码：
```cpp
void draw(Shape* p, int n);  // 糟糕的接口；糟糕的代码
Circle arr[10];
// ...
draw(arr, 10);
```
传递`10`作为参数`n`可能是一个错误：最常见的习惯用法是假设`[0:n)`，但这没有地方来说明。更坏的是对`draw()`的调用可以通过编译：这里有一个从数组到指针的隐式转换（数组衰变），然后有另一个从`Circle`到`Shape`的隐式转换。`draw()`没有办法可以安全地遍历数组：它没有办法知道元素的个数。

*替代方案*：使用一个辅助类型来保证元素的个数是正确的，以及避免危险的隐式转换。例如：
```cpp
void draw2(span<Circle>);
Circle arr[10];
// ...
draw2(span<Circle>(arr));  // 推导元素的个数
draw2(arr);    // 推导元素的类型和数组大小

void draw3(span<Shape>);
draw3(arr);    // 错误：Circle[10] 不能转换成 span<Shape>
```
`draw2()`传递了相同数量的信息给`draw()`，但它让参数应该是一个`Circle`范围成为显式的。参考???。

##### 例外
使用`string`和`czstring`来表示C风格的，以零结束的字符串。但这样做的时候，使用来自GSL的`string_span`来避免范围错误。

##### 实施
* （简单）（（范围））对任何依赖于从数组类型到指针类型的隐式转换表达式进行警告。允许zstring/czstring指针类型的例外情况。
* （简单）（（范围））对任何基于指针类型、结果也是指针类型的算术操作表达式进行警告。允许zstring/czstring指针类型的例外情况。

### I.22: 避免全局对象的复杂初始化
##### 理由
复杂的初始化会导致不确定的执行顺序。

##### 示例
```cpp
// file1.c

extern const X x;

const Y y = f(x);   // 读取x; 写入y

// file2.c

extern const Y y;

const X x = g(y);   // 读取y; 写入x
```
由于`x`和`y`位于不同的编译单元，调用`f()`和`g()`的顺序是不确定的；其中一个将会访问到未初始化的`const`。这个示例展示了全局（名称空间域）对象的初始化顺序问题不仅限于全局/变量/。

##### 注意
在并发代码中，初始化顺序的问题变得特别难以处理。通常最好完全避免使用全局（名称空间域）对象。

##### 实施
* 标记出那些调用非`constexpr`函数的全局对象的初始化。
* 标记处那些访问`extern`对象的全局对象的初始化。

I.23: 保持少量的函数参数
##### 理由
许多的参数为混乱创造了机会。传递许多参数的开销通常比其它方式更昂贵。

##### 讨论
函数有太多参数的两个最常见的原因是：
1. /缺乏抽象/。由于缺乏抽象，复合的值被作为单一的元素来传递，而不是作为一个保证了不变式的单一对象来传递。这不仅仅扩大了参数列表，而且会导致错误，因为其中的组成值不再被保证了的不变式来保护。
2. /违反了“一个函数，一个职责”/。函数尝试去做多于一件的事情，很可能应该被重构。

##### 示例
标准库的`merge()`处于我们能够轻松处理的极限：
```cpp
template<class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
OutputIterator merge(InputIterator1 first1, InputIterator1 last1,
                     InputIterator2 first2, InputIterator2 last2,
                     OutputIterator result, Compare comp);
```
注意这是因为上面提到的问题1——缺乏抽象。STL不传递范围（抽象），而是传递迭代器对（未封装的组成值）。

这里，我们有四个模板参数和六个函数参数。为了简化最频繁和最简单的用法，用于比较的参数可以默认为`<`：
```cpp
template<class InputIterator1, class InputIterator2, class OutputIterator>
OutputIterator merge(InputIterator1 first1, InputIterator1 last1,
                     InputIterator2 first2, InputIterator2 last2,
                     OutputIterator result);
```
这并没有减少整体的复杂度，但它减少了展现给许多用户的表面复杂度。为了真正地减少参数数量，我们需要把参数打包成更高级的抽象：
```cpp
template<class InputRange1, class InputRange2, class OutputIterator>
OutputIterator merge(InputRange1 r1, InputRange2 r2, OutputIterator result);
```
把参数组合成“包”是一个普遍的技术来减少参数数量，以及增加检查的机会。

另外，我们可以使用概念（在ISO TS中定义）来定义三种类型的概念必须是可以用来合并：
```cpp
Mergeable{In1, In2, Out}
OutputIterator merge(In1 r1, In2 r2, Out result);
```

##### 示例
安全性配置建议把：
```cpp
void f(int* some_ints, int some_ints_length);  // 不好：C风格，不安全
```
替换成
```cpp
void f(gsl::span<int> some_ints);              // 好：安全，有边界检查
```
这里，使用抽象带来安全性和健壮性的好处，而且自然地减少了参数的数量。

##### 注意
多少个参数算是太多？尝试使用少于四（4）个参数。有些函数用四个单独的参数能最好地表示，用更多则不行。

*替代方案*：使用更好的抽象：把参数组合成更具含义的对象，然后传递这个对象（传值或传引用）。

*替代方案*：使用默认参数或者重载，以允许用更少的参数来完成最常见的调用方式。

##### 实施
* 当一个函数声明了两个相同类型的迭代器（包括指针）而不是一个范围或者一个视图时，发出警告。
* （不可实施）这是一个不能直接检查的哲学指南。

### I.24: 避免无关的同类型参数相邻
##### 理由
相邻的同类型参数容易被错误地交换。

##### 示例，不好的
考虑以下代码：
```cpp
void copy_n(T* p, T* q, int n);  // 从[p:p + n)复制到[q:q + n)
```
这是令人讨厌K&R C风格接口的变体。它容易调转了“目标”和“来源”参数。

为“来源”参数使用`const`：
```cpp
void copy_n(const T* p, T* q, int n);  // 从[p:p + n)复制到[q:q + n)
```

##### 例外
如果参数的顺序不重要，那么是没有问题的：
```cpp
int max(int a, int b);
```

##### 替代方案
不要以指针传递数组，传递一个表示范围的对象（例如`span`）：
```cpp
void copy_n(span<const T> p, span<T> q);  // 从p复制到q
```

##### 替代方案
定义一个`struct`作为参数类型，并且相应地给那些参数命名：
```cpp
struct SystemParams {
    string config_file;
    string output_path;
    seconds timeout;
};
void initialize(SystemParams p);
```
这会使得这个函数调用对未来的读者更清晰，因为参数通常在调用点通过名字来赋值。

##### 实施
（简单）如果两个连续的参数拥有相同的类型，发出警告。

### I.25: 优先使用抽象类作为接口而不是类层次结构
##### 理由
相较于有状态的基类，抽象类更可能保持稳定。

##### 示例，不好的
你只知道`Shape`会在某个地方出现 :-)
```cpp
class Shape {  // 不好的: 带有数据的接口类
public:
    Point center() const { return c; }
    virtual void draw() const;
    virtual void rotate(int);
    // ...
private:
    Point c;
    vector<Point> outline;
    Color col;
};
```
这会强迫每个派生类都去计算一个中点——即使这个计算不是轻量的以及这个中点从来不使用。类似的，不是每个`Shape`都有`Color`，而且不使用定义为`Point`序列的轮廓的话，许多`Shape`反而能更好的表示。抽象类用来防止用户写出这样的类：
```cpp
class Shape {    // 好多了: Shape是一个纯接口
public:
    virtual Point center() const = 0;   // 纯接口函数
    virtual void draw() const = 0;
    virtual void rotate(int) = 0;
    // ...
    // ... no data members ...
};
```

##### 实施
（简单）如果一个对类`C`的指针/引用被赋值给一个对类`C`的基类的指针/引用，而且这个基类包含数据成员，发出警告。

### I.26: 如果你想要一个跨编译器的ABI，使用C风格子集
##### 理由
不同的编译器对类、异常处理、函数名称以及其它实现细节实现了不同的二进制布局。

##### 例外
你可以小心地使用一些谨慎选择的高层级C++类型来创造接口。参考???。

##### 例外
在一些平台上出现了常见的ABI，使你摆脱更苛刻的限制。

##### 注意
如果你使用单一的编译器，你可以在接口中使用完整的C++。这可能需要在升级到新的编译器版本之后重新编译。

##### 实施
（不可实施）可靠地识别出接口形成了ABI的哪一部分很困难。

### I.27: 为了得到稳定的库ABI，考虑使用pimpl技巧
##### 理由
由于私有数据成员参与了类布局，私有成员函数参与了重载解析，对这些实现细节的修改需要让所有使用了某个类的用户重新编译。一个非多态的，持有一个指向实现（pimpl）的接口类可以将类的用户从修改中隔离出来，以间接访问作为代价。

##### 示例
接口（widget.h）
```cpp
class widget {
    class impl;
    std::unique_ptr<impl> pimpl;
public:
    void draw(); // 公有API，会被转发给实现
    widget(int); // 在实现文件中定义
    ~widget();   // 在实现文件中定义，在该文件中impl是完整的类型。
    widget(widget&&) = default;
    widget(const widget&) = delete;
    widget& operator=(widget&&); // 在实现文件中定义
    widget& operator=(const widget&) = delete;
};
```
实现（widget.cpp）
```cpp
class widget::impl {
    int n; // 私有数据
public:
    void draw(const widget& w) { /* ... */ }
    impl(int n) : n(n) {}
};
void widget::draw() { pimpl->draw(*this); }
widget::widget(int n) : pimpl{std::make_unique<impl>(n)} {}
widget::~widget() = default;
widget& widget::operator=(widget&&) = default;
```

##### 注意
参见GOTW #100 和cppreference以了解与该技巧相关的权衡和额外的实现细节。

##### 实施
（不可实施）可靠地识别出接口形成了ABI的哪一部分很困难。

### I.30: 封装准则违规
##### 理由
为了保持代码简单和安全。有时候，处于逻辑或性能原因，丑陋、不安全或者容易出错的技术是必要的。如果是这样的话，使它们保持局部，而不是“传染”给接口，导致更大范围的程序员必需感知到这些精妙的存在。实现的复杂度应该——如果可能的话——不能通过接口泄露到用户代码中。

##### 示例
考虑一个程序，它依赖于某种形式的输入（例如`main`的参数），应该从文件、从命令行或者标准输入获取输入。我们可能会写
```cpp
bool owned;
owner<istream*> inp;
switch (source) {
case std_in:        owned = false; inp = &cin;                       break;
case command_line:  owned = true;  inp = new istringstream{argv[2]}; break;
case file:          owned = true;  inp = new ifstream{argv[2]};      break;
}
istream& in = *inp;
```
这违反了“避免未初始化变量”准则，“忽略所有权”准则，以及“避免魔法常量”准则。特别是，某个人必须记得在某个地方写
```cpp
if (owned) delete inp;
```
通过使用`unique_ptr`和一个特别的对`cin`什么也不做的删除器，我们可以处理这个具体的例子，但是这对于新手（容易遇到这个问题的人）来说是复杂的，而且这是一个更普遍问题的例子，即我们认为是静态的属性（在这里是所有权）很少需要在运行时处理。常见的、最频繁的以及最安全地例子可以静态地处理，因此我们不想在那上面增加开销和复杂度。但是我们必须同时应付不常见的、不么安全的以及必要的更昂贵的情况。这些例子在[Str15]中讨论。

因此，我们写了一个类
```cpp
class Istream { [[gsl::suppress(lifetime)]]
public:
    enum Opt { from_line = 1 };
    Istream() { }
    Istream(zstring p) :owned{true}, inp{new ifstream{p}} {}            // 从文件读取
    Istream(zstring p, Opt) :owned{true}, inp{new istringstream{p}} {}  // 从命令行读取
    ~Istream() { if (owned) delete inp; }
    operator istream& () { return *inp; }
private:
    bool owned = false;
    istream* inp = &cin;
};
```
现在，`istream`所有权的动态本质已经被封装起来。一些针对潜在错误的检查大概会添加到实际的代码中。

##### 实施
* 困难，判定哪些违反准则的代码必不可少很困难。
* 标记出那些导致跨接口违反准则的准则抑制。

## F: 函数
一个函数描述了一种行为或者一种计算，使系统从一个一致的状态转变到下一个状态。它是程序的基本构造块。

可以用有确切含义的名称来命名函数，说明其参数的需求，以及清楚地说明参数和结果之间的关系。实现并不是规范说明。尝试去思考一个函数做了什么以及它是如何做到的。函数在大部分接口中是最重要的部分，所以参见接口准则。

函数准则概要：

函数定义准则：
* F.1: 把有确切含义的操作“打包”成谨慎命名的函数
* F.2: 一个函数应该执行单一的逻辑操作
* F.3: 保持函数短小和简单
* F.4: 如果一个函数必须在编译时求值，把它声明为`constexpr`
* F.5: 如果一个函数非常小且对时间很关键，把它声明为内联
* F.6: 如果你的函数不会抛出异常，把它声明为`noexcept`
* F.7: 对于普通用法，使用`T*`或者`T&`作为参数而不是智能指针
* F.8: 优先使用纯函数
* F.9: 不使用的参数应该没有名字

参数传递表达式准则：
* F.15: 优先使用简单和常规的方式来传递信息
* F.16: 对于“输入”参数，拷贝廉价的类型以值方式传递，其它类型以`const`引用方式传递
* F.17: 对于“输入-输出”参数，以非`const`引用方式传递
* F.18: 对于“消费”参数，以`X&&`方式传递并且在参数上使用`std::move`
* F.19: 对于“转发”参数，以`TP&&`方式传递并且只在参数上使用`std::forward`
* F.20: 对于“输出”值，优先使用返回值而不是输出参数
* F.21: 为了返回多个“输出”值，优先返回一个元组或结构
* F.60: 当“无参数”是有效的选项时，优先使用`T*`而不是`T&`

参数传递语义准则：
* F.22: 使用`T*`或`owner<T*>`来表示单一对象
* F.23: 使用`not_null<T>`来指明“null”不是有效的值
* F.24: 使用`span<T>`或`span_p<T>`来表示半开序列
* F.25: 使用`zstring`或`not_null<zstring>`来表示C风格字符串
* F.26: 在需要使用指针的地方，使用`unique_ptr<T>`来转移所有权
* F.27: 使用`shared_ptr<T>`来共享所有权

值返回语义准则：
* F.42: 返回`T*`来指示位置（只用于这种情况）
* F.43: 永不（直接或间接）返回指向局部对象的指针或引用
* F.44: 当不希望拷贝以及不需要“返回无对象”时，返回`T&`
* F.45: 不要返回`T&&`
* F.46: `int`是`main()`的返回值
* F.47: 在赋值操作符中返回`T&`

其它函数准则：
* F.50: 在函数不能达到目的的时候使用lambda（捕捉局部变量，或者写一个局部函数）
* F.51: 在可以选择的时候，优先使用默认参数而不是重载
* F.52: 在局部使用的lambda中，优先以引用来捕获变量，包括传递给算法
* F.53: 在非局部使用的lambda中，避免以引用来捕获变量，包括返回，在堆中存储，或者传递给其它线程
* F.54: 如果你捕获了`this`，显式地捕获所有变量（非默认捕获）
* F.55: 不要使用`va_arg`参数

函数与lambda和函数对象有很强的相似性。

*另见*：C.lambdas: 函数对象和lambda

## F.def: 函数定义
函数定义是指同时描述了函数实现，即函数体的函数声明。

### F.1: 把有确切含义的操作“打包”成谨慎命名的函数
##### 理由
把通用的代码重构出来可以使代码更加可读，更可能被重用，以及限制在复杂代码中出现错误。如果有些东西是具有良好说明的行为，把它从周围的代码中分离出来并且给它一个名称。

##### 示例，不要这样做
```cpp
void read_and_print(istream& is)    // 读取和打印一个int
{
    int x;
    if (is >> x)
        cout << "the int is " << x << '\n';
    else
        cerr << "no int on input\n";
}
```
`read_and_print`中几乎所有东西都是错的。它读，它写（到一个固定的`ostream`），它写错误信息（到一个固定的`ostream`），它只处理`int`。没有东西可以重用，逻辑上独立的操作混合在一起，并且局部变量在它们逻辑使用后的作用域内。对于一个细小的例子，这看起来没问题，但如果输入操作、输出操作和错误处理变得更加复杂的时候，纠缠在一起的混乱会变得难以理解。

##### 注意
如果你写了一个非平凡的lambda，它有潜在的可能性用在多个地方，那么把它赋值给一个（通常是非局部的）变量，以给它一个名字。

##### 示例
```cpp
sort(a, b, [](T x, T y) { return x.rank() < y.rank() && x.value() < y.value(); });
```
命名那个lambda会把表达式分解成它的逻辑部分，并且为lambda的含义提供了强烈的提示。
```cpp
auto lessT = [](T x, T y) { return x.rank() < y.rank() && x.value() < y.value(); };

sort(a, b, lessT);
find_if(a, b, lessT);
```
对于性能或者可维护性来说，最短的代码并不总是最好的。

##### 例外
循环体，包括作为循环体使用的lambda，很少需要被命名。然而，大的循环体（例如，许多行或者许多页）可能会是问题。保持函数短小和简单的准则暗示了“保持循环体短小”。类似的，作为回调参数使用的lambda有时是非平凡的，也不太可能被重用。

##### 实施
* 参见保持函数短小和简单
* 标记在多个不同地方使用的相同或非常相似的lambda

### F.2: 一个函数应该执行单一的逻辑操作
##### 理由
一个执行单一操作的函数更容易理解、测试和重用。

##### 示例
考虑以下代码：
```cpp
void read_and_print()    // 不好的
{
    int x;
    cin >> x;
    // 检查错误
    cout << x << "\n";
}
```
这是与特定输入绑定的庞大单元，永远找不到其它（不同的）用途。相反，应该把函数分解成合适的逻辑部分以及参数化：
```cpp
int read(istream& is)    // 好多了
{
    int x;
    is >> x;
    // 检查错误
    return x;
}

void print(ostream& os, int x)
{
    os << x << "\n";
}
```
这些函数现在可以根据需要来组合：
```cpp
void read_and_print()
{
    auto x = read(cin);
    print(cout, x);
}
```
如果需要的话，我们可以进一步在数据类型、输入/输出机制、对错误的响应等方面模板化`read()`和`print()`。例如：
```cpp
auto read = [](auto& input, auto& value)    // better
{
    input >> value;
    // check for errors
};

auto print(auto& output, const auto& value)
{
    output << value << "\n";
}
```

##### 实施
* 多于一个“输出”参数的函数是值得怀疑的。使用返回值来代替，包括使用`tuple`来返回多个返回值。
* 不能在编辑器的一个屏幕中显示完整的“大型”函数是值得怀疑的。考虑把这类函数重构成更小的具有良好命名的子操作。
* 有7个或以上参数的函数是值得怀疑的。

### F.3: 保持函数短小和简单
##### 理由
大的函数难以阅读，更可能包含复杂的代码，而且更可能包含超出其最小作用域的变量。拥有复杂控制结构的函数更可能长而且更可能隐藏逻辑错误。

##### 示例
考虑以下代码：
```cpp
double simple_func(double val, int flag1, int flag2)
    // simple_func: 获取一个值并且计算出期望的ASIC输出，
    // 基于两个模式标记。
{
    double intermediate;
    if (flag1 > 0) {
        intermediate = func1(val);
        if (flag2 % 2)
             intermediate = sqrt(intermediate);
    }
    else if (flag1 == -1) {
        intermediate = func1(-val);
        if (flag2 % 2)
             intermediate = sqrt(-intermediate);
        flag1 = -flag1;
    }
    if (abs(flag2) > 10) {
        intermediate = func2(intermediate);
    }
    switch (flag2 / 10) {
    case 1: if (flag1 == -1) return finalize(intermediate, 1.171);
            break;
    case 2: return finalize(intermediate, 13.1);
    default: break;
    }
    return finalize(intermediate, 0.);
}
```
这过于复杂（和长）。你怎么知道是否所有可能的分支情况都被正确地处理了呢？是的，它也违反了其它准则。

我们可以重构：
```cpp
double func1_muon(double val, int flag)
{
    // ???
}

double funct1_tau(double val, int flag1, int flag2)
{
    // ???
}

double simple_func(double val, int flag1, int flag2)
    // simple_func: 获取一个值并且计算出期望的ASIC输出，
    // 基于两个模式标记。
{
    if (flag1 > 0)
        return func1_muon(val, flag2);
    if (flag1 == -1)
        // 在func1_tau中处理: flag1 = -flag1;
        return func1_tau(-val, flag1, flag2);
    return 0.;
}
```

##### 注意
“不能在一屏中显示完整”通常是“太大”的一个良好、切实可行的定义。一到五行的函数应该认为是正常的。

##### 注意
把大的函数拆分成更小的内聚和命名的函数。当函数调用的开销变得重要时，短小简单的函数容易被内联。

##### 实施
* 标记出“不能在一屏中显示完整”的函数。一屏是多大？试试60行，每行140个字符；这大致是适合书页的最大值。
* 标记出过于复杂的函数。多复杂算是太复杂？你可以使用圈复杂度。试试“超过10个逻辑路径”。将一个简单的分支算作一个路径。

### F.4: 如果一个函数必须在编译时求值，把它声明为`constexpr`
##### 理由
`constexpr`用来告诉编译器允许编译时求值。

##### 示例
（不）著名的阶乘：
```cpp
constexpr int fac(int n)
{
    constexpr int max_exp = 17;      // constexpr允许max_exp在Expects中使用
    Expects(0 <= n && n < max_exp);  // 避免愚蠢和溢出
    int x = 1;
    for (int i = 2; i <= n; ++i) x *= i;
    return x;
}
```
这是C++14。对于C++11，使用`fac()`的递归形式。

##### 注意
`constexpr`不保证编译时求值；它只保证函数可以对常量表达式参数在编译时求值，在程序员要求这么做或者编译器决定这么做来优化的时候。
```cpp
constexpr int min(int x, int y) { return x < y ? x : y; }

void test(int v)
{
    int m1 = min(-1, 2);            // 可能是编译时求值
    constexpr int m2 = min(-1, 2);  // 编译时求值
    int m3 = min(-1, v);            // 运行时求值
    constexpr int m4 = min(-1, v);  // 错误：不能在编译时求值
}
```

##### 注意
`constexpr`函数是纯的：它们不能有副作用。
```cpp
int dcount = 0;
constexpr int double(int v)
{
    ++dcount;   // 错误：在constexpr函数中企图有副作用
    return v + v;
}
```
通常这是非常好的事情。

当给定一个非常量参数，`constexpr`函数会抛出异常。如果你认为抛出异常来退出是一个副作用，那么`constexpr`函数不是完全纯的；否则，这就不是问题。??? 留给委员会的一个问题：一个被`constexpr`函数抛出的异常的构造函数能否修改状态？“不能”会是一个好的答案，符合大部分的实践。

##### 注意
不要尝试把所有函数声明成`constexpr`。大部分计算最好在运行时完成。

##### 注意
最终依赖高层级运行时配置或者业务逻辑的任何API都不应该为`constexpr`。这种定制不能由编译器求值，而且任何依赖于这些API的`constexpr`函数都必须重构或者去掉`constexpr`。

##### 实施
不可能也没必要。如果在需要常量的地方调用了一个非`constexpr`函数，编译器会给出错误。

##### F.5: 如果函数非常短小并且对时间很关键，把它声明为`inline`
##### 理由
在没有程序员的提示下，有些优化器也能做好内联，但不要依赖这种情况。要进行测量！在过去的40年左右，我们已经承诺会有那么一个编译器，在人们没有提示的情况下，它的内联可以比人们做得更好。我们仍然在等待。指定`inline`促使编译器做得更好。

##### 示例
```cpp
inline string cat(const string& s, const string& s2) { return s + s2; }
```

##### 例外
不要把`inline`函数放到被认为是稳定的接口中，除非你确定它不会改变。内联函数是ABI的一部分。

##### 注意
`constexpr`暗含了`inline`。

##### 注意
在类内部定义的成员函数默认是`inline`。

##### 例外
模板函数（包括模板成员函数）通常定义在头文件中，因此是内联的。

##### 实施
标记那些超过三个语句，并且可能已经在行外声明的`inline`函数（例如类成员函数）。

### F.6: 如果你的函数不会抛出异常，把它声明为`noexcept`
##### 理由
如果不应该抛出异常，那么不能假定程序会应付错误，并且应该尽快结束。把函数声明为`noexcept`有助于优化器减少额外的执行路径的数量。它也会提高在失败后退出的速度。

##### 示例
为每个完全用C或其它没有异常的语言写的函数加上`noexcept`。C++标准库对C标准库中的所有函数都隐式地做了这个声明。

##### 注意
在运行时求值的时候，`constexpr`函数可能会抛异常，所以对于这其中的一些函数你可能需要`noexcept`。

##### 示例
你甚至可以在会抛异常的函数上使用`noexcept`：
```cpp
vector<string> collect(istream& is) noexcept
{
    vector<string> res;
    for (string s; is >> s;)
        res.push_back(s);
    return res;
}
```
如果`collect()`耗尽了内存，程序会崩溃。除非程序被制作成可以在内存不足时存活，这可能只是要做的正确事情；`terminate()`会生成合适的错误日志信息（但是在内存耗尽之后，难以做任何聪明的事情）。

##### 注意
当在决定是否为函数加上`noexcept`的时候，你必须意识到你的代码正在运行的执行环境，尤其是因为抛异常和分配的问题。想要完全通用的代码（像标准库和其它这类的工具代码）需要支持可以有意义地处理`bad_alloc`异常的环境。然而，大部分程序和执行环境不能有意义地处理分配失败，在那些情况下，终止程序是对分配失败最干净和最简单的回应。如果你知道你的程序代码不能回应分配失败，那么即使在分配函数上添加`noexcept`也可能是合适的。

换种方式：在大部分程序中，大部分函数会抛异常（例如，由于它们使用了`new`，调用了会这么做的函数，或者使用了通过抛异常来报告失败的库函数），所以不要只是把`noexcept`散播到所有地方，而不考虑可能的异常是否能被处理。

对于频繁使用、低层级的函数来说，`noexcept`是最有用的（而且也是最清晰正确的）。

##### 注意
析构函数、`swap`函数、移动操作符以及默认构造函数应该永不抛出异常。

##### 实施
* 标记出会抛异常的`swap`、`move`、析构函数和默认构造函数。
* 标记出没有`noexcept`也不会抛异常的函数。

### F.7: 对于普通用法，使用`T*`或者`T&`作为参数而不是智能指针
##### 理由
传递智能指针会转移或共享所有权，应该只有在需要所有权语义的时候才使用（参考R.30）。传递智能指针限制了函数只能由使用智能指针的调用者使用。传递共享智能指针（例如`std::shared_ptr`）隐含了运行时开销。

##### 示例
```cpp
// 接受任何int*
void f(int*);

// 只能接受那些你想转移所有权的int
void g(unique_ptr<int>);

// 只能接受那些你想共享所有权的int
void g(shared_ptr<int>);

// 不改变所有权，但要求调用方有特定的所有权
void h(const unique_ptr<int>&);

// 接受任何int
void h(int&);
```

##### 示例，不好的
```cpp
// 被调用者
void f(shared_ptr<widget>& w)
{
    // ...
    use(*w); // 只使用了w——生命周期根本没有使用
    // ...
};
```
参考R.30获取更多信息。

##### 注意
我们可以静态地捕获悬挂指针，所以我们不需要依赖资源管理来避免来自悬挂指针的违规行为。

##### 另见
* 当“没有参数”是有效的选项时，优先使用`T*`而不是`T&`
* 智能指针准则概要

##### 实施
标记出所有权语义没有被使用的智能指针类型（重载了`operator->`或`operator*`的类型）参数；也就是说：
* 可复制但从不复制/移动，或者可移动但从不移动
* 并且从不修改或者传递给其它会这样做的函数。

### F.8: 优先使用单纯函数
##### 理由
单纯函数更容易推理，有时更容易优化（甚至并行化），并且有时可以做备忘缓存。

##### 示例
```cpp
template<class T>
auto square(T t) { return t * t; }
```

##### 注意
`constexpr`函数是单纯的。

当给定一个非常量参数时，`constexpr`函数会抛出异常。如果你认为抛出异常来退出是一个副作用，那么`constexpr`函数不是完全纯的；否则，这就不是问题。??? 留给委员会的一个问题：一个被`constexpr`函数抛出的异常的构造函数能否修改状态？“不能”会是一个好的答案，符合大部分的实践。

##### 实施
不可能。

### F.9: 不使用的参数应该没有名字
##### 理由
可读性。防止出现未使用参数警告。

##### 示例
```cpp
X* find(map<Blob>& m, const string& s, Hint);   // 提示（hint）曾经被使用过
```

##### 注意
允许参数未命名在1980年代早期引入来处理这个问题。

##### 实施
标记出命名的未使用参数。

## F.call: 参数传递
有多种方式来传递参数给函数或者返回值。

### F.15: 优先使用简单和常规的方式来传递信息
##### 理由
使用“与众不同和聪明”的技术会导致意想不到的事情，给其他程序员的理解造成负担，并且容易出现缺陷。如果你真的觉得需要使用超出常见技术的优化，进行测量来确保它真的有提升，并且写好文档/注释，因为这个提升也许不是可移植的。

下面的表格总结了后续指南F.16-21的建议。

普通参数传递：
[image:245B84B0-CCF1-49EA-9563-FF6A685693DF-22679-0002673998E1A97C/537D1B91-819D-4F17-A8FE-DA2C52EC1542.png]

高级参数传递：

[image:157228FA-70C5-4EB9-B07B-683D029432D4-22679-0002673E0B8DFBEA/A4C776D2-B212-46BC-B1C7-D901FBE531F3.png]

仅在证实了需求之后才使用高级技术，并且在注释中做好这个需求的文档。

### F.16: 对于“输入”参数，拷贝廉价的类型以值方式传递，其它类型以`const`引用方式传递
##### 理由
两种方式都让调用者知道函数不会修改参数，并且两者都允许以右值初始化。

什么是“拷贝廉价”取决于机器架构，但两个或三个字的类型（双精度浮点数，指针，引用）通常最好以值来传递。当拷贝是廉价时，没有东西可以胜过拷贝的简洁性和安全性，并且对于小对象（多达两个或三个字）来说，拷贝也会比通过引用传递快，因为它不需要在函数中进行一次额外的间接访问。

##### 示例
```cpp
void f1(const string& s);  // 好的：以const引用传递；总是廉价的

void f2(string s);         // 不好的：有潜在的昂贵

void f3(int x);            // 好的：不可超越

void f4(const int& x);     // 不好的：: 在f4()中有访问开销
```

（仅）对于高级用法，你确实需要对传递给“只用于输入”的右值进行优化的场景：
* 如果函数将会无条件地从参数移动，通过`&&`来接收它。参见F.18。
* 如果函数将会保留参数的拷贝，除了通过`const&`传递（针对左值）之外，添加一个通过`&&`传递（针对右值）参数的重载，并且在函数体中用`std::move`移动到它的目标。本质上，这种做法重载了一个“消费”；参见F.18。
* 在特殊情况下，例如多个“输入+拷贝”参数，考虑使用完美转发。参考F.19。

##### 示例
```cpp
int multiply(int, int); // 只输入整数，以值传递

// suffix是只用于输入，但没有int那么廉价，以const&传递
string& concatenate(string&, const string& suffix);

void sink(unique_ptr<widget>);  // 只用于输入，并且消费了widget
```

避免“深奥的技术”，例如：
* “为了效率”以`T&&`传递参数。大部分关于用`&&`传递的性能优势的谣言都是错误的或者经不起推敲的（但是参见F.18和F.19）。
* 从赋值操作符和类似的操作中返回`const T&`（参见F.47）。

##### 示例
假设`Matrix`具有移动操作（可能通过在一个`std::vector`中保存元素）：
```cpp
Matrix operator+(const Matrix& a, const Matrix& b)
{
    Matrix res;
    // ... 用sum填充res ...
    return res;
}

Matrix x = m1 + m2;  // 移动构造

y = m3 + m3;         // 移动赋值
```

##### 注意
返回值优化不会处理赋值情况，但是移动赋值会。

可以假定一个引用指向一个有效的对象（语言规则）。不存在（合理的）“空引用”。如果你需要一个可选值的概念，使用指针、`std::optional`、或者用来表示“没有值”的特殊值。

##### 实施
* （简单）（（基础））当一个以值传递的参数具有大于`4 * sizeof(int)`的大小，发出警告。建议使用`const`引用代替。
* （简单）（（基础））当一个以引用传递的`const`参数具有小于`3 * sizeof(int)`的大小，发出警告。建议以值传递代替。
* （简单）（（基础））当一个以引用传递的`const`参数是经过了`std::move`移动的，发出警告。

### F.17: 对“输入输出”参数，以非`const`引用来传递
##### 理由
这会让调用者清楚地知道对象是会被修改的。

##### 示例
```cpp
void update(Record& r);  // 假设更新会写到r
```

##### 注意
一个`T&`参数可以传递信息进函数也可以传出去。因此`T&`可以是一个输入输出参数。这本身可能是一个问题和错误的来源：
```cpp
void f(string& s)
{
    s = "New York";  // 不明显的错误
}

void g()
{
    string buffer = ".................................";
    f(buffer);
    // ...
}
```
这里，`g()`的作者提供了一个缓冲区给`f()`填充，但是`f()`简单地替换了它（以某种程度上比简单地复制字符更高的成本）。如果`g()`的作者不正确地假设了`buffer`的大小，可能会出现严重的逻辑错误。

##### 实施
* （中等）（（基础））对于不写入非`const`参数的函数发出警告。
* （简单）（（基础））当一个以引用来传递的非`const`参数是经过了`std::move`移动的，发出警告。

### F.18: 对于“消费”参数，以`X&&`传递并且用`std::move`移动参数
##### 理由
这是高效的，并且能在调用方排除缺陷：`X&&`绑定到右值，如果传递的是左值，在调用方需要显式地使用`std::move`。

##### 示例
```cpp
void sink(vector<int>&& v) {   // sink获取了所有参数拥有的所有权
    // 在这里通常可能会有对v的const访问
    store_somewhere(std::move(v));
    // 在这里通常再也没有对v的使用；它被移走了
}
```
注意`std::move(v)`使得`store_somewhere()`能够把`v`变成被移走状态。这可能是危险的。

##### 例外
只能移动并且移动廉价的唯一所有者类型，例如`unique_ptr`，也能够以值来传递，这会写得更简单并且能达到同样的效果。以值传递的确会生成一个额外的（廉价的）移动操作，但首选简洁性和清晰性。

例如：
```cpp
template <class T>
void sink(std::unique_ptr<T> p) {
    // 使用p ... 可能在别的地方使用了std::move(p)
}   // p被销毁
```

##### 实施
* 标记所有在函数体中没有以`std::move`使用的`X&&`参数（这里`X`不是模板类型参数名称）。
* 标记对已移走对象的访问。
* 不要有条件性地移动对象。

### F.19: 对于“转发”参数，以`TP&&`传递并且只使用`std::forward`转发参数
##### 理由
如果对象被传递给其它代码并且不会被这个函数直接使用，我们要让这个函数不感知参数的常量性和右值性。

在且仅在这种情况下，使参数为`TP&&`，这里`TP`是一个模板类型参数——它同时忽略和保留了常量性和右值性。因此任何使用了`TP&&`的代码隐式地声明了它自己不会关心变量的常量性和右值性（因为被忽略了），但是会把值传递给其它关心常量性和右值性的代码（因为被保留了）。当作为参数使用时`TP&&`是安全的，因为任何从调用者传递来的临时对象会在函数的调用期间中存活。一个类型为`TP&&`的参数应该本质上总是在函数体中通过`std::forward`向前传递。

##### 示例
```cpp
template <class F, class... Args>
inline auto invoke(F f, Args&&... args) {
    return f(forward<Args>(args)...);
}

??? 调用 ???
```

### 实施
* 如果一个函数接受`TP&&`参数（这里`TP`是模板类型参数名称），并且除了在每个静态路径上只用`std::forward`转发它一次之外，还做了其它任何事情，标记这个函数。

### F.20: 对于“输出”输出值，优先使用返回值而不是输出参数
##### 理由
返回值是自带文档的，而`&`可以是输入输出的或者仅输出的，可能被误用。

这包括了大型对象，比如标准容器，它们为了性能使用隐式的移动操作，避免显式的内存管理。

如果你有多个值要返回，使用元祖或者类似的多成员类型。

##### 示例
```cpp
// 好的：返回指向值与x相同的元素的指针
vector<const int*> find_all(const vector<int>&, int x);

// 不好的：在out中存放指向值与x相同的元素的指针
void find_all(const vector<int>&, vector<const int*>& out, int x);
```

##### 注意
一个包含许多元素（各自是移动廉价）的`struct`可能整体上的移动是昂贵的。

不建议返回一个`const`值。这些老的建议现在被淘汰了；它没有增添价值，并且会妨碍移动语义。
```cpp
const vector<int> fct();    // 不好的：那个“const”比它的价值带来更多麻烦

vector<int> g(const vector<int>& vx)
{
    // ...
    fct() = vx;   // 被“const”阻止
    // ...
    return fct(); // 昂贵的拷贝：移动语义被“const”抑制了
}
```
关于添加`const`到返回值的争论是，它避免（非常少的）对临时对象的意外访问。对立的争论是它阻止（非常频繁的）移动语义的使用。

##### 例外
* 对于非值类型，例如在继承层次结构中的类型，以`unique_ptr`或`shared_ptr`返回对象。
* 如果类型移动昂贵（例如，`array<BigPID>`），考虑在自由存储上分配它并且返回一个句柄（例如，`unique_ptr`），或者在一个非`const`引用的目标对象上传递它来填充（作为输出参数来使用）。
* 为了在一个内部循环的多个函数调用之间重用带有容量的对象（例如，`std::string`，`std::vector`）：把它当成输入/输出参数并且以引用传递。

##### 示例
```cpp
struct Package {      // 例外情况：移动昂贵的对象
    char header[16];
    char load[2024 - 16];
};

Package fill();       // 不好的：大的返回值
void fill(Package&);  // 好的

int val();            // 好的
void val(int&);       // 不好的：val是否会读取它的参数？
```

##### 实施
* 标记那些在被写入之前没有读取并且其类型的返回是廉价的非`const`引用参数；它们应该是“输出”返回值。
* 标记返回一个`const`值的情况。修复：移除`const`来返回一个非`const`值。

### F.21: 为了返回多个“输出”值，优先返回元组或结构
##### 理由
作为一个“仅输出”值，返回值自带文档。注意C++没有多个返回值，通过使用`tuple`（包括`pair`）的约定，可能在调用方使用`tie`会有额外的便利。

##### 示例
```cpp
// 不好的：在注释中标注仅输出参数
int f(const string& input, /*output only*/ string& output_data)
{
    // ...
    output_data = something();
    return status;
}

// 好的：自带文档
tuple<int, string> f(const string& input)
{
    // ...
    return make_tuple(status, something());
}
```
C++98的标准库已经使用了这种方式，因为`pair`就像两个元素`tuple`。例如，给定一个`set<string> my_set`，考虑以下代码：
```cpp
// C++98
result = my_set.insert("Hello");
if (result.second) do_something_with(result.first);    // workaround
```
在C++11中我们可以这样写，把结果直接放在已有的局部变量中：
```cpp
Sometype iter;                                // 如果我们还没有值，使用默认初始化
Someothertype success;                        // 为了一些其它目的使用这些变量

tie(iter, success) = my_set.insert("Hello");   // 普通返回值
if (success) do_something_with(iter);
```
在C++17中我们应该能够使用“结构绑定”来声明和初始化多个变量：
```cpp
if (auto [ iter, success ] = my_set.insert("Hello"); success) do_something_with(iter);
```

##### 例外
有时候，我们需要传递一个对象给函数来维护它的状态。在这种情况下，以引用`T&`传递对象通常是正确的技术。显式用返回值再次把一个输入输出参数传出来通常是不必要的。例如：
```cpp
istream& operator>>(istream& is, string& s);    // 很像std::operator>>()

for (string s; cin >> s; ) {
    // do something with line
}
```
这里，`s`和`cin`都作为输入输出参数使用。我们以（非`const`）引用传递`cin`以便能够维护它的状态。我们传递`s`来避免重复的分配。通过重用`s`（以引用传递），我们只在需要扩大`s`的容量时才分配新内存。这个技术有时称为“调用者分配的输出”模式，而且对于需要进行自由存储分配的类型，如`string`和`vector`特别有用。

作为对比，如果我们把所有值作为返回值传出来，我们会有类似下面的代码：
```cpp
pair<istream&, string> get_string(istream& is);  // 不建议
{
    string s;
    is >> s;
    return {is, s};
}

for (auto p = get_string(cin); p.first; ) {
    // 用p.second做些事情
}
```
我们认为明显不那么优雅比明显降低性能好。

为了真正严格地阅读这条准则（F.21），这个例外不是真的例外，因为它依赖于输入输出参数，而不是在这条准则中提到的纯粹的输出参数。然而，我们更想要清晰，而不是模糊。

##### 注意
在许多情况下，返回一个特定的，用户定义的类型可能有用。例如：
```cpp
struct Distance {
    int value;
    int unit = 1;   // 1表示米
};

Distance d1 = measure(obj1);        // 访问d1.value和d1.unit
auto d2 = measure(obj2);            // 访问d2.value和d2.unit
auto [value, unit] = measure(obj3); // 访问value和unit；对于了解measure()的人来说稍微多余
auto [x, y] = measure(obj4);        // 不要这样做；这可能会使人困惑
```
过于通用的`pair`和`tuple`应该仅在返回的值表示独立实体而不是抽象时使用。

其它示例，使用一个特定的类型和`variant<T, error_code>`一起使用，而不是使用通用的`tuple`。

##### 实施
* 输出参数应该用返回值来替换。输出参数是函数会写入，用来调用非`const`成员函数，或者以非`const`传递的参数。

### F.22: 使用`T*`或者`owner<T*>`来表示单一对象
##### 理由
可读性：它使得纯指针的意义更清晰。开启重要工具的支持。

##### 注意
在传统的C和C++代码中，纯`T*`用在许多弱相关的目的，例如：
* 标识一个（单一）对象（不能被这个函数删除）
* 指向一个在自由存储上分配的对象（在稍后删除）
* 持有`nullptr`
* 标识一个C风格字符串（以零结尾的字符数组）
* 与一个分开指定的长度一起标识一个数组
* 标识一个数组中的位置
这会难以理解代码做了什么和它应该做什么。它使得检查和工具支持复杂化。

##### 示例
```cpp
void use(int* p, int n, char* s, int* q)
{
    p[n - 1] = 666; // 不好的：我们不知道p是否指向n个元素；
                    // 假设它没有或不使用span<int>
    cout << s;      // 不好的：我们不知道s是否指向一个以零结尾的字符数组
                    // 假设它没有或不使用zstring
    delete q;       // 不好的：我们不知道*q是否在自由存储上分配的
                    // 假设它没有或不使用owner
}
```
更好的做法
```cpp
void use2(span<int> p, zstring s, owner<int*> q)
{
    p[p.size() - 1] = 666; // 好的，可以捕捉范围错误
    cout << s; // 好的
    delete q;  // 好的
}
```

##### 注意
`owner<T*>`表示所有权，`zstring`表示C风格字符串。

*而且*：假设从一个指向`T`的智能指针（例如，`unique_ptr<T>`）获取的`T*`指向一个单一元素。

*另见*：支持库

##### 实施
* （简单）（（边界））对作用在指针类型表达式上，并且结果是指针类型的算术操作发出警告。

### F.23: 使用`not_null<T>`来指明“null”不是有效值
##### 理由
清晰性。带有`not_null<T>`参数的函数清楚地表明了函数的调用者有责任对任何`nullptr`进行必要的检查。类似的，带有`not_null<T>`返回值的函数清楚地表明了函数的调用者不需要检查`nullptr`。

##### 示例
`not_null<T*>`让读者（人或机器）明显地知道在解引用之前检查`nullptr`是不必要的。另外，在调试的时候，`owner<T*>`和`not_null<T>`可以用来进行正确性检查。

考虑以下代码：
```cpp
int length(Record* p);
```
当我调用`length(p)`的时候我应该先检查`p`是否为`nullptr`吗？`length()`的实现应该检查`p`是否为`nullptr`吗？
```cpp
// 调用者要确保 p != nullptr
int length(not_null<Record*> p);

// length()的实现必须假设 p == nullptr 是可能的
int length(Record* p);
```

##### 注意
`not_null<T*>`是不为`nullptr`的；`T*`可以为`nullptr`；两者在内存中都可以通过`T*`来表示（因此没有隐含运行时开销）。

##### 注意
`not_null`不仅用于内置指针。它可用于`unique_ptr`，`shared_ptr`，以及其它类似指针的类型。

##### 实施
（简单）在一个函数内，如果一个原始指针在解引用之前没有与`nullptr`进行比较（或者等同的操作），发出警告，建议把它声明为`not_null`。
（简单）在一个函数内，如果一个原始指针有时先与`nullptr`进行比较（或者等同的操作）之后再解引用，有时又没有这么做，发出错误。
（简单）在一个函数内，如果一个`not_null`指针与`nullptr`进行比较，发出警告。

### F.24: 使用`span<T>`或`span_p<T>`来表示半开序列
##### 理由
随便的/不明显的区间是错误的来源。

##### 示例
```cpp
X* find(span<X> r, const X& v);    // 在r中查找v

vector<X> vec;
// ...
auto p = find({vec.begin(), vec.end()}, X{});  // 在vec中查找X{}
```

##### 注意
在C++代码中区间非常常见。通常，它们是隐式的而且很难保证它们被正确使用。特别是，给定一对参数`(p, n)`来表示一个数组`[p:p+n)`，一般不可能知道在`*p`后面是否真的有n个元素。`span<T>`和`span_p<T>`是简单的辅助类型，分别表示一个`[p:q)`区间，以及一个以`p`开头并且以判断式为真的首个元素结尾的区间。

##### 示例
`span`表示一个元素区间，但我们如何操作这个区间的元素？
```cpp
void f(span<int> s)
{
    // 区间遍历（正确性得到保障）
    for (int x : s) cout << x << '\n';

    // C风格遍历（有内在的检查）
    for (gsl::index i = 0; i < s.size(); ++i) cout << s[i] << '\n';

    // 随机访问（有内在的检查）
    s[7] = 9;

    // 提取指针（有内在的检查）
    std::sort(&s[0], &s[s.size() / 2]);
}
```

##### 注意
`span<T>`对象不会拥有的元素，而且它小得可以以值来传递。

传递`span`对象作为参数与传递一对指针参数或者传递一个指针和一个整数个数的效率一样高。

*另见*：支持库

##### 实施
（复杂）当访问一个通过其它整数类型指定边界的指针参数时，发出警告，并且建议他们使用`span`。

### F.25: 使用`zstring`或者`not_null<zstring>`来表示C风格字符串
##### 理由
C风格字符串是普遍存在的。它们通过约定来定义：以零字符结尾的字符数组。我们必须把C风格字符与单个字符的指针或者旧式的字符数组指针区分开来。

##### 示例
考虑以下代码：
```cpp
int length(const char* p);
```
当我调用`length(s)`的时候我应该检查`s`是否为`nullptr`吗？`length()`的实现应该检查`p`是否为`nullptr`吗？
```cpp
// length()的实现必须假设p == nullptr是可能的
int length(zstring p);

// 调用者要保证p != nullptr
int length(not_null<zstring> p);
```

##### 注意
`zstring`不表示所有权。

*另见*：支持库

##### F.26: 在需要使用指针的地方，使用`unique_ptr<T>`来转移所有权
##### 理由
使用`unique_ptr`是安全传递指针最廉价的方式。

*另见*：C.50 考虑什么时候从工厂中返回`shared_ptr`。

##### 示例
```cpp
unique_ptr<Shape> get_shape(istream& is)  // 从输入流中组装形状
{
    auto kind = read_header(is); // 读取头部并且在输入中标识下一个形状
    switch (kind) {
    case kCircle:
        return make_unique<Circle>(is);
    case kTriangle:
        return make_unique<Triangle>(is);
    // ...
    }
}
```

##### 注意
如果你转移的是一个来自类层次结构的对象，并且这个类层次结构被（作为基类）使用在接口中，那么你需要传递一个指针而不是一个对象。

##### 实施
（简单）如果一个函数返回一个局部分配的原始指针，发出警告。建议使用`unique_ptr`或者`shared_ptr`代替。

### F.27: 使用`shared_ptr<T>`共享所有权
##### 理由
使用`shared_ptr`是表示共享所有权的标准方式。也就是说，最后一个所有者删除对象。

##### 示例
```cpp
shared_ptr<const Image> im { read_image(somewhere) };

std::thread t0 {shade, args0, top_left, im};
std::thread t1 {shade, args1, top_right, im};
std::thread t2 {shade, args2, bottom_left, im};
std::thread t3 {shade, args3, bottom_right, im};

// 分离线程
// 最后一个结束的线程删除图像
```

##### 注意
如果在同一时刻从来不会有多于一个的所有者，`unique_ptr`优先于`shared_ptr`。`shared_ptr`用来共享所有权。

注意大量使用的`shared_ptr`会带来开销（在`shared_ptr`引用计数上的原子操作有显著的总体开销）。

##### 替代方案
以一个单一对象持有共享对象（例如，一个作用域范围内的对象），当所有用户都使用完之后删除它（最好是隐式的）。

##### 实施
（不可实施）可靠地检测这个模式太复杂了。

### F.60: 当“无参数”是有效的选项时，优先使用`T*`而不是`T&`
##### 理由
指针（`T*`）可以是`nullptr`而引用（`T&`）不能，不存在有效的“空引用”。有时使用`nullptr`作为一个选择来表示“无对象”是有用的，但如果不是这样，引用从符号表示法上来说更简单而且会产出更好的代码。

##### 示例
```cpp
string zstring_to_string(zstring p) // zstring是char*；即C风格字符串
{
    if (!p) return string{};    // p可能是nullptr；记得检查
    return string{p};
}

void print(const vector<int>& r)
{
    // r引用一个vector<int>；不需要检查
}
```

##### 注意
构造一个本质上是`nullptr`的引用是可能的，但这不是合理的C++（例如，`T* p = nullptr; T& r = (T&)*p`）。这种错误是非常罕见的。

##### 注意
如果你更喜欢指针表示法（`->`和/或`*`对比`.`），`not_null<T*>`提供了与`T&`同样的保证。

##### 实施
* 标记???

### F.42: 返回`T*`来指示位置（只用于这种情况）
##### 理由
这是指针擅长的地方。返回`T*`来转移所有权是一个错误用法。

##### 示例
```cpp
Node* find(Node* t, const string& s)  // 在Node的二叉树上查找s
{
    if (!t || t->name == s) return t;
    if ((auto p = find(t->left, s))) return p;
    if ((auto p = find(t->right, s))) return p;
    return nullptr;
}
```
如果`find`返回的指针不为`nullptr`，它表示一个持有`s`的`Node`。重要的是，它没有隐式地把所指对象的所有权转移给调用者。

##### 注意
位置也可以通过迭代器、索引和引用来传递。如果没有必要使用`nullptr`，或者如果指向的对象不应该改变，引用通常是比指针更好的选择。

##### 注意
不要返回指向不在调用者作用域范围内的东西的指针；参阅F.43。

*另见*：避免悬挂指针的讨论

##### 实施
* 标记作用在纯`T*`上的`delete`、`std::free()`等。只有所有者才应该删除。
* 标记赋值给纯`T*`的`new`、`malloc()`等。只有所有者才负责删除。

##### F.43: 永不（直接或间接）返回指向局部对象的指针或引用
##### 理由
避免由于使用悬挂指针导致的崩溃和数据损坏。

##### 示例，不好的
```cpp
int* f()
{
    int fx = 9;
    return &fx;  // 不好的
}

void g(int* p)   // 看起来足够无辜
{
    int gx;
    cout << "*p == " << *p << '\n';
    *p = 999;
    cout << "gx == " << gx << '\n';
}

void h()
{
    int* p = f();
    int z = *p;  // 从废弃的栈帧上读取（不好的）
    g(p);        // 传递指向废弃栈帧的指针给函数（不好的）
}
```
这里，在一个流行的实现上我得到以下输出：
```
*p == 999
gx == 999
```
我猜测这是因为`g()`的调用重用了`f()`的调用废弃的栈空间，因此`*p`指向的空间现在被`gx`占用了。
* 想像一下如果`fx`和`gx`是不同的类型会怎样。
* 想像一下如果`fx`和`gx`是一个具有不变式的类型会怎样。
* 想像一下如果更多的这种悬挂指针在更大的函数集之间传递会怎样。
* 想像一下骇客会用这个悬挂指针来做什么。
幸运的是，大部分（全部？）现代编译器会捕获并警告这个简单的场景。

##### 注意
这也适用于引用：
```cpp
int& f()
{
    int x = 7;
    // ...
    return x;  // 不好的：返回对即将销毁的对象的引用
}
```

##### 注意
这只适用于非`static`的局部变量。所有`static`变量都是静态分配的（正如它们的名称所示），因此指向它们的指针不会变成悬挂。

##### 示例，不好的
并非所有泄露指向局部变量的指针的案例都是那么明显：
```cpp
int* glob;       // 全局变量在许多方面都是不好的

template<class T>
void steal(T x)
{
    glob = x();  // 不好的
}

void f()
{
    int i = 99;
    steal([&] { return &i; });
}

int main()
{
    f();
    cout << *glob << '\n';
}
```
这里，我设法读取被`f`的调用废弃的位置。储存在`glob`中的指针可能很晚才使用，并且以不可预知的方式造成麻烦。

##### 注意
局部变量的地址可以被这些方式“返回”/泄露：通过返回语句，通过一个`T&`输出参数，作为一个返回对象的成员，作为一个返回数组的元素，以及更多的方式。

##### 注意
从一个内部作用域“泄露”指针到外部作用域的类似例子可以被构造出来；这些例子与泄露指针到函数外部同等看待。

这个问题的一个稍微不同的变体是，把一个指针放到容器中，而这个容器的生命周期比指针指向的对象更长。

*另见*：获得悬挂指针的另一个方法是指针无效化。它可以用类似的技术来检测/防御。

##### 实施
* 编译器一般会捕捉到返回指向局部变量的引用，而且可以在许多情况下捕捉到返回指向局部变量的指针。
* 静态分析可以捕捉许多常见的使用指针表示位置的模式（因此可以避免悬挂指针）。

### F.44: 当不希望拷贝以及不需要“返回无对象”时，返回`T&`
##### 理由
语言保证了`T&`指向一个对象，因此检测`nullptr`是没有必要的。

*另见*：引用的返回必须不能隐含所有权的转移：预防悬挂指针的讨论以及所有权的讨论。

##### 示例
```cpp
class Car
{
    array<wheel, 4> w;
    // ...
public:
    wheel& get_wheel(int i) { Expects(i < w.size()); return w[i]; }
    // ...
};

void use()
{
    Car c;
    wheel& w0 = c.get_wheel(0); // w0拥有与c一样的生命周期
}
```

### F.45: 不要返回`T&&`
##### 理由
这是在要求返回一个指向已销毁的临时对象的引用。`&&`是用于临时对象的磁铁。当对临时对象的引用被“向下”传递给被调用者时，这是可以的，因为临时对象的生命周期保证比函数调用长（参阅F.18和F.19）。然而，当“向上”传递这样的引用给更大的调用者作用域时，这是不可以的。另见???。

对于（通过普通引用或者通过完美转发）传入参数的透传函数，如果想要返回值，使用简单的`auto`返回类型推导（不是`auto&&`）。

##### 示例，不好的
如果`F`以值返回，这个函数返回一个指向临时对象的引用。
```cpp
template<class F>
auto&& wrapper(F f)
{
    log_call(typeid(f)); // 或者其它任何指令
    return f();
}
```

##### 示例，好的
好多了：
```cpp
template<class F>
auto wrapper(F f)
{
    log_call(typeid(f)); // 或者其它任何指令
    return f();
}
```

##### 例外
`std::move`和`std::forward`的确返回`&&`，但它们只是转型——只在特定的表达式上下文中按照惯例来使用：当一个指向临时对象的引用在该临时对象销毁之前与同一个表达式一起传递。我们不知道任何其它返回`&&`的好例子。

##### 实施
标记任何使用`&&`作为返回类型的情况，除了`std::move`和`std::forward`。

### F.46: `int`是`maint()`的返回类型
##### 理由
这是语言规则，但经常被“语言扩展”违反，所以值得一提。把`main`（程序唯一全局的`main`）声明为`void`限制了可移植性。

##### 示例
```cpp
void main() { /* ... */ };  // 不好的，不是C++

int main()
{
    std::cout << "This is the way to do it\n";
}
```

##### 注意
我们提及这个只是因为这个错误在社区中一直存在。

##### 实施
* 编译器应该这么做
* 如果编译器不这样做，让工具标记它

### F.47: 在赋值操作符中返回`T&`
##### 理由
操作符重载（特别是对于值类型）的一个约定是，让`operation=(const T&)`执行赋值并且返回（非`const`）`*this`。这保证了与标准库的类型保持一致，并遵循“像整数一样运作”的原则。

##### 注意
历史上有一些指导让赋值操作符返回`const T&`。这主要是为了避免`(a = b) = c`形式的代码——这类代码不够常见，不足以证明违反与标准类型的一致性是正确的。

##### 示例
```cpp
class Foo
{
 public:
    ...
    Foo& operator=(const Foo& rhs) {
      // 拷贝成员。
      ...
      return *this;
    }
};
```

##### 实施
这应该由工具通过检查任何赋值操作符的返回类型（和返回值）来实施。

### F.50: 在函数不能达到目的的时候使用lambda（捕捉局部变量，或者写一个局部函数）
##### 理由
函数不能捕捉局部变量或者声明在局部作用域中；如果你需要这些东西，可能的话优先使用lambda，否则手写一个函数对象。另一方面，lambda和函数对象不会重载；如果你需要重载，优先使用函数（使lambda可重载的变通方法是奢华的）。如果两者都可用，优先写一个函数；使用所需的最简单工具。

##### 示例
```cpp
// 写一个只应该接受一个整数或者一个字符串的函数——重载是自然的
void f(int);
void f(const string&);

// 写一个需要捕捉局部状态以及出现在语句或者表达式作用域的函数对象
// ——lambda是自然的
vector<work> v = lots_of_work();
for (int tasknum = 0; tasknum < max; ++tasknum) {
    pool.run([=, &v]{
        /*
        ...
        ... 处理v的第 1 / max 个元素，tasknum - 第几块
        ...
        */
    });
}
pool.join();
```

##### 例外
泛型lambda提供了简洁的方式来写函数模板，因此它是有用的，即使在一个普通函数模板用更多的语法来做得同样好的情况下。一旦所有函数都获得了拥有概念参数的能力，这个优势在将来可能会消失。

##### 实施
* 对于具名的非泛型lambda（例如，`auto x = [](int i) { /*...*/; };`），如果它没有捕获东西并且出现在全局作用域，发出警告。写一个普通的函数来代替。

### F.51: 在可以选择的时候，优先使用默认参数而不是重载
##### 理由
默认参数简单地为一个单一的实现提供了另一个接口。没有办法保证一组重载函数全部都实现了相同的语义。使用默认参数可以避免代码重复。

##### 注意
 只有当另外的接口来自相同类型的参数集合时，在默认参数和重载之间才有选择。例如：
```cpp
void print(const string& s, format f = {});
```
而不是
```cpp
void print(const string& s);  // 使用默认格式
void print(const string& s, format f);
```
当一组函数用来对一组类型做相同语义的操作时，是没有选择的。例如：
```cpp
void print(const char&);
void print(int);
void print(zstring);
```

##### 另见
虚函数的默认参数

##### 实施
???

### F.52: 在局部使用的lambda中，优先以引用来捕获变量，包括传递给算法
##### 理由
为了效率和正确性，你几乎总是想在局部使用lambda的时候以引用来捕获变量。这包括了写或者调用局部的并行算法，因为它们会在返回之前接合。

##### 讨论
效率的考虑基于大部分类型以引用传递比以值传递更廉价。

正确性的考虑基于许多调用想在调用侧在原始对象上执行副作用（参考下面的示例）。以值传递阻止了这种做法。

##### 注意
不幸的是，没有简单的方式以`const`引用捕捉变量来获得局部调用的效率，同时阻止副作用。

##### 示例
这里，一个大型对象（一个网络消息）被传递给一个迭代算法，拷贝这个消息是否不高效或者不正确（它可能不能拷贝）呢：
```cpp
std::for_each(begin(sockets), end(sockets), [&message](auto& socket)
{
    socket.send(message);
});
```

##### 示例
这是一个简单的三阶并行管道。每个`stage`对象封装了一个工作线程和一个队列，有一个`process`函数来让工作进队列，并且在它的析构函数中，在结束线程之前自动阻塞等待队列变空。
```cpp
void send_packets(buffers& bufs)
{
    stage encryptor([] (buffer& b){ encrypt(b); });
    stage compressor([&](buffer& b){ compress(b); encryptor.process(b); });
    stage decorator([&](buffer& b){ decorate(b); compressor.process(b); });
    for (auto& b : bufs) { decorator.process(b); }
}  // 自动阻塞等待管道完成
```

### F.53: 在非局部使用的lambda中，避免以引用来捕获变量，包括返回，在堆中存储，或者传递给其它线程
##### 理由
指向局部变量的指针和引用的生命周期不应该超过它们所在的作用域。以引用捕获变量的lambda只是另一个地方来保存指向局部对象的引用，如果它们（或者它们的拷贝）的生命周期比作用域长，就不应该这样做。

##### 示例，不好的
```cpp
int local = 42;

// 想要一个指向局部变量的引用。
// 注意，在程序退出了这个作用域之后，local不再存在，
// 因此process()的调用将会有未定义的行为！
thread_pool.queue_work([&]{ process(local); });
```

##### 示例，好的
```cpp
int local = 42;
// 想要一个local的拷贝。
// 由于拷贝了local，这个调用总是可行的。
thread_pool.queue_work([=]{ process(local); });
```

##### 实施
* （简单）当捕获列表包含指向局部声明变量的引用时，发出警告
* （复杂）当捕获列表包含指向局部声明变量的引用，并且这个lambda被传递给一个非`const`和非局部的上下文时，进行标记

## F.54: 如果你捕获了`this`，显式地捕获所有变量（非默认捕获）
##### 理由
这是令人困惑的。在一个成员函数中写`[=]`看起来是以值来捕获，但实际上是以引用捕获数据成员，因为它实际上以值捕获了不可见的`this`指针。如果你意图那样做，显式地写`this`。

##### 示例
```cpp
class My_class {
    int x = 0;
    // ...

    void f() {
        int i = 0;
        // ...

        auto lambda = [=]{ use(i, x); };   // 不好的：“看起来”是以拷贝/值来捕获的
        // [&]有同等的语义并且在当前的准则下复制this指针
        // [=,this]和[&,this]并没有好多少，而且同样令人困惑

        x = 42;
        lambda(); // 调用use(0, 42);
        x = 43;
        lambda(); // 调用use(0, 43);

        // ...

        auto lambda2 = [i, this]{ use(i, x); }; // 好的，最清晰并且最少困惑

        // ...
    }
};
```

##### 注意
在标准化过程中，这个问题被积极地讨论，而且在未来的标准版本中，可能会通过添加新的捕获模式或者调整`[=]`的含义来解决。目前，只要让它保持清晰即可。

##### 实施
* 标记出任何指定了默认捕获并且同时捕获了`this`（不论是显式的或者通过默认捕获的）的lambda捕获列表。

### F.55: 不要使用`va_arg`参数
##### 理由
从`va_arg`读取假定了实际传递的是正确的类型。传递给可变参数假定了会以正确的类型来读取。这是脆弱的，因为在语言中它通常不能保证是安全的，并且依赖于程序员的自律来让它正确执行。

##### 示例
```cpp
int sum(...) {
    // ...
    while (/*...*/)
        result += va_arg(list, int); // 不好的，假设了它传递的是int
    // ...
}

sum(3, 2); // 正确
sum(3.14159, 2.71828); // 坏了，未定义行为

template<class ...Args>
auto sum(Args... args) { // 好的，而且更加灵活
    return (... + args); // 注意：C++17的“折叠表达式”
}

sum(3, 2); // 正确：5
sum(3.14159, 2.71828); // 正确：~5.85987
```

##### 替代方案
* 重载
* 可变参数模板
* `variant`参数
* `initializer_list`（同类的方法）

##### 注意
对于那些不会使用传进来的实参的技术，声明一个`...`参数有时候是有用的，尤其是声明“接受任何东西”的函数，从而在重载集合中禁用“其它所有东西”，或者在模板元程序中表达一个捕获所有东西的情况。

##### 实施
* 对于使用了`va_list`、`va_start`或者`va_arg`的情况，发出诊断报告。
* 如果传递一个参数给一个函数的可变参数，并且该函数在可变参数的位置没有提供一个更具体类型的重载，发出诊断报告。修复方法：使用一个不同的函数，或者`[[suppress(types)]]`。

## C: 类与类层次结构
类是一个用户定义类型，程序员可以用它来定义表示，操作和接口。类层次结构用来组织相关的类到分层的结构中。

类准则概要：
* C.1: 把相关的数据组织到结构中（`struct`或者`class`）
* C.2: 如果类有不变式，使用`class`；如果数据成员可以独立地变化，使用`struct`
* C.3: 使用类来表示接口和实现之间的差异
* C.4: 只有在需要直接访问类的表示时才把函数定义成成员
* C.5: 把辅助函数放在与它们所支持的类的同一个名称空间内
* C.7: 不要在同一个语句中定义类或枚举并且声明这个类型的变量
* C.8: 如果有任一成员是非公有的，使用`class`而不是`struct`
* C.9: 暴露最少的成员

小节：
* C.concrete: 具体类型
* C.ctor: 构造函数，赋值，和析构函数
* C.con: 容器和其它资源句柄
* C.lambdas: 函数对象和lambda
* C.hier: 类层次结构（OOP）
* C.over: 重载和重载操作符
* C.union: 联合

### C.1: 把相关的数据组织到结构中（`struct`或者`class`）
##### 理由
容易理解。如果数据是相关的（出于根本原因），这个事实应该在代码中反映出来。

##### 示例
```cpp
void draw(int x, int y, int x2, int y2);  // 不好的：不必要的隐式关系
void draw(Point from, Point to);          // 好多了
```

##### 注意
没有虚函数的简单类意味着没有空间或时间开销。

##### 注意
从语言来看，`class`和`struct`只在它们成员的默认可视性上有不同。

##### 实施
也许是不可能的。也许启发式地查找一起使用的数据项是可能的。

### C.2: 如果类有不变式，使用`class`；如果数据成员可以独立地变化，使用`struct`
##### 理由
可读性。容易理解。使用`class`提醒程序员不变式的需要。这是一个有用的约定。

##### 注意
不变式是对一个对象的成员的逻辑条件，必须由构造函数来建立，并且由公有成员函数来承担。在不变式建立之后（一般通过构造函数），可以调用对象的每个成员函数。不变式可以非正式地声明（例如，在注释中）或者更正式地使用`Expects`。

如果所有数据成员可以彼此独立地变化，没有不变式是可能的。

##### 示例
```cpp
struct Pair {  // 成员可以独立地变化
    string name;
    int volume;
};
```
但是：
```cpp
class Date {
public:
    // 验证 {yy, mm, dd} 是有效的日期并且初始化
    Date(int yy, Month mm, char dd);
    // ...
private:
    int y;
    Month m;
    char d;    // 天
};
```

##### 注意
如果一个类有任意`private`数据，用户不能在不使用构造函数的情况下完全初始化一个对象。因此，类的定义者要提供一个构造函数并且必须指定它的含义。这实际上意味着定义者需要定义一个不变式。

*另见*：
* 用`class`定义具有私有数据的类
* 优先把类中的接口放在首位
* 暴露最少的成员
* 避免`protected`数据

##### 实施
查找所有数据都是私有的`struct`，以及具有公有成员的`class`。

### C.3: 使用类来区分接口和实现
##### 理由
明显地区分接口和实现可以提高可读性和简化维护。

##### 示例
```cpp
class Date {
    // ... 一些表示 ...
public:
    Date();
    // 验证{yy, mm, dd}是有效的日期并且初始化
    Date(int yy, Month mm, char dd);

    int day() const;
    Month month() const;
    // ...
};
```
如上所示，我们现在可以改变`Date`的表示而不影响到它的用户（尽管很可能要重新编译）。

##### 注意
使用类以这种方式来区分接口和实现当然不是唯一的方法。例如，我们可以使用在一个名称空间中声明的独立函数集合，抽象基类，或者带有概念来表示接口的模板函数。最重要的事情是要明显地区分一个接口和它的实现“细节”。理想的同时也是典型的情况下，一个接口远比它的实现更稳定。

##### 实施
???

### C.4: 只有在需要直接访问类的表示时才把函数定义成成员
##### 理由
比成员函数具有更少的关联，有更少会修改对象状态而导致问题的函数，减少在改变表示之后需要修改的函数数量。

##### 示例
```cpp
class Date {
    // ... 相关的小接口 ...
};

// 辅助函数
Date next_weekday(Date);
bool operator==(Date, Date);
```
“辅助函数”不需要直接访问`Date`的表示。

##### 注意
如果C++有了“统一函数调用”，这个准则会变得更好。

##### 例外
语言需要`virtual`函数是成员，而且并不是所有`virtual`函数都直接访问数据。特别是，抽象类的成员很少这样做。

注意多重方法。

##### 例外
语言要求操作符`=`、`()`、`[]`和`->`为成员。

##### 例外
一个重载集合中可能有些成员不会直接访问`private`数据：
```cpp
class Foobar {
public:
    void foo(long x)    { /* 维护私有数据 */ }
    void foo(double x) { foo(std::lround(x)); }
    // ...
private:
    // ...
};
```
类似的，一系列函数可能设计来用在链中：
```cpp
x.scale(0.5).rotate(45).set_color(Color::red);
```
一般情况下，部分但不是所有这些函数会直接访问`private`数据。

##### 实施
* 查找不会直接接触数据成员的非`virtual`函数。这里的障碍是，许多不需要直接接触数据成员的成员函数会这么做。
* 忽略`virtual`函数。
* 忽略作为重载集合一部分的函数，其中至少有一个函数访问了私有成员。
* 忽略返回`this`的函数。

### C.5: 把辅助函数放在与它们所支持的类的同一个名称空间内
##### 理由
辅助函数是不需要直接访问类的表示的函数（通常由类的作者提供），甚至可以看成是类的有用接口的一部分。把它们跟类放在同一个名称空间使得它们与类的关系更明显，并且允许它们可以被参数依赖查找找到。

##### 示例
```cpp
namespace Chrono { // 这里我们存放了时间相关的服务

    class Time { /* ... */ };
    class Date { /* ... */ };

    // 辅助函数
    bool operator==(Date, Date);
    Date next_weekday(Date);
    // ...
}
```

##### 注意
这对于重载操作来说特别重要。

##### 实施
* 标记出那些接收来自单个名称空间的参数类型的全局函数。

### C.7: 不要在同一个语句中定义类或枚举并且声明这个类型的变量
##### 理由
在同一个声明中混合类型定义和另一个实体的定义令人困惑并且没有必要。

##### 示例；不好的
```cpp
struct Data { /*...*/ } data{ /*...*/ };
```

##### 示例；好的
```cpp
struct Data { /*...*/ };
Data data{ /*...*/ };
```

##### 实施
如果类或枚举定义的`}`后面没有跟着`;`，标记出来。`;`缺失了。

### C.8: 如果有任一成员是非公有的，使用`class`而不是`struct`
##### 理由
可读性。清楚地表明有些东西被隐藏/被抽象了。这是一个有用的约定。

##### 示例，不好的
```cpp
struct Date {
    int d, m;

    Date(int i, Month m);
    // ... 许多函数 ...
private:
    int y;  // 年
};
```
就C++语言规则所关注的而言，这个代码没有错误。但从设计的观点来看几乎所有东西都是错的。私有数据隐藏在远离公有数据的地方。数据分割在类定义的不同部分。数据的不同部分有不同的访问权限。所有这些降低了可读性并且使维护复杂化。

##### 注意
优先把接口放在类的首位，参阅NL.16。

##### 实施
标记出定义成`struct`并且有`private`或`protected`成员的类。

### C.9: 暴露最少的成员
##### 理由
封装。信息隐藏。最小化意外访问的机会。这可以简化维护。

##### 示例
```cpp
template<typename T, typename U>
struct pair {
    T a;
    U b;
    // ...
};
```
不论我们在`//`部分做什么，`pair`的任意用户可以任意和独立地改变它的`a`和`b`。在大型的代码库中，我们不能简单地找到哪些代码对`pair`的成员做了什么事情。这可能的确是我们想要的，但如果我们想保证成员之间的关系，我们需要把它们声明成`private`并且通过构造函数和成员函数保证这个关系（不变式）。例如：
```cpp
class Distance {
public:
    // ...
    double meters() const { return magnitude*unit; }
    void set_unit(double u)
    {
            // ... 检查u是10的因子 ...
            // ... 适当地修改数量 ...
            unit = u;
    }
    // ...
private:
    double magnitude;
    double unit;    // 1是米，1000是千米，0.001是毫米，等等。
};
```

##### 注意
如果一组变量的直接用户不能简单地确定，它们的类型或者用法就不能（简单地）改变/提升。对于`public`和`protected`数据，这是常见的情况。

##### 示例
一个类提供了两部分接口给它的用户。一部分提供给派生类（`protected`），一部分提供给普通用户（`public`）。例如，派生类可能允许跳过一个运行时检查因为它已经保证了正确性：
```cpp
class Foo {
public:
    int bar(int x) { check(x); return do_bar(x); }
    // ...
protected:
    int do_bar(int x); // 在数据上做一些操作
    // ...
private:
    // ... 数据 ...
};

class Dir : public Foo {
    //...
    int mem(int x, int y)
    {
        /* ... 做些事情 ... */
        return do_bar(x + y); // 没问题：派生类可以绕过检查
    }
};

void user(Foo& x)
{
    int r1 = x.bar(1);      // 没问题，会检查
    int r2 = x.do_bar(2);   // 错误：会绕过检查
    // ...
}
```

##### 注意
`protected`数据是不好的想法。

##### 注意
优先以`public`成员，`protected`成员，`private`成员的顺序排列。参阅这里。

##### 实施
* 标记出受保护数据。
* 标记出`public`和`private`数据的混合体。

## C.concrete: 具体类型
关于类的一个观点是定义成常规类型。这大概的意思是“表现地像一个`int`”。具体类型是一种最简单的类。常规类型的值可以被拷贝，并且拷贝的结果是一个与原始对象有相同值的独立对象。如果一个具体类型同时有`=`和`==`，`a = b`应该会使`a == b`的结果为`true`。也可以定义没有赋值和相等操作的具体类型，但这是非常罕见的（也应该如此）。C++内置类型是常规的，因此标准库的类也是如此，例如`string`，`vector`和`map`。具体类型通常也称为值类型，以将它们与作为类层次结构一部分使用的类型区分开来。

具体类型准则概要：
* C.10: 优先使用具体类型而不是类层次结构
* C.11: 使具体类型是常规的

### C.10: 优先使用具体类型而不是类层次结构
##### 理由
具体类型从根本上比层次结构更简单：更容易设计，更容易实现，更容易使用，更容易解释，更小，以及更快。你需要一个使用层次结构的理由（使用场景）。

##### 示例
```cpp
class Point1 {
    int x, y;
    // ... 操作 ...
    // ... 没有虚函数 ...
};

class Point2 {
    int x, y;
    // ... 操作，一些虚函数 ...
    virtual ~Point2();
};

void use()
{
    Point1 p11 {1, 2};   // 在栈上创建一个对象
    Point1 p12 {p11};    // 一个拷贝

    auto p21 = make_unique<Point2>(1, 2);   // 在自由存储上创建一个对象
    auto p22 = p21.clone();                 // 创建一个拷贝
    // ...
}
```
如果一个类是层次结构的一部分，我们必须通过指针或者引用来操作它的对象（如果在小例子中没有必要的话，那么在真实的代码中）。这意味着更多内存开销，更多分配和释放，以及更多运行时开销来执行间接访问的结果。

##### 注意
具体类型可以在栈上分配，并且作为其它类的成员。

##### 注意
间接访问的使用是运行时多态接口的基础。而分配/释放的开销并不是（那只是最常见的情况）。我们可以使用基类作为某个派生类作用域对象的接口。当动态分配被禁止时（例如，硬实时），是可以这样做的，并且这为某些种类的插件提供了稳定的接口。

##### 实施
???

### C.11: 使具体类型是常规的
##### 理由
常规类型比非常规类型更容易理解和解释（不规则的类型需要更多的努力去理解和使用）。

##### 示例
```cpp
struct Bundle {
    string name;
    vector<Record> vr;
};

bool operator==(const Bundle& a, const Bundle& b)
{
    return a.name == b.name && a.vr == b.vr;
}

Bundle b1 { "my bundle", {r1, r2, r3}};
Bundle b2 = b1;
if (!(b1 == b2)) error("impossible!");
b2.name = "the other bundle";
if (b1 == b2) error("No!");
```
特别是，如果具体类型有一个赋值操作，那么要同时给它一个相等操作符，因而`a = b`暗含了`a == b`。

##### 实施
???

## C.ctor: 构造函数，赋值操作符，以及析构函数
这些函数控制了对象的生命周期：创建，拷贝，移动和析构。定义构造函数来保证和简化类的初始化。

这些是默认的操作：
* 默认构造函数：`X()`
* 拷贝构造函数：`X(const X&)`
* 拷贝赋值操作符：`operator=(const X&)`
* 移动构造函数：`X(X&&)`
* 移动赋值操作符：`operator=(X&&)`
* 析构函数：`~X()`

默认情况下，编译器会在每一个操作被使用的时候定义它们，但这个默认行为可以被抑制。

这些默认操作是一组有关联的操作，它们共同实现了一个对象的声明周期语义。默认情况下，C++将类视为像值一样的类型，但并非所有类型都像值一样。

默认操作准则合集：
* C.20: 如果你可以避免定义任何默认操作，那么就这么做
* C.21: 如果你定义或者用`=delete`删除任何默认操作，那么同样定义或者用`=delete`删除全部默认操作
* C.22: 使默认操作保持一致

析构函数准则：
* C.30: 如果类需要在对象销毁的时候执行显式的行为，定义析构函数
* C.31: 类获取的所有资源必须由类的析构函数释放
* C.32: 如果类拥有原始指针（`T*`）或引用（`T&`），要考虑它们是否可能是类自身所有
* C.33: 如果类拥有一个自己所有的指针成员，定义或者用`=delete`删除析构函数
* C.35: 拥有虚函数的基类需要虚析构函数
* C.36: 析构函数不能失败
* C.37: 使析构函数为`noexcept`

构造函数准则：
* C.40: 如果类有不变式，定义构造函数。
* C.41: 构造函数应该创建完全初始化的对象
* C.42: 如果构造函数不能构造有效的对象，抛出异常
* C.43: 保证可拷贝（值类型）的类有默认构造函数
* C.44: 优先使默认构造函数简单并且不会抛出异常
* C.45: 不要定义只初始化数据成员的默认构造函数；使用成员初始化器代替
* C.46: 默认情况下，把单个参数的构造函数声明为`explicit`
* C.47: 根据成员声明的顺序来定义和初始化成员变量
* C.48: 优先在构造函数中对成员初始化器使用类内初始化器，而不是常量初始化器
* C.49: 优先在构造函数中使用初始化而不是赋值
* C.50: 如果你在初始化过程中需要“虚拟行为”，使用工厂函数
* C.51: 使用委托构造函数来表示类的所有构造函数的公共行为
* C.52: 使用继承构造函数把构造函数导入不需要进一步显式初始化的派生类

拷贝和移动准则：
* C.60: 使拷贝赋值操作符非`virtual`，以`const&`接收参数，并且以非`const&`返回
* C.61: 拷贝操作应该拷贝
* C.62: 使拷贝赋值操作符对于自我赋值是安全的
* C.63: 使移动赋值操作符非`virtual`，以`&&`接收参数，并且以非`const&`返回
* C.64: 移动操作应该移动并且让它的来源处于有效的状态
* C.65: 使移动赋值操作符对于自我赋值是安全的
* C.66: 使移动操作为`noexcept`
* C.67: 如果希望拥有“拷贝行为”，基类应该阻止拷贝，并且提供一个虚拟的`clone`来代替

其它默认操作准则：
* C.80: 如果你必须显式说明要使用默认语义，使用`=default`
* C.81: 当你想要禁用默认行为（又不想要其它替代方案）时，使用`=delete`
* C.82: 不要在构造函数和析构函数中调用虚函数
* C.83: 对于值类型，考虑提供一个`noexcept`交换函数
* C.84: `swap`不能失败
* C.85: 使`swap`为`noexcept`
* C.86: 使`==`的操作数类型对称，并且为`noexcept`
* C.87: 注意基类的`==`
* C.89: 使`hash`为`noexcept`

## C.defop: 默认操作
默认情况下，语言提供了具有默认语义的默认操作。当然，程序员可以禁止或者替换这些默认操作。

### C.20: 如果你可以避免定义默认操作，那么就这么做
##### 理由
这是最简单的，并且提供了最干净的语义。

##### 示例
```cpp
struct Named_map {
public:
    // ... 没有声明默认操作 ...
private:
    string name;
    map<int, int> rep;
};

Named_map nm;        // 默认构造
Named_map nm2 {nm};  // 拷贝构造
```
由于`std::map`和`string`有了所有特定的函数，因此不需要更多的工作。

##### 注意
这称为“零准则”。

##### 实施
（不可实施）虽然不可实施，但一个好的静态分析器可以检测出那些指出可能的改善的模式来满足这个准则。例如，在类中拥有一对（指针，大小）的成员，并且在析构函数中用`delete`删除指针，这种情况很可能可以转换成使用`vector`。

### C.21: 如果你定义或者用`=delete`删除任何默认操作，那么同样定义或者用`=delete`删除全部默认操作
##### 理由
特殊的成员函数是默认构造函数，拷贝构造函数，拷贝赋值操作符，移动构造函数，移动赋值操作符，以及析构函数。

这些特殊函数的语义是紧密相关的，因此如果需要声明其中一个，那么很可能其它的也需要考虑一下。

声明任意特殊的成员函数，除了默认构造函数之外，即使只是声明为`=default`或`=delete`，也会阻止移动构造函数和移动赋值操作符的隐式声明。声明移动构造函数或者移动赋值操作符，即使只是声明为`=default`或`=delete`，也会导致隐式生成的拷贝构造函数或隐式生成的拷贝赋值操作符被定义成已删除。因此一旦声明了任意特殊函数，其它的也应该声明，以防出现不想要的结果，例如所有潜在的移动转变成了昂贵的拷贝，或者使得类只能移动。

##### 示例，不好的
```cpp
struct M2 {   // 不好：不完整的默认操作
public:
    // ...
    // ... 没有拷贝或移动操作 ...
    ~M2() { delete[] rep; }
private:
    pair<int, int>* rep;  // zero-terminated set of pairs
};

void use()
{
    M2 x;
    M2 y;
    // ...
    x = y;   // 默认赋值
    // ...
}
```
上面的析构函数需要“特别注意”（在这里用来释放），在这个情况下拷贝和移动赋值（两者都会隐式地删除对象）正确的可能性很低（在这里我们会遇到双重删除）。

##### 注意
这称为“五准则”或者“六准则”，取决于你是否把默认构造函数计算在内。

##### 注意
如果你想要一个默认操作的默认实现（同时定义了其它操作），写上`=default`来表示你是有意对这个函数这么做的。如果你不想要一个默认操作，用`=delete`来阻止它。

##### 示例，好的
当仅仅为了使析构函数为`virtual`而声明它的时候，它可以被定义成默认的。为了避免阻止隐式的移动操作，它们也必须声明，然后为了避免类变成只能移动（并且不可拷贝），拷贝操作也必须声明：
```cpp
class AbstractBase {
public:
  virtual ~AbstractBase() = default;
  AbstractBase(const AbstractBase&) = default;
  AbstractBase& operator=(const AbstractBase&) = default;
  AbstractBase(AbstractBase&&) = default;
  AbstractBase& operator=(AbstractBase&&) = default;
};
```
另外，为了避免C.67提到的对象切割，拷贝和移动操作可以全部删除：
```cpp
class ClonableBase {
public:
  virtual unique_ptr<ClonableBase> clone() const;
  virtual ~ClonableBase() = default;
  ClonableBase(const ClonableBase&) = delete;
  ClonableBase& operator=(const ClonableBase&) = delete;
  ClonableBase(ClonableBase&&) = delete;
  ClonableBase& operator=(ClonableBase&&) = delete;
};
```
只定义移动操作或者拷贝操作在这里会有同样的效果，但是显式地为每个特殊成员说明意图会让它对读者更加明显。

##### 注意
编译器实施了该准则的大部分，而且可以理想地对任何违规进行警告。

##### 注意
在拥有析构函数的类中依赖隐式生成的拷贝操作是已废弃的。

##### 实施
（简单）类应该对全部特殊函数都有声明（甚至是`=delete`的声明），或者全部都不声明。

### C.22: 使默认操作保持一致
##### 理由
从概念上，默认操作是匹配的组合。它们的语义是相互关联的。如果拷贝/移动构造和拷贝/移动赋值执行了不同的逻辑操作，用户会感到惊讶。如果构造函数和析构函数没有提供一致的资源管理视图，用户会感到惊讶。如果拷贝和移动没有反映出构造函数和析构函数的工作方式，用户会感到惊讶。

##### 示例，不好的
```cpp
class Silly {   // 不好的：不一致的拷贝操作
    class Impl {
        // ...
    };
    shared_ptr<Impl> p;
public:
    Silly(const Silly& a) : p{a.p} { *p = *a.p; }   // 深拷贝
    Silly& operator=(const Silly& a) { p = a.p; }   // 浅拷贝
    // ...
};
```
这些操作与拷贝语义不一致。这会导致困惑和缺陷。

##### 实施
* （复杂）拷贝/移动构造函数和对应的拷贝/移动赋值操作符应该在相同级别的解引用上写入同一个成员变量。
* （复杂）任何在拷贝/移动构造函数中写入的成员变量应该也要在所有其它构造函数中初始化。
* （复杂）如果拷贝/移动构造函数执行了一个成员变量的深拷贝，那么析构函数应该修改这个成员变量。
* （复杂）如果析构函数修改了一个成员变量，这个成员变量应该在任意拷贝/移动构造函数或者赋值操作符中写入。

## C.dtor: 析构函数
“这个类需要析构函数吗？”是一个令人惊讶的强大的设计问题。对于大部分类来说答案是“不”，不仅因为类没有持有资源，而且因为析构函数被零准则处理了；也就是说，它的成员可以照管它们自己作为关注的析构。如果答案是“是”，类的许多设计如下（参阅五准则）。

### C.30: 如果类需要在对象销毁的时候执行显式的行为，定义析构函数
##### 理由
析构函数会在对象生命周期结束时隐式调用。如果默认析构函数已经足够，那么使用它。只有在类需要执行的代码不属于其成员的析构函数的一部分时，才定义非默认的析构函数。

##### 示例
```cpp
template<typename A>
struct final_action {   // 稍微做了简化
    A act;
    final_action(A a) :act{a} {}
    ~final_action() { act(); }
};

template<typename A>
final_action<A> finally(A act)   // 推导action的类型
{
    return final_action<A>{act};
}

void test()
{
    auto act = finally([]{ cout << "Exit test\n"; });  // 建立退出的action
    // ...
    if (something) return;   // act在这里执行
    // ...
} // act在这里执行
```
`final_action`的全部目的是让代码片段（通常是lambda）在析构的时候执行。

##### 注意
有两种普遍的类需要用户定义的析构函数：
* 一种是拥有资源的类，这些资源还未以具有析构函数的类，例如`vector`或者事务类来表示。
* 一种是主要用来在析构时执行行为的类，例如追踪器或者`final_action`。

##### 示例，不好的
```cpp
class Foo {   // 不好的；应使用默认析构函数
public:
    // ...
    ~Foo() { s = ""; i = 0; vi.clear(); }  // 清理
private:
    string s;
    int i;
    vector<int> vi;
};
```
默认析构函数做得更好，更高效，并且不会出错。

##### 注意
如果需要使用默认析构函数，但是它被阻止生成（例如，通过定义移动构造函数），那么使用`=default`。

##### 实施
查找可能的“隐式资源”，例如指针和引用。查找即使所有数据成员都有析构函数，但其仍然带有析构函数的类。

### C.31: 类获取的所有资源必须由类的析构函数释放
##### 理由
防止资源泄露，特别是在出错的情况下。

##### 注意
对于那些用带有完整默认操作的类表示的资源，这是自动执行的。

##### 示例
```cpp
class X {
    ifstream f;   // 可能拥有一个文件
    // ... 没有定义默认操作或者=delete ...
};
```
`X`的`ifstream`会在`X`的析构函数执行时隐式地关闭任何已打开的文件。

##### 示例，不好的
```cpp
class X2 {     // 不好的
    FILE* f;   // 可能拥有一个文件
    // ... 没有定义默认操作或者=delete ...
};
```
X2可能会泄露一个文件句柄。

##### 注意
一个不能关闭的套接字会怎样？析构函数，关闭或者清理操作应该永不失败。然而，如果它确实发生了，我们就遇到一个没有真正好的解决方法的问题。对于初学者，析构函数的作者不知道为什么析构函数会被调用，并且不能通过抛出异常来“拒绝执行”。参阅这个讨论。使这个问题更糟糕的是，许多“关闭/释放”操作是不可重试的。许多人尝试去解决这个问题，但没有已知的普遍的解决方法。如果可能的话，考虑将关闭/释放的错误视为基本的设计错误，并且终止程序。

##### 注意
类可能持有指向不属于它的对象的指针和引用。显然，这些对象不应该被类的析构函数用`delete`删除。例如：
```cpp
Preprocessor pp { /* ... */ };
Parser p { pp, /* ... */ };
Type_checker tc { p, /* ... */ };
```
这里`p`引用了`pp`，但并没有拥有它。

##### 实施
* （简单）如果拥有指针或引用成员变量的类是所有者（例如，通过使用`gsl::owner`被视为所有者），那么这些变量应该在类的析构函数中有所引用。
* （困难）在没有显式声明所有权的时候，确定指针或者引用成员变量是否所有者（例如，查看构造函数）。

### C.32: 如果类拥有原始指针（`T*`）或引用（`T&`），要考虑它们是否可能是类自身所有
##### 理由
有许多代码没有明确说明所有权。

##### 示例
```cpp
???
```

##### 注意
如果`T*`或者`T&`是类所有的，用`owning`标记它。如果`T*`不是类所有，考虑用`ptr`标记它。这会有助于文档和分析。

##### 实施
查看原始成员指针和成员引用的初始化，看是否使用了分配。

### C.33: 如果类拥有一个自己所有的指针成员，定义析构函数
##### 理由
一个被持有的对象必须在持有它的对象的析构函数中删除。

##### 示例
指针成员可能表示资源。`T*`不应该这么做，但在旧代码中，这是常见的。考虑`T*`的可能的所有者，然后据此进行推测。
```cpp
template<typename T>
class Smart_ptr {
    T* p;   // 不好的：*p的所有权是模糊的
    // ...
public:
    // ... 没有用户定义的默认操作 ...
};

void use(Smart_ptr<int> p1)
{
    // 错误：p2.p泄露了（如果不是nullptr，而且没有被其它代码持有）
    auto p2 = p1;
}
```
注意，如果你定义了析构函数，那么你必须定义或者删除所有默认操作：
```cpp
template<typename T>
class Smart_ptr2 {
    T* p;   // 不好的：*p的所有权是模糊的
    // ...
public:
    // ... 没有用户定义的拷贝操作 ...
    ~Smart_ptr2() { delete p; }  // p是所有者！
};

void use(Smart_ptr2<int> p1)
{
    auto p2 = p1;   // 错误：双重删除
}
```
默认的拷贝操作只会把`p1.p`拷贝到`p2.p`，导致`p1.p`的双重析构。应该显式地声明所有权：
```cpp
template<typename T>
class Smart_ptr3 {
    owner<T*> p;   // 好的：*p的所有权是清晰的
    // ...
public:
    // ...
    // ... 拷贝和移动操作 ...
    ~Smart_ptr3() { delete p; }
};

void use(Smart_ptr3<int> p1)
{
    auto p2 = p1;   // 错误：双重删除
}
```

##### 注意
通常获得析构函数的最简单方法是把指针替换成智能指针（例如，`std::unique_ptr`），并且让编译器负责生成适当的隐式析构。

##### 注意
为什么不干脆把全部持有的指针定义成“智能指针”？因为这有时会要求非平凡的代码修改，并且会影响到ABI。

##### 实施
* 一个拥有指针数据成员的类是可疑的。
* 一个拥有`owner<T>`的类应该定义它的默认操作。

### C.35: 基类的析构函数应该要么是公有的和虚拟的，要么是受保护的和非虚拟的
##### 理由
为了避免未定义的行为。如果析构函数是公有的，那么调用代码可以尝试通过基类指针来删除派生类对象，然而，如果基类的析构函数是非虚拟的，结果是未定义的。如果析构函数是受保护的，那么调用代码不能通过基类指针来销毁对象，从而析构函数不需要是虚拟的；它确实需要是受保护的，而不是私有的，因此派生的析构函数可以调用它。通常，基类的作者不知道在析构时要执行的正确行为。

##### 讨论
参阅在讨论部分的这个内容。

##### 示例，不好的
```cpp
struct Base {  // 不好的：没有虚析构函数
    virtual void f();
};

struct D : Base {
    string s {"a resource needing cleanup"};
    ~D() { /* ... 做一些清理 ... */ }
    // ...
};

void use()
{
    unique_ptr<Base> p = make_unique<D>();
    // ...
} // p的析构函数调用~Base()，而不调用~D()，会导致泄露D::s以及可能更多的内容
```

##### 注意
虚函数为派生类定义了一个接口，该接口可以在不查看派生类的时候使用。如果该接口允许销毁，它应该能够安全地这么做。

##### 注意
析构函数必须是非私有的，否则它会阻止使用这个类型：
```cpp
class X {
    ~X();   // 私有析构函数
    // ...
};

void use()
{
    X a;                        // 错误：不能销毁
    auto p = make_unique<X>();  // 错误：不能销毁
}
```

##### 例外
我们可以想象出一个你想要受保护的虚析构函数的场景：当一个派生类型（只有这个类型）的对象被允许通过指向基类的指针销毁另一个对象（不是它自己）时。不过，我们还没有在实践见过这种场景。

##### 实施
* 拥有任何虚函数的类应该有一个析构函数，该析构函数要么是公有的和虚拟的，或者是受保护的和非虚拟的。

#### C.36: 析构函数不能失败
##### 理由
通常，如果一个析构函数可以失败，那么我们不知道如何写出没有错误的代码。标准库要求所有它处理的类都要有一个不通过抛异常来退出的析构函数。

##### 示例
```cpp
class X {
public:
    ~X() noexcept;
    // ...
};

X::~X() noexcept
{
    // ...
    if (cannot_release_a_resource) terminate();
    // ...
}
```

##### 注意
许多人试图设计一个防呆的模式来处理析构函数中的失败。没有人能成功地找到一个通用的模式。这是一个真正的实际问题：例如，套接字不能关闭怎么办？析构函数的作者不知道为什么析构函数会被调用，不能通过抛出异常来“拒绝执行”。参阅讨论。使问题更糟糕的是，很多“关闭/释放”操作是不可重试的。如果可能的话，考虑把关闭/清理的失败视为基本的设计错误，然后结束程序。

##### 注意
把析构函数声明为`noexcept`。这会保证它要么正常地完成，要么结束程序。

##### 注意
如果资源不能释放而且程序不能失败，尝试以某种方式把失败发送到系统的其它地方（可能甚至通过修改一些全局的状态，然后希望有些东西会注意到并且能够处理该问题）。要明确知道这个技术是目标特定的，并且容易出错。考虑“我的连接关闭不了”的例子。很可能在连接的另一端存在问题，而且只有同时负责连接两端的一小块代码可以正确地处理该问题。析构函数可以发送一个消息（以某种方式）给系统中负责任的部分，并认为连接已经关闭，然后正常地返回。

##### 注意
如果析构函数使用了会失败的操作，它可以捕获异常，然后在一些情况下仍然成功地完成（例如，使用了不同的会抛出异常的清理机制）。

##### 实施
（简单）如果析构函数会抛出异常，它应该声明为`noexcept`。

### C.37: 使析构函数为`noexcept`
##### 理由
析构函数不能失败。如果析构函数试图用异常来退出，这是一个槽糕的设计错误，程序最好终止。

##### 注意
如果类的所有成员都有`noexcept`析构函数，那么该类的析构函数（不论是用户定义的还是编译器生成的）会隐式地声明为`noexcept`（与函数体中的代码无关）。通过显式标记析构函数为`noexcept`，作者可以避免通过添加或修改类成员导致析构函数隐式地变为`noexcept(false)`。

##### 实施
（简单）如果析构函数会抛出异常，它应该声明为`noexcept`。

## C.ctor: 构造函数
构造函数定义了一个对象如何初始化（构造）。

### C.40: 如果类有不变式，定义构造函数
##### 理由
这就是构造函数的要做的。

##### 示例
```cpp
class Date {  // Date表示在1900年1月1日到2100年12月31日范围内的有效日期
    Date(int dd, int mm, int yy)
        :d{dd}, m{mm}, y{yy}
    {
        if (!is_valid(d, m, y)) throw Bad_date{};  // 确保不变式
    }
    // ...
private:
    int d, m, y;
};
```
在构造函数中用`Ensures`表达不变式通常是一个好主意。

##### 注意
即使类没有不变式，也能出于方便而使用构造函数。例如：
```cpp
struct Rec {
    string s;
    int i {0};
    Rec(const string& ss) : s{ss} {}
    Rec(int ii) :i{ii} {}
};

Rec r1 {7};
Rec r2 {"Foo bar"};
```

##### 注意
C++11的初始化列表规则消除了很多构造函数的需要。例如：
```cpp
struct Rec2{
    string s;
    int i;
    Rec2(const string& ss, int ii = 0) :s{ss}, i{ii} {}   // 冗余的
};

Rec2 r1 {"Foo", 7};
Rec2 r2 {"Bar"};
```
`Rec2`的构造函数是冗余的。此外，`int`的默认值使用成员初始化器会更好。

*另见*：构造有效的对象和构造函数抛异常。

##### 实施
* 标记出拥有用户定义的拷贝构造函数但没有构造函数的类（用户定义的拷贝是很好地指示，说明类有不变式）。

### C.41: 构造函数应该创建完全初始化的对象
##### 理由
构造函数为类建立不变式。类的用户应该可以假定一个构造好的对象是可用的。

##### 示例，不好的
```cpp
class X1 {
    FILE* f;   // 在任何其它函数之前调用init()
    // ...
public:
    X1() {}
    void init();   // 初始化f
    void read();   // 读取f
    // ...
};

void f()
{
    X1 file;
    file.read();   // 崩溃或者读取到坏数据！
    // ...
    file.init();   // 太迟了
    // ...
}
```
编译器不会阅读注释。

#####  例外
如果有效的对象不能方便地通过构造函数来构造，使用工厂函数。

##### 实施
* （简单）每个构造函数都应该初始化每个成员变量（可以是显式的，也可以通过委托构造调用或者通过默认构造）。
* （未知）如果构造函数有`Ensures`契约，尝试看看它是否持有一个后置条件。

##### 注意
如果构造函数需要一个资源（来创建有效的对象），那么该资源应该由析构函数释放。由构造函数获得资源然后由析构函数释放的惯用法称为RAII（“资源获取即初始化”）。

### C.42: 如果构造函数不能构造有效的对象，抛出异常
##### 理由
留下一个无效的对象是自找麻烦。

##### 示例
```cpp
class X2 {
    FILE* f;   // 在任何其它函数之前调用init()
    // ...
public:
    X2(const string& name)
        :f{fopen(name.c_str(), "r")}
    {
        if (!f) throw runtime_error{"could not open" + name};
        // ...
    }

    void read();      // 读取f
    // ...
};

void f()
{
    X2 file {"Zeno"}; // 如果文件不能打开，抛出异常
    file.read();      // 没问题
    // ...
}
```

##### 示例，不好的
```cpp
class X3 {     // 不好的：构造函数留下了一个无效的对象
    FILE* f;   // 在任何其它函数之前调用init()
    bool valid;
    // ...
public:
    X3(const string& name)
        :f{fopen(name.c_str(), "r")}, valid{false}
    {
        if (f) valid = true;
        // ...
    }

    bool is_valid() { return valid; }
    void read();   // 读取f
    // ...
};

void f()
{
    X3 file {"Heraclides"};
    file.read();   // 崩溃或者读取到坏数据！
    // ...
    if (file.is_valid()) {
        file.read();
        // ...
    }
    else {
        // ... 处理错误 ...
    }
    // ...
}
```

##### 注意
对于变量的定义（例如在栈上定义，或者作为另一个对象的成员），没有显式的函数调用可以返回一个错误码。留下一个无效的对象并且依赖用户不断地在使用之前检查`is_valid()`函数，这是单调乏味的，容易出错，并且效率低下。

##### 例外
有些领域，例如一些硬实时系统（想一下飞机控制），（在没有额外工具的支持下）异常处理从时间的观点来看没有足够的可预测性。此时必须使用`is_valid()`技术。在这些情况下，不断地检查`is_valid()`并且立即去模仿RAII。

##### 替代方案
如果你受到诱惑去使用一些“构造后初始化”或者“两阶段初始化”的惯用法，尽量不要这么做。如果你真的必须要这样做，看一下工厂函数。

##### 注意
人们使用`init()`函数而不是在构造函数中做初始化工作的其中一个原因是为了避免代码重复。委托构造函数和默认成员初始化会做得更好。另一个原因是为了延迟初始化直到需要对象的时候；解决方法通常是不要声明变量直到它能够被正确地初始化。

##### 实施
???

### C.43: 保证可拷贝（值类型）的类有默认构造函数
##### 理由
许多语言和库的设施依赖默认构造函数来初始化它们的元素，例如`T a[10]`和`std::vector<T> v(10)`。默认构造函数通常简化了为一个可拷贝类型定义合适的移出状态的任务。

##### 注意
值类型是可拷贝的类（通常也是可比较的）。它与来自EoP和Palo Alto TR的正规类型紧密相关。

##### 示例
```cpp
class Date { // 不好的：没有默认构造函数
public:
    Date(int dd, int mm, int yyyy);
    // ...
};

vector<Date> vd1(1000);   // 这里需要默认的Date
vector<Date> vd2(1000, Date{Month::October, 7, 1885});   // 另一种方式
```
默认构造函数只有在没有用户声明的构造函数时才会自动生成，因此在上面的例子中不可能初始化vector `vd1`。缺乏默认值会导致用户惊讶并且使它的使用复杂化，所以如果如果可以合理地定义构造函数，那就应该这样做。

选择`Date`作为例子是用来鼓励思考：不存在“自然的”默认日期（大爆炸太久远了，对大部分人来说没有用），所以这个例子是非平凡的。在大部分日历系统上`{0, 0, 0}`不是有效的日期，因此选择这个值的话会引入一些像浮点数的`NaN`之类的错误。当然，大部分现实的`Date`类有“第一个日期”（例如，受欢迎的1970年1月1日），因此把它作为默认值通常是不重要的。
```cpp
class Date {
public:
    Date(int dd, int mm, int yyyy);
    Date() = default; // [另见](#Rc-default)
    // ...
private:
    int dd = 1;
    int mm = 1;
    int yyyy = 1970;
    // ...
};

vector<Date> vd1(1000);
```

##### 注意
所有成员都有默认构造函数的类会隐式获得一个默认构造函数：
```cpp
struct X {
    string s;
    vector<int> v;
};

X x; // 等同于X{{}, {}}; 是一个空字符串和空vector
```

要小心内置类型不会正确地默认构造：
```cpp
struct X {
    string s;
    int i;
};

void f()
{
    X x;    // x.s初始化成空字符串；x.i未初始化

    cout << x.s << ' ' << x.i << '\n';
    ++x.i;
}
```
静态分配的内置类型对象会默认初始化成`0`，但局部的内置变量不会。要小心你的编译器可能会默认对局部内置变量进行初始化，而在优化构建中则不会这样做。因此，像上面例子中的代码可能能够正常运行，但它依赖了未定义的行为。假如你想要初始化，显式的默认初始化能提供帮助：
```cpp
struct X {
    string s;
    int i {};   // 默认初始化（为0）
};
```

##### 注意
没有合理的构造函数的类通常也是不可拷贝的，所以它们不受这个准则的影响。

例如，基类不是值类型（基类应该是不可拷贝的），因此不需要默认构造函数：
```cpp
// Shape是一个抽象基类，不是一个可拷贝的值类型。
// 它可能需要也可能不需要默认构造函数。
struct Shape {
    virtual void draw() = 0;
    virtual void rotate(int) = 0;
    // =delete 拷贝/移动函数
    // ...
};
```
必须在构造期间由调用者提供资源的类通常不能有默认构造函数，但它不受这个准则的影响，因为这样的类通常不管怎样都是不可拷贝的：
```cpp
// std::lock_guard不是可拷贝的值类型。
// 它没有默认构造函数。
lock_guard g {mx};  // guard the mutex mx
lock_guard g2;      // error: guarding nothing
```
拥有“特殊状态”的类必须由成员函数与其它状态区分处理，否则会给用户带来额外的工作（很可能是更多的错误）。这样的类型可以自然地使用特殊状态作为默认构造的值，不管它是否可拷贝：
```cpp
// std::ofstream不是可拷贝的值类型。
// 它确实有一个默认构造函数，伴随一个特殊的“未打开”状态。
ofstream out {"Foobar"};
// ...
out << log(time, transaction);
```
类似的，可拷贝的带有特殊状态的类型，例如可拷贝的智能指针，拥有特殊的状态“==nullptr”，应该使用这个特殊状态作为它们默认构造的值。

不管怎样，最好在默认构造函数中构造有意义的默认状态，例如`std::string`的`""`和`std::vector`的`{}`。

##### 实施
* 标记出可通过`=`拷贝而没有默认构造函数的类。
* 标记出可通过`==`比较但不可拷贝的类。

### C.44: 优先使默认构造函数简单并且不会抛出异常
##### 理由
能够不通过可能会失败的操作来将值设置成“默认值”，简化了关于移动操作的错误处理和说明。

##### 示例，有问题的
```cpp
template<typename T>
// elem指向使用new分配的元素
class Vector0 {
public:
    Vector0() :Vector0{0} {}
    Vector0(int n) :elem{new T[n]}, space{elem + n}, last{elem} {}
    // ...
private:
    own<T*> elem;
    T* space;
    T* last;
};
```
这很好而且常见，但在出现错误后把`Vector0`设置为空会涉及到分配，而分配可能会失败。而且，用`{new T[0], 0, 0}`表示默认的`Vector`似乎是浪费的。例如，`Vector0 v(100)`花费100个分配。

##### 示例
```cpp
template<typename T>
// elem为nullptr，或者指向使用new分配的元素
class Vector1 {
public:
    // 把内部表示设置为{nullptr, nullptr, nullptr}；不会抛异常
    Vector1() noexcept {}
    Vector1(int n) :elem{new T[n]}, space{elem + n}, last{elem} {}
    // ...
private:
    own<T*> elem = nullptr;
    T* space = nullptr;
    T* last = nullptr;
};
```
使用`{nullptr, nullptr, nullptr}`让`Vecotor1{}`更廉价，但需要额外的特殊情况和隐式的运行时检查。在检测到错误后把`Vector`设置成空是没有什么影响的。

##### 实施
* 标记会抛异常的默认构造函数。

### C.45: 不要定义只初始化数据成员的默认构造函数；使用类内部成员初始化器代替
##### 理由
使用类内部成员初始化器让编译器为你生成所需的函数。编译器生成的函数会更高效。

##### 示例，不好的
```cpp
class X1 { // 不好：没有使用成员初始化器
    string s;
    int i;
public:
    X1() :s{"default"}, i{1} { }
    // ...
};
```

##### 示例
```cpp
class X2 {
    string s = "default";
    int i = 1;
public:
    // 使用编译器生成的默认构造函数
    // ...
};
```

##### 实施
（简单）比起仅仅用常量初始化成员变量，默认构造函数应该做更多事情。

### C.46: 默认情况下，把单个参数的构造函数声明为`explicit`
##### 理由
避免意外的转换。

##### 示例，不好的
```cpp
class String {
    // ...
public:
    String(int);   // 不好的
    // ...
};

String s = 10;   // 意外：大小为10的String
```

##### 例外
如果你真的想要从构造函数的参数类型隐式转换成类类型，不要使用`explicit`：
```cpp
class Complex {
    // ...
public:
    Complex(double d);   // 好的：我们想要从d转换成{d, 0}
    // ...
};

Complex z = 10.7;   // 不意外的转换
```

*另见*：隐式转换的讨论

##### 注意
拷贝和移动构造函数不应为`explicit`，因为他们不执行转换。带有`explicit`的拷贝/移动构造函数使按值来传递和返回变得困难。

##### 实施
（简单）单个参数的构造函数应该声明为`explicit`。合理的单参数且非`explicit`的构造函数在大多数代码库里都是很罕见的。对于所有不在“确定列表”上的这种构造函数发出警告。

### C.47: 根据成员声明的顺序来定义和初始化成员变量
##### 理由
最小化困惑和错误。成员声明的顺序即初始化的顺序（与成员初始化器的顺序不相关）。

##### 示例，不好的
```cpp
class Foo {
    int m1;
    int m2;
public:
    Foo(int x) :m2{x}, m1{++x} { }   // 不好的：有误导的初始化器顺序
    // ...
};

Foo x(1); // 意外：x.m1 == x.m2 == 2
```

##### 实施
（简单）成员初始化列表应该按照成员声明的相同顺序来初始化。

*另见*：讨论

### C.48: 优先在构造函数中对成员初始化器使用类内初始化器，而不是常量初始化器
##### 理由
显式表明希望在所有构造函数中使用相同值。避免重复。避免维护问题。这会产出最短和最高效的代码。

##### 示例，不好的
```cpp
class X {   // 不好的
    int i;
    string s;
    int j;
public:
    X() :i{666}, s{"qqq"} { }   // j没有初始化
    X(int ii) :i{ii} {}         // s为""，而且j没有初始化
    // ...
};
```
维护者怎么知道`j`是否故意不初始化（总之很可能是糟糕的想法），以及`s`的默认值是否有意在一种情况下为`""`而在另一种情况下为`qqq`呢（几乎可以肯定是一个缺陷）？`j`的问题（忘记初始化成员）通常出现在往一个已存在的类添加新成员时。

##### 示例
```cpp
class X2 {
    int i {666};
    string s {"qqq"};
    int j {0};
public:
    X2() = default;        // 所有成员都以默认值初始化
    X2(int ii) :i{ii} {}   // s和j初始化为它们的默认值
    // ...
};
```

*替代方案*：我们可以从构造函数的默认参数中获取部分好处，在旧的代码中这并不罕见。不管怎样，这是不够明显的，会导致传递更多参数，而且如果多于一个构造函数的话会出现重复。
```cpp
class X3 {   // 不好的：不明显，传递参数有额外开销
    int i;
    string s;
    int j;
public:
    X3(int ii = 666, const string& ss = "qqq", int jj = 0)
        :i{ii}, s{ss}, j{jj} { }   // 所有成员都初始化为默认值
    // ...
};
```

##### 实施
* （简单）每个构造函数都应该初始化每个成员变量（可以是显式的，也可以通过委托构造调用或者通过默认构造）。
* （简单）带有默认参数的构造函数表明类内初始化器可能会更合适。

### C.49: 优先在构造函数中使用初始化而不是赋值
##### 理由
初始化显式地表明了执行的是初始化而不是赋值，而且这是更优雅且更高效的。避免“在使用之前设置”的错误。

##### 示例，好的
```cpp
class A {   // 好的
    string s1;
public:
    A() : s1{"Hello, "} { }    // 好的：直接构造
    // ...
};
```

##### 示例，不好的
```cpp
class B {   // 不好的
    string s1;
public:
    B() { s1 = "Hello, "; }   // 不好的：在默认构造函数后紧接着赋值
    // ...
};

class C {   // 难看，又非常不好
    int* p;
public:
    C() { cout << *p; p = new int{10}; }   // 在初始化之前意外地使用
    // ...
};
```

### C.50: 如果你在初始化过程中需要“虚拟行为”，使用工厂函数
##### 理由
如果基类对象的状态必须依赖对象派生部分的状态，我们需要使用虚函数（或者等价的东西），同时尽量减少误用一个未完全构造好的对象的机会。

##### 注意
工厂的返回值类型一般应该默认为`unique_ptr`；如果有些使用的地方是共享的，调用者可以通过`move`把`unique_ptr`移动到`shared_ptr`。当然，如果工厂的作者知道使用返回对象的所有地方都是共享使用，那么可以返回`shared_ptr`并且在函数体中使用`make_shared`来节省一次分配。

##### 示例，不好的
```cpp
class B {
public:
    B()
    {
        // ...
        f();   // 不好的：在构造函数中的虚拟调用
        // ...
    }

    virtual void f() = 0;

    // ...
};
```

##### 示例
```cpp
class B {
protected:
    B() { /* ... */ }              // 创建一个未完全初始化的对象

    virtual void PostInitialize()  // 在构造之后立即调用
    {
        // ...
        f();    // 好的：虚拟派发是安全地
        // ...
    }

public:
    virtual void f() = 0;

    template<class T>
    static shared_ptr<T> Create()  // 创建共享对象的接口
    {
        auto p = make_shared<T>();
        p->PostInitialize();
        return p;
    }
};

class D : public B { /* ... */ };  // 一些派生类

shared_ptr<D> p = D::Create<D>();  // 创建D对象
```
通过使构造函数为`protected`，我们避免了未完全构造的对象逃逸到外部。通过提供工厂函数`Create()`，我们使构造（在自由存储上）更方便。

##### 注意
常规的工厂函数在自由存储上分配，而不是在栈上或者封闭的对象里。

*另见*：讨论

### C.51:使用委托构造函数来表示类的所有构造函数的公共行为
##### 理由
避免重复和意外的差异。

##### 示例，不好的
```cpp
class Date {   // 不好的：重复
    int d;
    Month m;
    int y;
public:
    Date(int ii, Month mm, year yy)
        :i{ii}, m{mm}, y{yy}
        { if (!valid(i, m, y)) throw Bad_date{}; }

    Date(int ii, Month mm)
        :i{ii}, m{mm} y{current_year()}
        { if (!valid(i, m, y)) throw Bad_date{}; }
    // ...
};
```
公共的行为写起来单调乏味，而且可能意外地变得不公共。

##### 示例
```cpp
class Date2 {
    int d;
    Month m;
    int y;
public:
    Date2(int ii, Month mm, year yy)
        :i{ii}, m{mm}, y{yy}
        { if (!valid(i, m, y)) throw Bad_date{}; }

    Date2(int ii, Month mm)
        :Date2{ii, mm, current_year()} {}
    // ...
};
```

*另见*：如果“重复的行为”是简单的初始化，考虑使用类内部的成员初始化器。

##### 实施
（中等）查找相似的构造函数体。

### C.52: 使用继承构造函数把构造函数导入不需要进一步显式初始化的派生类
##### 理由
如果你需要在派生类中使用那些构造函数，重新实现它们是单调乏味而且容易出错的。

##### 示例
`std::vector`有许多复杂的构造函数，所以如果我想要我自己的`vector`，我不想重新实现它们：
```cpp
class Rec {
    // ... 数据和许多不错的构造函数 ...
};

class Oper : public Rec {
    using Rec::Rec;
    // ... 没有数据成员 ...
    // ... 许多不错的工具函数 ...
};
```

##### 示例，不好的
```cpp
struct Rec2 : public Rec {
    int x;
    using Rec::Rec;
};

Rec2 r {"foo", 7};
int val = r.x;   // 未初始化
```

##### 实施
确保派生类的每个成员都经过初始化。

## C.copy: 拷贝和移动
值类型通常应该是可拷贝的，但在类层次结构中的接口则不应该。资源句柄可能可以拷贝，也可能不可以。为了逻辑和性能原因，类型可以定义成可移动的。

### C.60: 使拷贝赋值操作符非`virtual`，以`const&`接收参数，并且以非`const&`返回
##### 理由
这是简单且高效的。如果你想针对右值进行优化，提供一个接受`&&`参数的重载版本（参阅F.18）。

##### 示例
```cpp
class Foo {
public:
    Foo& operator=(const Foo& x)
    {
        // 好的：不需要检查自我赋值（除了性能之外）
        auto tmp = x;
        std::swap(*this, tmp);
        return *this;
    }
    // ...
};

Foo a;
Foo b;
Foo f();

a = b;    // 赋值左值：拷贝
a = f();  // 赋值右值：隐式地移动
```

##### 注意
使用`swap`来实现的技术提供了强力的保证。

##### 示例
不过，如果你可以通过不生成临时拷贝的方式获得轻微的性能提升，会怎么样呢？考虑一个简单的`Vector`，在使用它的场景中，经常出现大型且相同大小的`Vector`的赋值。在这种情况下，由`swap`实现技术隐含的元素拷贝会导致成本在数量级上的增加：
```cpp
template<typename T>
class Vector {
public:
    Vector& operator=(const Vector&);
    // ...
private:
    T* elem;
    int sz;
};

Vector& Vector::operator=(const Vector& a)
{
    if (a.sz > sz) {
        // ... 使用swap技术，这不能被改善 ...
        return *this
    }
    // ... 从*a.elem拷贝元素到elem ...
    if (a.sz < sz) {
        // ... 销毁*this*中剩余的元素，并且调整大小 ...
    }
    return *this;
}
```
通过直接向目标元素写入，我们只得到基础的保证而不是由`swap`技术提供的强力保证。要小心自我赋值。

*替代方案*：如果你认为你需要一个`virtual`赋值操作符，并且理解为什么这是很有问题的，不要称之为`operator=`。创建一个具名的函数如`virtual void assign(const Foo&)`。参阅拷贝构造函数对比`clone()`。

##### 实施
* （简单）赋值操作符不应该是虚拟的。这是邪恶的巨龙！
* （简单）赋值操作符应该返回`T&`以支持链式调用，而不是返回`const T&`这类会干扰可组合性和把对象放到容器中的类型。
* （中等）赋值操作符应该（隐式或显式）调用所有基类和成员的拷贝操作符。查看析构函数来确定该类型是具有指针语义还是值语义。

### C.61: 拷贝操作应该拷贝
##### 理由
这是普遍认定的语义。在执行了`x = y`之后，我们应该有`x == y`的结果。在拷贝之后，`x`和`y`是独立的对象（值语义，非指针的内置类型和标准库类型的使用方式）或者引用共享的对象（指针语义，指针使用的方式）。

##### 示例
```cpp
class X {   // 好：值语义
public:
    X();
    X(const X&);     // 拷贝X
    void modify();   // 修改X的值
    // ...
    ~X() { delete[] p; }
private:
    T* p;
    int sz;
};

bool operator==(const X& a, const X& b)
{
    return a.sz == b.sz && equal(a.p, a.p + a.sz, b.p, b.p + b.sz);
}

X::X(const X& a)
    :p{new T[a.sz]}, sz{a.sz}
{
    copy(a.p, a.p + sz, p);
}

X x;
X y = x;
if (x != y) throw Bad{};
x.modify();
if (x == y) throw Bad{};   // 呈现出值语义
```

##### 示例
```cpp
class X2 {  // 好：指针语义
public:
    X2();
    X2(const X2&) = default; // 浅拷贝
    ~X2() = default;
    void modify();          // 修改指向的值
    // ...
private:
    T* p;
    int sz;
};

bool operator==(const X2& a, const X2& b)
{
    return a.sz == b.sz && a.p == b.p;
}

X2 x;
X2 y = x;
if (x != y) throw Bad{};
x.modify();
if (x != y) throw Bad{};  // 呈现出指针语义
```

##### 注意
优先使用拷贝语义除非你正在创建一个“智能指针”。值语义是最容易理解的，并且是标准库的设施所期望的。

##### 实施
（不可实施）

### C.62: 使拷贝赋值操作符对于自我赋值是安全的
##### 理由
如果`x = x`改变了`x`的值，人们会惊讶，并且会发生严重的错误（通常包含了泄露）。

##### 示例
标准库容器优雅且高效地处理了自我赋值：
```cpp
std::vector<int> v = {3, 1, 4, 1, 5, 9};
v = v;
// v的值仍然是{3, 1, 4, 1, 5, 9}
```

##### 注意
默认赋值在成员正确处理自我赋值时，也能保证正确处理自我赋值。
```cpp
struct Bar {
    vector<pair<int, int>> v;
    map<string, int> m;
    string s;
};

Bar b;
// ...
b = b;   // 正确和高效的
```

##### 注意
你可以通过显式地检测自我赋值来处理它，但通常不使用检测来应付的话会更快且更高效（例如，使用`swap`）。
```cpp
class Foo {
    string s;
    int i;
public:
    Foo& operator=(const Foo& a);
    // ...
};

Foo& Foo::operator=(const Foo& a)   // 可以，但有额外开销
{
    if (this == &a) return *this;
    s = a.s;
    i = a.i;
    return *this;
}
```
这是明显安全和有效的。然而，要是我们每一百万次赋值才执行一次自我赋值呢？那么就会存在大约一百万次冗余的检测（但由于检测的结果基本上总是相同的，计算机的分支预测基本上每次都会猜对）。考虑下面的：
```cpp
Foo& Foo::operator=(const Foo& a)   // 更简单，并且可能更好
{
    s = a.s;
    i = a.i;
    return *this;
}
```
`std::string`对于自我赋值是安全的，`int`也是。所有额外开销都由（罕见的）自我赋值情况带走了。

##### 实施
（简单）赋值操作符不应该包含`if (this == &a) return *this;`的模式。???

### C.63: 使移动赋值操作符非`virtual`，以`&&`接收参数，并且以非`const&`返回
##### 理由
这是简单和高效的。

*参阅*：拷贝赋值的准则。

##### 实施
与拷贝赋值做的事情相同。
* （简单）赋值操作符不应该是虚拟的。这是邪恶的巨龙！
* （简单）赋值操作符应该返回`T&`以支持链式调用，而不是返回`const T&`这类会干扰可组合性和把对象放到容器中的类型。
* （中等）移动赋值操作符应该（隐式或显式）调用所有基类和成员的移动操作符。

### C.64: 移动操作应该移动并且让它的来源处于有效的状态
##### 理由
这是普遍认定的语义。在执行了`y = std::move(x)`之后，`y`的值应该是`x`原来的值，并且`x`应该处于有效的状态。

##### 示例
```cpp
template<typename T>
class X {   // 好：值语义
public:
    X();
    X(X&& a) noexcept;  // 移动X
    void modify();     // 改变X的值
    // ...
    ~X() { delete[] p; }
private:
    T* p;
    int sz;
};


X::X(X&& a)
    :p{a.p}, sz{a.sz}  // 偷取内部表示
{
    a.p = nullptr;     // 设置为“空”
    a.sz = 0;
}

void use()
{
    X x{};
    // ...
    X y = std::move(x);
    x = X{};   // 好
} // 好：x可以被销毁
```

##### 注意
理想情况下，在被移走之后，对象应该是类型的默认值。要保证这一点，除非有特别好的理由不这么做。当然，不是所有类型都有默认值，而且有些类型建立默认值是昂贵的。C++标准只要求被移走的对象能够销毁。通常，我们可以容易且廉价地做得更好：标准库假定对被移走的对象赋值是可能的。总是让被移走的对象处于某种有效的状态。

##### 注意
除非有特别强烈的理由不这么做，否则应使`x = std::move(y); y = z;`能按照惯用语义正常执行。

##### 实施
（不可实施）查找在移动操作中对成员的赋值。如果存在默认构造函数，把那些赋值与默认构造函数中的初始化进行对比。

### C.65: 使移动赋值操作符对于自我赋值是安全的
##### 理由
如果`x = x`改变了`x`的值，人们会感到惊讶，并且会发生严重的错误。当然，人们一般不会直接写出会转变成移动的自我赋值，但它是可能发生的。不管怎样，`std::swap`使用了移动操作来实现，因此如果你意外地执行了`swap(a, b)`，而`a`和`b`指向同一个对象的话，不能处理自我移动是严重且不易察觉的错误。

##### 示例
```cpp
class Foo {
    string s;
    int i;
public:
    Foo& operator=(Foo&& a);
    // ...
};

Foo& Foo::operator=(Foo&& a) noexcept  // 没问题，但是有额外的开销
{
    if (this == &a) return *this;  // 这一行是冗余的
    s = std::move(a.s);
    i = a.i;
    return *this;
}
```
在自我赋值的论述中，关于`if (this == &a) return *this;`这个检测存在的“一百万次中的一次”问题的讨论，对于自我移动来说甚至更有意义。

##### 注意
没有已知的普遍适用的方法来避免移动赋值中的`if (this == &a) return *this;`检测，而又仍然能够得到正确的结果（例如，在执行了`x = x`之后`x`的值不发生改变）。

##### 注意
ISO标准保证了对于标准库容器只有一个“有效但不确定的”状态。显然，在将近10年的试验和正式产品使用中这还不是问题。如果你发现了反例，请联系作者。这里的准则会更加谨慎且坚持完全的安全。

##### 示例
这里是一个移动指针而不需要检测的方法（想像这是在一个移动赋值的实现中的代码）：
```cpp
// 从other.ptr移动到this->ptr
T* temp = other.ptr;
other.ptr = nullptr;
delete ptr;
ptr = temp;
```

##### 实施
* （中等）在自我赋值的情况下，移动赋值操作符不应该让对象持有已经被`delete`删除或者设置成`nullptr`的指针成员。
* （不可实施）查看标准库容器类型的使用（包括`string`），并考察它们对于普通用法（非生命周期紧密相关的）是否安全。

### C.66: 使移动操作为`noexcept`
##### 理由
会抛异常的移动操作违背了大多数人合理的假设。不会抛异常的移动操作在标准库和语言的设施中用起来更高效。

##### 示例
```cpp
template<typename T>
class Vector {
    // ...
    Vector(Vector&& a) noexcept :elem{a.elem}, sz{a.sz} { a.sz = 0; a.elem = nullptr; }
    Vector& operator=(Vector&& a) noexcept { elem = a.elem; sz = a.sz; a.sz = 0; a.elem = nullptr; }
    // ...
public:
    T* elem;
    int sz;
};
```
这些操作不会抛异常。

##### 示例，不好的
```c
template<typename T>
class Vector2 {
    // ...
    Vector2(Vector2&& a) { *this = a; }             // 只使用了拷贝
    Vector2& operator=(Vector2&& a) { *this = a; }  // 只使用了拷贝
    // ...
public:
    T* elem;
    int sz;
};pp
```
`Vector2`不仅效率低，而且由于拷贝需要分配，可能会抛异常。

##### 实施
（简单）移动操作应该标记为`noexcept`。

### C.67: 如果希望拥有“拷贝行为”，基类应该阻止拷贝，并且提供一个虚拟的`clone`来代替
##### 理由
避免对象切割，因为普通的拷贝操作只拷贝派生对象的基类部分。

##### 示例，不好的
```cpp
class B { // 不好的：基类没有屏蔽拷贝
    int data;
    // ... 拷贝操作不需要做什么，因此使用默认的 ...
};

class D : public B {
    string more_data; // 添加一个数据成员
    // ...
};

auto d = make_unique<D>();

// 糟糕，切割了对象；只得到d.data，丢失了d.more_data
auto b = make_unique<B>(d);
```

##### 示例
```cpp
class B { // 好：基类屏蔽了拷贝
public:
    B(const B&) = delete;
    B& operator=(const B&) = delete;
    virtual unique_ptr<B> clone() { return /* B object */; }
    // ...
};

class D : public B {
    string more_data; // 添加一个数据成员
    unique_ptr<B> clone() override { return /* D object */; }
    // ...
};

auto d = make_unique<D>();
auto b = d.clone(); // 没问题，深克隆
```

##### 注意
返回智能指针是好的，但它不像原始指针那样可以使用协变返回类型（例如，`D::clone`不能返回`unique_ptr<D>`。不要让这个引诱你返回原始指针；与智能指针提供的主要健壮性好处相比，这是次要的缺点。

##### 例外
如果你需要协变返回类型，返回`owner<derived*>`。参阅C.130。

##### 实施
具有任何虚拟函数的类不应该有拷贝构造函数或者拷贝赋值操作符（不论是编译器生成的还是手写的）。

## C.other: 其它默认操作准则
除了语言提供默认实现的操作，还有一些操作非常基础，因此需要准则来规范它们的定义：比较，`swap`和`hash`。

### C.80: 如果你必须显式说明要使用默认语义，使用`=default`
##### 理由
编译器更可能得到正确的默认语义，而且你不可能把这些函数实现得比编译器更好。

##### 示例
```cpp
class Tracer {
    string message;
public:
    Tracer(const string& m) : message{m} { cerr << "entering " << message << '\n'; }
    ~Tracer() { cerr << "exiting " << message << '\n'; }

    Tracer(const Tracer&) = default;
    Tracer& operator=(const Tracer&) = default;
    Tracer(Tracer&&) = default;
    Tracer& operator=(Tracer&&) = default;
};
```
因为我们定义了析构函数，所以我们必须定义拷贝和移动操作。使用`=default`达到这个目的是最好且最简单的。

##### 示例，不好的
```cpp
class Tracer2 {
    string message;
public:
    Tracer2(const string& m) : message{m} { cerr << "entering " << message << '\n'; }
    ~Tracer2() { cerr << "exiting " << message << '\n'; }

    Tracer2(const Tracer2& a) : message{a.message} {}
    Tracer2& operator=(const Tracer2& a) { message = a.message; return *this; }
    Tracer2(Tracer2&& a) :message{a.message} {}
    Tracer2& operator=(Tracer2&& a) { message = a.message; return *this; }
};
```
写出拷贝和移动操作的的函数体是冗余的，单调乏味的，而且容易出错的。编译器会做得更好。

##### 实施
（中等）特殊操作的函数体不应该与编译器生成的版本具有相同的访问操作和语义，因为那是冗余的。

### C.81: 当你想要禁用默认行为（又不想要其它替代方案）时，使用`=delete`
##### 理由
在一些情况下，不希望使用默认操作。

##### 示例
```cpp
class Immortal {
public:
    ~Immortal() = delete;   // 不允许析构
    // ...
};

void use()
{
    Immortal ugh;   // 出错：ugh不能被销毁
    Immortal* p = new Immortal{};
    delete p;       // 出错：不能销毁*p
}
```

##### 示例
`unique_ptr`可以移动，但不能拷贝。为了达到这个目的，它的拷贝操作被删除了。为了避免拷贝，有必要在接受左值的拷贝操作上使用`=delete`：
```cpp
template <class T, class D = default_delete<T>> class unique_ptr {
public:
    // ...
    constexpr unique_ptr() noexcept;
    explicit unique_ptr(pointer p) noexcept;
    // ...
    unique_ptr(unique_ptr&& u) noexcept;   // 移动构造函数
    // ...
    unique_ptr(const unique_ptr&) = delete; // 禁用对左值的拷贝
    // ...
};

unique_ptr<int> make();   // 创建“一些东西”然后通过移动来返回

void f()
{
    unique_ptr<int> pi {};
    auto pi2 {pi};      // 错误：不存在接受左值的移动构造函数
    auto pi3 {make()};  // 没问题，移动：make()的结果是一个右值
}
```
注意被删除的方法应该是公有的。

##### 实施
是否排除默认操作（应该）基于类所期望的语义。要对排除了默认操作的类持有怀疑态度，但同时要维护一份“正确列表”，这份列表中的类已经由人们断定语义是正确的。

### C.82: 不要在构造函数和析构函数中调用虚函数
##### 理由
调用的函数是到调用点为止已构造对象的函数，而不是可能在派生类中重写的函数。这是最令人困惑的。更糟糕的是，在构造函数或者析构函数中直接或者间接调用未实现的纯虚函数会导致未定义的行为。

##### 示例，不好的
```cpp
class Base {
public:
    virtual void f() = 0;   // 未实现
    virtual void g();       // 实现了基类版本
    virtual void h();       // 实现了基类版本
};

class Derived : public Base {
public:
    void g() override;   // 提供派生实现
    void h() final;      // 提供派生实现

    Derived()
    {
        // 不好：尝试调用未实现的虚函数
        f();

        // 不好：会调用Derived::g，不会进一步派发虚拟调用
        g();

        // 好：显式声明意图只调用可见的版本
        Derived::g();

        // 没问题，不需要限定，h是最终的
        h();
    }
};
```
注意，调用指定了显式限定的函数不是虚拟调用，即使该函数是`virtual`。

*另见*工厂函数来看看如何达到调用派生类函数的效果而不会有未定义行为的风险。

##### 注意
从构造函数和析构函数中调用虚函数不存在内在的错误。这些调用的语义是类型安全地。然而，经验表明这些调用很少需要，容易迷惑维护者，而且当新手使用的时候会成为错误的来源。

##### 实施
* 标记出在构造函数和析构函数中调用的虚函数。

### C.83: 对于值类型，考虑提供一个`noexcept`交换函数
##### 理由
`swap`可以用来方便地实现许多惯用法，从平滑地移动对象到容易地实现赋值，它提供了有保证的提交函数来实现强错误安全的调用代码。考虑使用交换来根据拷贝构造实现拷贝赋值。另外可参阅析构函数、析构和交换不能失败。

##### 示例，好的
```cpp
class Foo {
    // ...
public:
    void swap(Foo& rhs) noexcept
    {
        m1.swap(rhs.m1);
        std::swap(m2, rhs.m2);
    }
private:
    Bar m1;
    int m2;
};
```
为了方便调用者，可以在与你的类型相同的名称空间内提供一个非成员`swap`函数。
```cpp
void swap(Foo& a, Foo& b)
{
    a.swap(b);
}
```

##### 实施
* （简单）没有虚函数的类应该声明一个`swap`成员函数。
* （简单）如果类有一个`swap`成员函数，它应该声明为`noexcept`。

### C.84: `swap`不能失败
##### 理由
`swap`广泛地用在假定不会失败的地方，而且假如存在会失败的`swap`，则不能容易地写出仍然能够正确运行的程序。标准库的容器和算法在元素类型的交换函数失败时不能够正确执行。

##### 示例，不好的
```cpp
void swap(My_vector& x, My_vector& y)
{
    auto tmp = x;   // 拷贝元素
    x = y;
    y = tmp;
}
```
这样做不仅仅慢，而且如果`tmp`内的元素发生了内存分配，这个`swap`可能会抛异常，导致使用了它的STL算法失败。

##### 实施
（简单）如果类有一个`swap`成员函数，它应该声明为`noexcept`。

### C.85: 使`swap`为`noexcept`
##### 理由
`swap`不能失败。如果`swap`试图用异常来退出，这是糟糕的设计错误，程序最好终止。

##### 实施
（简单）如果类有一个`swap`成员函数，它应该声明为`noexcept`。

### C.86: 使`==`的操作数类型对称，并且为`noexcept`
##### 理由
不对称地对待操作数是令人诧异的，当存在可能的类型转换时，这是错误的来源。`==`是基础的操作，程序员应该能够在不担心失败的情况下使用它。

##### 示例
```cpp
struct X {
    string name;
    int number;
};

bool operator==(const X& a, const X& b) noexcept {
    return a.name == b.name && a.number == b.number;
}
```

##### 示例，不好的
```cpp
class B {
    string name;
    int number;
    bool operator==(const B& a) const {
        return name == a.name && number == a.number;
    }
    // ...
};
```
`B`的比较接受第二个操作数的转换，但第一个操作数不能。

##### 注意
如果类具有失败状态，比如`double`的`NaN`，它会诱惑你在与失败状态比较时抛异常。替代方法是让两个失败状态的比较结果为相等，并且任何正确状态与失败状态的比较结果为不相等。

##### 注意
该准则适用于所有常见的比较操作符：`!=`，`<`，`<=`和`>=`。

##### 实施
* 标记出参数类型不一样的`operator==()`；其它比较操作符也一样：`!=`，`<`，`<=`，`>`和`>=`。
* 标记出作为成员的`operator==()`；其它比较操作符也一样：`!=`，`<`，`<=`，`>`和`>=`。

### C.87: 注意基类的`==`
##### 理由
为类层次结构写出不会出错而且有用的`==`真的非常困难。

##### 示例，不好的
```cpp
class B {
    string name;
    int number;
    virtual bool operator==(const B& a) const
    {
         return name == a.name && number == a.number;
    }
    // ...
};
```
`B`的比较操作接受第二个操作数的转换，但它的第一个操作数不能。

```cpp
class D :B {
    char character;
    virtual bool operator==(const D& a) const
    {
        return name == a.name && number == a.number && character == a.character;
    }
    // ...
};

B b = ...
D d = ...
b == d;    // 比较name和number，忽略d的character
d == b;    // 出错：没有定义相关的==
D d2;
d == d2;   // 比较name，number和character
B& b2 = d2;
b2 == d;   // 比较name和number，忽略d2和d的character
```
当然有办法可以让`==`在类层次结构中运作，但是这个天真的方法是不通用的。

##### 注意
该准则适用于所有常见的比较操作符：`!=`，`<`，`<=`和`>=`。

##### 实施
* 标记出虚拟的`operator==()`；其它比较操作符也一样：`!=`，`<`，`<=`和`>=`。

### C.89: 使`hash`为`noexcept`
##### 理由
哈希容器的用户会直接使用`hash`，而且不希望这个简单的访问会抛异常。这是标准库的要求。

##### 示例，不好的
```cpp
template<>
struct hash<My_type> {  // 完全错误的hash特化
    using result_type = size_t;
    using argument_type = My_type;

    size_t operator() (const My_type & x) const
    {
        size_t xs = x.s.size();
        if (xs < 4) throw Bad_My_type{};    // "Nobody expects the Spanish inquisition!"
        return hash<size_t>()(x.s.size()) ^ trim(x.s);
    }
};

int main()
{
    unordered_map<My_type, int> m;
    My_type mt{ "asdfg" };
    m[mt] = 7;
    cout << m[My_type{ "asdfg" }] << '\n';
}
```
如果你必须定义`hash`的特化版本，尽量用`^`（异或）组合标准库中的`hash`特化版本来简化它。对于非专家来说，这比“聪明”运作得更好。

##### 实施
* 标记出会抛异常的`hash`。

## C.con: 容器和其它资源句柄
容器是一个对象，它持有某种类型的对象序列；`std::vector`是基础的容器。资源句柄是一个类，它持有资源；`std::vector`是典型的资源句柄；它的资源是它的对象序列。

容器准则概要：
* C.100: 定义容器的时候遵守STL
* C.101: 为容器提供值语义
* C.102: 为容器提供移动操作
* C.103: 为容器提供初始化列表构造函数
* C.104: 为容器提供设置为空的默认构造函数
* C.105: 提供构造函数和`Extent`构造函数
* ???
* C.109: 如果资源句柄有指针语义，提供`*`和`->`

*另见*：资源

## C.lambdas: 函数对象和lambda
函数对象是一个提供了`()`重载的对象，因此你可以调用它。lambda表达式（在口语上通常简称为“lambda”）是生成函数对象的表示法。函数对象的拷贝应该是廉价的（因此可以以值来传递）。

概要：
* F.50: 在函数不能达到目的的时候使用lambda（捕捉局部变量，或者写一个局部函数）
* F.52: 在局部使用的lambda中，优先以引用来捕获变量，包括传递给算法
* F.53: 在非局部使用的lambda中，避免以引用来捕获变量，包括返回，在堆中存储，或者传递给其它线程
* ES.28: 对复杂的初始化使用lambda，特别是`const`变量

## C.hier: 类层次结构（OOP）
类层次结构（只）用来表示一组分层组织的概念。通常基类会作为接口。对于层次结构有两种主要的用法，通常称之为实现继承和接口继承。

类层次结构准则概要：
* C.120: （只）使用类层次结构来表示继承的层次概念
* C.121: 如果基类用作接口，使其为纯抽象类
* C.122: 当需要完全分离接口和实现的时候，使用抽象类作为接口

层次结构中类的设计准则概要：
* C.126: 抽象类通常不需要构造函数
* C.127: 有虚函数的类应该有虚拟或者受保护的析构函数
* C.128: 虚函数应该只指定`virtual`、`override`或者`final`的其中一个
* C.129: 在设计类层次结构的时候，区分实现继承和接口继承
* C.130: 在基类中重定义或者禁止拷贝；优先使用虚拟的`clone`函数代替
* C.131: 避免无意义的获取函数和设置函数
* C.132: 不要无故使使函数为`virtual`
* C.133: 避免`protected`数据
* C.134: 保证所有非`const`数据成员有相同的访问级别
* C.135: 使用多重继承来表示多个不同的接口
* C.136: 使用多重继承来表示实现属性的合并
* C.137: 使用`virtual`基类来避免过于通用的基类
* C.138: 使用`using`为派生类和它的基类创建重载集合
* C.139: 保守地使用`final`
* C.140: 不要为虚拟函数和它的覆写函数提供不同的默认参数

在层次结构中访问对象的准则概要：
* C.145: 通过指针和引用访问多态对象
* C.146: 当类层次结构的类型访问不可避免时，使用`dynamic_cast`
* C.147: 当不能找到所需的类视为错误时，在引用类型上使用`dynamic_cast`
* C.148: 当不能找到所需的类视为有效的可选状态时，在指针类型上使用`dynamic_cast`
* C.149: 使用`unique_ptr`或`shared_ptr`来避免忘记用`delete`删除由`new`创建的对象
* C.150: 使用`make_unique()`来构造由`unique_ptr`持有的对象
* C.151: 使用`make_shared()`来构造由`shared_ptr`持有的对象
* C.152: 永不将指向派生类对象数组的指针赋值给指向其基类的指针
* C.153: 优先使用虚拟函数而不是类型转换

###  C.120: （只）使用类层次结构来表示继承的层次概念
##### 理由
直接在代码中表达想法易于理解和维护。要确保在基类中表达的想法完全匹配所有派生类型，并且没有比使用紧耦合继承更好表达地这个想法的方式。

当简单地持有数据成员就能够达到目的的时候，不要使用继承。通常这意味着派生类需要覆写基类的虚拟函数或者需要访问受保护成员。

##### 示例
```cpp
class DrawableUIElement {
public:
    virtual void render() const = 0;
    // ...
};

class AbstractButton : public DrawableUIElement {
public:
    virtual void onClick() = 0;
    // ...
};

class PushButton : public AbstractButton {
    virtual void render() const override;
    virtual void onClick() override;
    // ...
};

class Checkbox : public AbstractButton {
// ...
};
```

##### 示例，不好的
不要把无层次的领域概念表示为类层次结构。
```cpp
template<typename T>
class Container {
public:
    // list operations:
    virtual T& get() = 0;
    virtual void put(T&) = 0;
    virtual void insert(Position) = 0;
    // ...
    // vector operations:
    virtual T& operator[](int) = 0;
    virtual void sort() = 0;
    // ...
    // tree operations:
    virtual void balance() = 0;
    // ...
};
```
这里，大部分覆写的类不能很好地实现接口要求的大部分函数。所以这个基类变成了实现负担。而且，`Container`的用户不能指望成员函数真的合理高效地执行了有意义的操作；相反它可能会抛出异常。因此，用户必须求助于运行时检查，并且/或者不使用这个（过于）通用的接口，转而使用基于运行时类型查询（例如`dynamic_cast`）创建的特殊接口。

##### 实施
* 查找那些拥有许多不做事情只抛出异常的成员的类。
* 标记出对非公有基类`B`的每处使用，其中`B`的派生类`D`不覆写虚拟函数或访问`B`的受保护成员，而且`B`不是以下情况中的一种：空类，模板参数或者`D`的参数包，用`D`特化的类模板。

### C.121: 如果基类用作接口，使其为纯抽象类
##### 理由
如果一个类不包含数据，会更加稳定（更不脆弱）。接口通常应该完全有公有的纯虚拟函数和默认/空的虚拟析构函数组成。

##### 示例
```cpp
class My_interface {
public:
    // ... 这里只有纯虚拟函数 ...
    virtual ~My_interface() {}   // 或者 =default
};
```

##### 示例，不好的
```cpp
class Goof {
public:
    // ... 这里只有纯虚拟函数 ...
    // 没有虚拟析构函数
};

class Derived : public Goof {
    string s;
    // ...
};

void use()
{
    unique_ptr<Goof> p {new Derived{"here we go"}};
    f(p.get()); // 通过Goof的接口使用Derived
    g(p.get()); // 通过Goof的接口使用Derived
} // 泄露
```
`Derived`通过它的`Goof`接口用`delete`来删除，所以它的`string`泄露了。为`Goof`提供虚拟析构函数之后，一切都没问题了。

##### 实施
* 对于任意类，如果它包含数据成员，同时有可覆写（非`final`）的虚拟函数，发出警告。

### C.122: 当需要完全分离接口和实现的时候，使用抽象类作为接口
##### 理由
比如说在ABI（链接）的边界上

##### 示例
```cpp
struct Device {
    virtual ~Device() = default;
    virtual void write(span<const char> outbuf) = 0;
    virtual void read(span<char> inbuf) = 0;
};

class D1 : public Device {
    // ... 数据 ...

    void write(span<const char> outbuf) override;
    void read(span<char> inbuf) override;
};

class D2 : public Device {
    // ... 不同的数据 ...

    void write(span<const char> outbuf) override;
    void read(span<char> inbuf) override;
};
```
用户现在可以通过`Device`提供的接口可交换地使用`D1`和`D2`。而且，我们可以使用与旧版本非二进制兼容的方式来更新`D1`和`D2`，只要所有访问都通过`Device`。

##### 实施
???

## C.hierclass: 设计在层次结构中的类
### C.126: 抽象类通常不需要构造函数
##### 理由
抽象类通常没有任何数据让构造函数初始化。

##### 示例
???

##### 例外
* 基类的构造函数确实有用，例如在某个地方注册一个对象，可能需要构造函数。
* 在极端罕见的情况下，你可能会发现抽象类拥有一点被所有派生类共享的数据是合理的（例如，使用静态数据，调试信息等）；这些类倾向于有构造函数。但是要提醒你：这些类同样容易倾向于需要虚拟继承。

##### 实施
标记出有构造函数的抽象类。

### C.127: 有虚函数的类应该有虚拟或者受保护的析构函数
##### 理由
拥有虚拟函数的类时常（而且通常）通过基类的指针来使用。一般情况下，最后的用户必须在基类的指针上调用`delete`，这通常是通过基类的智能指针，因此这个类的析构函数应该是公有的和虚拟的。在较不常见的情况下，如果不希望支持通过基类指针来删除，析构函数应该是受保护的和非虚拟的；参阅C.35。

##### 示例，不好的
```cpp
struct B {
    virtual int f() = 0;
    // ... 没有用户提供的析构函数，默认为公有非虚拟的 ...
};

// 糟糕的：从没有虚拟析构函数的类派生
struct D : B {
    string s {"default"};
};

void use()
{
    unique_ptr<B> p = make_unique<D>();
    // ...
} // 未定义行为。可能只调用B::~B并且泄露了string
```

### 注意
有些人不遵循该准则，因为他们希望只通过`shared_ptr`来使用类：`std::shared_ptr<B> p = std::make_shared<D>(args);`。这里，共享的指针会处理好删除，因此对基类不合适的`delete`不会发生泄露。经常这样做的人会错误地乐观，但该准则是重要的——如果有一个对象是使用`make_unique`分配的呢？这是不安全的，除非`B`的作者保证了它永远不会被误用，例如让所有构造函数都为私有的，并且提供工厂函数来保证用`make_shared`分配。

##### 实施
* 拥有任何虚拟函数的类都应该有一个析构函数，该函数即可以是公有且虚拟的，也可以是受保护且非虚拟的。
* 标记出作用于有虚拟函数但没有虚拟析构函数的类上的`delete`。

### C.128: 虚函数应该只指定`virtual`、`override`或者`final`的其中一个
##### 理由
可读性。检测错误。写出明显的`virtual`、`override`或者`final`是自带文档的，并且能够让编译器捕捉在基类和派生类之间不匹配的类型以及/或者名称。然而，在这三者中，写出一个以上都是冗余的，而且是潜在的错误来源。

只有在声明新的虚拟函数时使用`virtual`。只有在声明覆写函数时使用`override`。只有在声明终结的覆写函数时使用`final`。如果基类的析构函数声明为`virtual`，那么要避免声明派生类的析构函数为`virtual`或者`override`。一些代码库和工具可能会坚持在析构函数使用`override`，但在这些指南中这是不建议的。

##### 示例，不好的
```cpp
struct B {
    void f1(int);
    virtual void f2(int) const;
    virtual void f3(int);
    // ...
};

struct D : B {
    void f1(int);        // 不好的（希望能有警告）：D::f1()隐藏了B::f1()
    void f2(int) const;  // 不好的（但符合习惯并且有效）：没有显式覆写
    void f3(double);     // 不好的（希望能有警告）：D::f3()隐藏了B::f3()
    // ...
};
```

##### 示例，好的
```cpp
struct Better : B {
    void f1(int) override;        // 错误（被捕捉）：D::f1()隐藏了B::f1()
    void f2(int) const override;
    void f3(double) override;     // 错误（被捕捉）：D::f3()隐藏了B::f3()
    // ...
};
```

##### 实施
* 比较基类和派生类中的名称，标记出使用了相同名称但没有覆写的函数。
* 标记出既没有用`override`也没有用`final`的覆写函数。
* 标记出使用了`virtual`、`override`和`final`中超过一个以上的函数声明。

### C.129: 在设计类层次结构的时候，区分实现继承和接口继承
##### 理由
在接口中存在的实现细节会使接口脆弱；也就是说，会让它的用户容易受到影响，在修改了接口实现之后不得不重新编译。在基类中的数据增加了基类实现的复杂度，而且会导致重复代码。

##### 注意
定义：
* 接口继承是用来隔离用户和实现的继承，特别是允许在不影响基类用户的前提下添加和修改派生类。
* 实现继承是用来简化新功能实现的继承，为新操作的实现提供有用的相关操作（有时候称为“根据差异编程”）。

纯接口类是简单的纯虚拟函数集合；参阅I.25。

在早期的OOP中（例如，在1980年代和1990年代），实现继承和接口继承通常混淆在一起，这个坏习惯很难消灭。即使是现在，这种混合的代码在旧代码库和旧式教材里并非罕见。

保持这两种继承的重要性在增加
* 随着层次结构大小的增长（例如，很多的派生类），
* 随着层次结构被使用的时间长度的增加（例如，数十年），以及
* 随着使用层次结构的不同组织数量的增加（例如，难以对基类发布新的更新）。

##### 示例，不好的
```cpp
class Shape {   // 不好的，混合了接口和实现
public:
    Shape();
    Shape(Point ce = {0, 0}, Color co = none): cent{ce}, col {co} { /* ... */}

    Point center() const { return cent; }
    Color color() const { return col; }

    virtual void rotate(int) = 0;
    virtual void move(Point p) { cent = p; redraw(); }

    virtual void redraw();

    // ...
private:
    Point cent;
    Color col;
};

class Circle : public Shape {
public:
    Circle(Point c, int r) :Shape{c}, rad{r} { /* ... */ }

    // ...
private:
    int rad;
};

class Triangle : public Shape {
public:
    Triangle(Point p1, Point p2, Point p3); // 计算中点
    // ...
};
```
存在的问题：
* 随着层次结构增长，以及更多的数据添加到`Shape`，构造函数会更加难以编写和维护。
* 为什么要为`Triangle`计算中点？我们也许从来不使用它。
* 添加一个数据成员到`Shape`（例如，绘制样式或者画布），所有派生类和所有用户都需要重新检查，可能要进行修改，可能要重新编译。

`Shape::move()`的实现是实现继承的例子：我们只为所有派生类定义`move()`一次。越多代码在基类的成员函数实现中，以及越多数据放在基类中来共享，我们就会得到更多好处——同时层次结构会更不稳定。

##### 示例
这个`Shape`的层次结构可以使用接口继承来重写：
```cpp
class Shape {  // 纯接口
public:
    virtual Point center() const = 0;
    virtual Color color() const = 0;

    virtual void rotate(int) = 0;
    virtual void move(Point p) = 0;

    virtual void redraw() = 0;

    // ...
};
```
注意纯接口几乎不会有构造函数：没有东西要构造。
```cpp
class Circle : public Shape {
public:
    Circle(Point c, int r, Color c) :cent{c}, rad{r}, col{c} { /* ... */ }

    Point center() const override { return cent; }
    Color color() const override { return col; }

    // ...
private:
    Point cent;
    int rad;
    Color col;
};
```
该接口现在没那么脆弱了，但在成员函数的实现中会有更多工作。例如，`center`必须由每个派生自`Shape`的类实现。

##### 示例，双重层次结构
我们怎样可以从接口继承得到稳定的层次结构，同时从实现继承得到复用实现的好处呢？一个广泛使用的技术是双重层次结构。有许多方法来实现双重层次结构的想法；这里，我们使用一个多重继承的变体。

首先我们设计接口类的层次结构：
```cpp
class Shape {   // 纯接口
public:
    virtual Point center() const = 0;
    virtual Color color() const = 0;

    virtual void rotate(int) = 0;
    virtual void move(Point p) = 0;

    virtual void redraw() = 0;

    // ...
};

class Circle : public Shape {   // 纯接口
public:
    virtual int radius() = 0;
    // ...
};
```
为了让这个接口有用，我们必须提供它的实现类（这里，类的命名一样，但在`Impl`名称空间中）：
```cpp
class Impl::Shape : public Shape { // 实现
public:
    // 构造函数，析构函数
    // ...
    Point center() const override { /* ... */ }
    Color color() const override { /* ... */ }

    void rotate(int) override { /* ... */ }
    void move(Point p) override { /* ... */ }

    void redraw() override { /* ... */ }

    // ...
};
```
现在`Shape`是一个带有实现的类的拙劣例子，但我们可以容忍，因为这只是一个针对复杂层次结构技术的简单的示例。
```cpp
class Impl::Circle : public Circle, public Impl::Shape {   // 实现
public:
    // 构造函数，析构函数

    int radius() override { /* ... */ }
    // ...
};
```
然后我们可以添加一个`Smiley`类（:-)）来扩展这个层次结构：
```cpp
class Smiley : public Circle { // 纯接口
public:
    // ...
};

class Impl::Smiley : public Smiley, public Impl::Circle {   // 实现
public:
    // 构造函数，析构函数
    // ...
}
```
现在有了两个层次结构：
* 接口：`Smiley` -> `Circle` -> `Shape`
* 实现：`Impl::Smiley` -> `Impl::Circle` -> `Impl::Shape`

由于每个实现都从它的接口和实现基类派生，我们得到一个格子框架（DAG）：
```
Smiley     ->         Circle     ->  Shape
  ^                     ^               ^
  |                     |               |
Impl::Smiley -> Impl::Circle -> Impl::Shape
```

正如上面提到的，这只是构建双重层次结构的一种方法。

实现层次结构可以直接使用，而不用通过抽象接口。
```cpp
void work_with_shape(Shape&);

int user()
{
    Impl::Smiley my_smiley{ /* args */ };   // 创建具体形状
    // ...
    my_smiley.some_member();        // 直接使用实现类
    // ...
    work_with_shape(my_smiley);     // 通过抽象接口使用实现
    // ...
}
```
如果实现类含有的成员没有在抽象接口中提供，或者如果直接使用成员能提供优化的机会，这种做法是有用的（例如，如果一个实现的成员函数为`final`）。

##### 注意
另一个与隔离接口和实现（相关的）技术是Pimpl。

##### 注意
在把通用功能作为（实现）基类中的函数和自由函数（在一个实现名称空间中）之间，通常会有个选择。基类提供了更短的表示符号，而且更容易访问（在基类中的）共享数据，代价是这个功能只对层次结构的用户可用。

##### 实施
* 标记出派生来到基类转换，该基类同时拥有数据和虚拟函数（除了从派生类成员到基类成员的调用）。
* ???

### C.130: 在基类中重定义或者禁止拷贝；优先使用虚拟的`clone`函数代替
##### 理由
拷贝基类通常会导致对象切割。如果你真的需要拷贝语义，那么要深拷贝：提供一个虚拟的`clone`函数，该函数会拷贝实际最深层派生的类型，并且返回一个指向新对象的指针，然后在派生类中返回这个派生类型（使用协变返回类型）。

##### 示例
```cpp
class Base {
public:
    virtual owner<Base*> clone() = 0;
    virtual ~Base() = 0;

    Base(const Base&) = delete;
    Base& operator=(const Base&) = delete;
};

class Derived : public Base {
public:
    owner<Derived*> clone() override;
    virtual ~Derived() override;
};
```
注意，由于语言规则，协变返回类型不能用于智能指针。参阅C.67。

##### 实施
* 标记出拥有虚拟函数以及非用户定义拷贝操作的类。
* 标记出对基类对象的赋值（对象的类派生于另一个对象的类）。

### C.131: 避免无意义的获取函数和设置函数
##### 理由
无意义的获取函数和设置函数没有增加语义价值；数据项也可以是`public`的。

##### 示例
```cpp
class Point {   // 不好的：啰嗦
    int x;
    int y;
public:
    Point(int xx, int yy) : x{xx}, y{yy} { }
    int get_x() const { return x; }
    void set_x(int xx) { x = xx; }
    int get_y() const { return y; }
    void set_y(int yy) { y = yy; }
    // 没有具有行为的成员函数
};
```
考虑把这种类定义成`struct`——也就是说，没有行为的变量捆绑，所有成员都是公有数据，没有成员函数。
```cpp
struct Point {
    int x {0};
    int y {0};
};
```
注意我们可以在成员变量中使用默认初始化器：C.49: 优先在构造函数中使用初始化而不是赋值。

##### 注意
这个准则的关键是获取函数/设置函数的语义是否无意义的。可是“无意义”并没有完整的定义，因此要想想如果获取函数/设置函数是公有数据成员的话，在语法之上是否会有任何不同。非无意义语义的例子有：维护类不变式或者在内部类型和接口类型之间转换。

##### 实施
标记出多个`get`和`set`成员函数，这些函数只是简单的访问成员而没有额外的语义。

### C.132: 不要无故使使函数为`virtual`
##### 理由
多余的`virtual`增加了运行时开销和对象代码的大小。虚拟函数可以被覆写，因此会在派生类中产生错误。模板层次结构中的虚拟函数会导致代码重复。

##### 示例，不好的
```cpp
template<class T>
class Vector {
public:
    // ...
    virtual int size() const { return sz; }   // 不好的：派生类能做什么？
private:
    T* elem;   // 元素
    int sz;    // 元素个数
};
```
这种“向量”根本不是用作基类的。

##### 实施
* 标记出有虚拟函数但没有派生类的类。
* 标记出所有成员函数都是虚拟而且有实现的类。

### C.133: 避免`protected`数据
##### 理由
`protected`数据是复杂度和错误的来源。`protected`数据使不变式语句复杂化。`protected`数据本质上违反了不要把数据放在基类中的指导，而这通常会导致必须同时处理虚拟继承。

##### 示例，不好的
```cpp
class Shape {
public:
    // ... 接口函数 ...
protected:
    // 在派生类中使用的数据
    Color fill_color;
    Color edge_color;
    Style st;
};
```
现在每个派生的`Shape`都要正确地维护受保护数据。这种做法很受欢迎，但同时也是维护问题的主要来源。在大型的类层次结构中，经常使用受保护数据会难以维护，因为这会让很多代码散布在很多类中。可以接触那些数据的类集合是开放的：任何人都可以派生一个新的类，然后开始操作受保护数据。通常，不可能去检查完整的类集合，所以任何对类的表示的修改会变得不可行。受保护数据没有可保证的不变式；它更像是一系列全局变量。受保护数据实际上成为了庞大代码体中的全局数据。

##### 数据
受保护数据常常看起来很诱人，可以通过派生来进行任意改进。通常，你得到的是无原则的修改和错误。优先使用`private`数据，这些数据具有良好的说明和可保证的不变式。另一个通常更好的方法是，不要在作为接口使用的类中定义数据。

##### 注意
受保护的成员函数是没有问题的。

##### 实施
标记出拥有`protected`数据的类。

### C.134: 保证所有非`const`数据成员有相同的访问级别
##### 理由
防止逻辑上的困惑导致出现错误。如果非`const`数据成员没有相同的访问级别，这个类型试图要做什么是令人困惑的。这个类型维护了一个不变式还是简单地作为值的集合？

##### 讨论
核心的问题是：什么代码负责维护变量有意义的/正确的值？

有两种确切的数据成员：
* A: 不参与对象不变式的成员。这些成员的任何组合值都是有效的。
* B: 参与对象不变式的成员。并非所有组合值都是有意义的（否则就不会存在不变式）。因此所有对这些变量拥有写入访问的代码必须知道它们的不变式，知道它们的语义，以及知道（并且主动实现和保证）保持值正确的规则。

在分类A的数据成员应该只是`public`的（或者，更少见的，如果你只想派生类看到它们，使用`protected`）。它们不需要封装。系统中的所有代码也可以看到和维护它们。

在分类B中的数据成员应该是`private`或者`const`的。这是因为封装是重要的。使它们为非`private`和非`const`意味着对象不能控制它自己的状态：在类之外的无限制数量的代码需要知道不变式的存在并且参与正确地维护它——如果这些数据成员是`public`的，那么这会是所有使用了该对象的调用代码；如果它们是`protected`的，那么这会是所有现在以及将来的派生类的代码。这会导致脆弱和紧耦合的代码，很快会变成维护噩梦。任何不经意把数据成员设置成无效或者意外组合值的代码，会使对象以及所有对该对象的后续使用产生错乱。

大部分类要么都是A或者要么都是B：
* 全部公有：如果你正在写一个聚合的变量捆绑类，在这些变量之间不需要不变式，那么所有变量应该为`public`。为了方便，把这些类声明成`struct`而不是`class`。
* 全部私有：如果你正在写的类型维护了一个不变式，那么所有非`const`变量应该是私有的——它们应该被封装起来。

##### 例外
在个别情况下，类会混合A和B，通常是为了调试的原因。被封装的对象可能会包含一些类似非`const`的调试数据，它不是不变式的一部分因此落入分类A——它真的不是对象值的一部分，或者有意义的可观察状态。在这种情况下，属于A的部分应该当做A来看待（定义成`public`，或者在少数情况下，如果它们应该只对派生类可见，定义成`protected`），而属于B的部分应该仍然当做B来看待（`private`或者`const`）。

##### 实施
标记出任何有非`const`数据成员，而且它们的访问级别不一样的类。

### C.135: 使用多重继承来表示多个不同的接口
##### 理由
并非所有类都有必要支持全部接口，而且不是所有调用者都有必要处理所有操作。特别是将庞大的接口拆分成由指定派生类支持的多个“方面”的行为。

##### 示例
```cpp
class iostream : public istream, public ostream {   // 非常简单
    // ...
};
```
`istream`提供了输入操作的接口；`ostream`提供了输出操作的接口。`iostream`提供了`istream`和`ostream`接口的结合，以及在单个流上允许两种操作的同步需求。

##### 注意
这是继承非常常见的用法，因为多个不同接口和实现的需求很常见，而且这种接口通常不容易或者自然地组织成单个根节点的层次结构。

##### 注意
这些接口通常是抽象类。

##### 实施
???

### C.136: 使用多重继承来表示实现属性的合并
##### 理由
一些形式的混合类型拥有状态，而且通常会在这个状态上进行操作。如果操作是虚拟的，那么继承的使用是必需的，如果不是，那么使用继承可以避免样板和转发。

##### 示例
```cpp
class iostream : public istream, public ostream {   // 非常简单
    // ...
};
```
`istream`为输入操作（和一些数据）提供了接口；`ostream`为输出操作（和一些数据）提供了接口。`iostream`提供了`istream`和`ostream`接口的结合，以及在单个流上允许两种操作的同步需求。

##### 注意
这是一种相对少见的用法，因为实现通常可以组织成一个单个根节点的层次结构。

##### 示例
有时候，“实现属性”更像是一个“混合类型”，它决定了实现的操作，并且注入成员来启用它所需要的策略的实现。例如，参考`std::enable_shared_from_this`或者来自boost.instrusive的不同基类（例如`list_base_hook`或者`instrusive_ref_counter`）。

##### 实施
???

### C.137: 使用`virtual`基类来避免过于通用的基类
##### 理由
允许分开共享的数据和接口。避免所有共享的数据都放进一个终极基类中。

##### 示例
```cpp
struct Interface {
    virtual void f();
    virtual int g();
    // ... 这里没有数据 ...
};

class Utility {  // 有数据
    void utility1();
    virtual void utility2();    // 允许自定义的点
public:
    int x;
    int y;
};

class Derive1 : public Interface, virtual protected Utility {
    // 覆写接口函数
    // 可能覆写Utility的虚拟函数
    // ...
};

class Derive2 : public Interface, virtual protected Utility {
    // 覆写接口函数
    // 可能覆写Utility的虚拟函数
    // ...
};
```
如果许多派生类共享重要的“实现细节”，把`Utility`重构出来是合理的。

##### 注意
显然，这里的例子过于“理论化”，但找到一个小型的真实例子很困难。`Interface`是一个接口层次结构的根节点，而`Utility`是一个实现层次结构的根节点。这里有一个带有解释的稍微更真实的例子。

##### 注意
通常，层次结构的线性化是更好的解决方法。

##### 实施
标记出混合了接口和实现的层次结构。

### C.138: 使用`using`为派生类和它的基类创建重载集合
##### 理由
如果没有使用using声明，在派生类中的成员函数会隐藏掉全部继承下来的重载集合。

##### 示例，不好的
```cpp
#include <iostream>
class B {
public:
    virtual int f(int i) { std::cout << "f(int): "; return i; }
    virtual double f(double d) { std::cout << "f(double): "; return d; }
};
class D: public B {
public:
    int f(int i) override { std::cout << "f(int): "; return i + 1; }
};
int main()
{
    D d;
    std::cout << d.f(2) << '\n';   // 输出 "f(int): 3"
    std::cout << d.f(2.3) << '\n'; // 输出 "f(int): 3"
}
```

##### 示例，好的
```cpp
class D: public B {
public:
    int f(int i) override { std::cout << "f(int): "; return i + 1; }
    using B::f; // 暴露 f(double)
};
```

##### 注意
这个问题同时影响到虚拟和非虚拟成员函数。

对于可变个数的基类，C++17引入了一个using声明的可变个数形式：
```cpp
template <class... Ts>
struct Overloader : Ts... {
    using Ts::operator()...; // 从每个基类暴露 operator()
};
```

##### 实施
诊断名称隐藏。

### C.139: 保守地使用`final`
##### 理由
为了逻辑原因用`final`封锁层次结构是很罕见的需求，并且会损害层次结构的可扩展性。

##### 示例，不好的
```cpp
class Widget { /* ... */ };

// 没有人会想去改善My_widget（或者是你认为的）
class My_widget final : public Widget { /* ... */ };

class My_improved_widget : public My_widget { /* ... */ };  // 错误：不能这样做
```

##### 注意
不是每个类都要成为基类。大多数标准库的类是这方面的例子（例如，`std::vector`和`std::string`并非设计用来派生的）。这个准则是关于在带有虚拟函数的类上使用`final`，这些类是要成为类层次结构中的接口。

##### 注意
用`final`封锁一个单独的虚拟函数是容易出错的，因为在定义/覆写一系列函数的时候，`final`会容易被看漏。幸运的是，编译器会捕捉到这类错误：你不能在派生类中重新声明/重新打开一个`final`成员。

##### 注意
从`final`得到性能提升的说法应该要去证实。这种说法往往基于推测或者其它语言的经验。

有些例子可以说明`final`在逻辑和性能原因上都是重要的。一个例子是，在编译器或者语言分析工具中的一个性能攸关的AST层次结构。新的派生类并不是经常添加，而且只能由库的实现来添加。然而，错误的使用（或者至少）更加常见。

##### 实施
标记出`final`的使用。

### C.140: 不要为虚拟函数和它的覆写函数提供不同的默认参数
##### 理由
这样会导致困惑：覆写函数不能继承默认参数。

##### 示例，不好的
```cpp
class Base {
public:
    virtual int multiply(int value, int factor = 2) = 0;
};

class Derived : public Base {
public:
    int multiply(int value, int factor = 10) override;
};

Derived d;
Base& b = d;

b.multiply(10);  // 这两个调用会调用相同的函数，但是用不同的参数，
d.multiply(10);  // 因此会产生不同的结果。
```

##### 实施
标记出虚拟函数上的默认参数，如果它们在基类和派生类声明中不一样的话。

## C.hier-access: 访问层次结构中的对象
### C.145: 通过指针和引用访问多态对象
##### 理由
如果你有一个带有虚拟函数的类，你（一般）不知道是哪个类提供了要使用的函数。

##### 示例
```cpp
struct B { int a; virtual int f(); };
struct D : B { int b; int f() override; };

void use(B b)
{
    D d;
    B b2 = d;   // 切割
    B b3 = b;
}

void use2()
{
    D d;
    use(d);   // 切割
}
```
两个`d`都被切割了。

##### 例外
你可以在对象的定义范围内安全地访问一个具名的多态对象，而不会导致它被切割。
```cpp
void use3()
{
    D d;
    d.f();   // 没问题
}
```

##### 实施
标记出所有对象切割。

### C.146: 当类层次结构的类型访问不可避免时，使用`dynamic_cast`
##### 理由
`dynamic_cast`是在运行时检查的。

##### 示例
```cpp
struct B {   // 一个接口
    virtual void f();
    virtual void g();
};

struct D : B {   // 一个更大的接口
    void f() override;
    virtual void h();
};

void user(B* pb)
{
    if (D* pd = dynamic_cast<D*>(pb)) {
        // ... 使用D的接口 ...
    }
    else {
        // ... 使用B的接口 ...
    }
}
```
使用其它的转型会违反类型安全，并且会导致程序在访问一个实际类型为`X`的变量时，它会被当作一个不相关的类型`Z`来访问：
```cpp
void user2(B* pb)   // 糟糕的
{
    D* pd = static_cast<D*>(pb);    // 我知道pb实际上指向的是D；相信我
    // ... 使用D的接口 ...
}

void user3(B* pb)    // 不安全
{
    if (some_condition) {
        D* pd = static_cast<D*>(pb);   // 我知道pb实际上指向的是D；相信我
        // ... 使用D的接口 ...
    }
    else {
        // ... 使用B的接口 ...
    }
}

void f()
{
    B b;
    user(&b);   // 没问题
    user2(&b);  // 糟糕的错误
    user3(&b);  // 没问题，*如果*程序员对some_condition的检查是正确的话
}
```

##### 注意
像其它转型一样，`dynamic_cast`被过度使用。应优先使用虚拟函数做转型。应优先使用静态的多态性而不是层次结构浏览，当它是可能的（没必要做运行时解析）并且合理方便的时候。

##### 注意
在使用`typeid`更合适的时候，有些人却会使用`dynamic_cast`；`dynamic_cast`是通用的“是一种”的操作，来发现一个对象上最适合的接口，然而`typeid`是“给我这个对象的准确类型”的操作，来发现一个对象的实际类型。后者是一个从内部来说更简单的操作，因而会更快。后者（`typeid`）在必要时是很容易手工实现的（例如，在一个由于某些原因禁止了RTTI的系统上工作），而前者（`dynamic_cast`）通常更加难以正确地实现。

考虑以下代码：
```cpp
struct B {
    const char* name {"B"};
    // 如果pb1->id() == pb2->id()， *pb1与*pb2有相同的类型
    virtual const char* id() const { return name; }
    // ...
};

struct D : B {
    const char* name {"D"};
    const char* id() const override { return name; }
    // ...
};

void use()
{
    B* pb1 = new B;
    B* pb2 = new D;

    cout << pb1->id(); // "B"
    cout << pb2->id(); // "D"


    if (pb1->id() == "D") {         // 看起来没有坏处
        D* pd = static_cast<D*>(pb1);
        // ...
    }
    // ...
}
```
`pb2->id() == "D"`的结果实际上是由实现定义的。我们把它加入到了home-brew RTTI的危险警告中。这个代码可能符合预期地执行了多年，只在那些不会统一字符字面量的新机器、新编译器、或者新链接器上失败。

如果你要实现你自己的RTTI，要小心。

##### 例外
如果你使用的实现提供了一个确实很慢的`dynamic_cast`，你可能不得不使用变通的方法。然而，所有不能被静态解析的变通方法都要调用显式的转型（通常是`static_cast`），并且是容易出错的。基本上你要制作你自己的特殊目的的`dynamic_cast`。因此，首先要确保你的`dynamic_cast`确实与你认为的一样慢（有相当数量的关于这方面的不被支持的谣言），而且你使用`dynamic_cast`的地方确实是性能攸关的。

我们认为目前`dynamic_cast`的实现是不必要的慢。例如，在适当的条件下，是有可能在快速常量时间内执行一次`dynamic_cast`的。然而，即使所有人都认为进行优化的努力是值得的，但兼容性问题使得这个改变很困难。

在很少见的情况下，如果你已经测量过`dynamic_cast`的开销是重要的，你有其它方法来静态地保证向下转型会成功（例如，你正在小心地使用CRTP），并且没有虚拟继承被调用，可以考虑有策略地使用`static_cast`，同时写上一段显眼的注释和总结这个段落的免责声明，这样在维护的时候人们需要注意，因为类型系统不能保证正确性。即使是这样，在我们的经验中，这种“我知道我在做什么”的情况仍然是已知的缺陷来源。

##### 例外
考虑以下代码：
```cpp
template<typename B>
class Dx : B {
    // ...
};
```

##### 实施
* 标记出所有用`static_cast`的向下转型，包括会执行`static_cast`的C风格转型。
* 这个准则是类型安全性简介的一部分。

### C.147: 当不能找到所需的类视为错误时，在引用类型上使用`dynamic_cast`
##### 理由
在一个你期望得到有效对象的引用表达式上转型，这个转型必须成功。`dynamic_cast`会在不成功的时候抛出异常。

##### 示例
```cpp
???
```

##### 实施
???

### C.148: 当不能找到所需的类视为有效的可选状态时，在指针类型上使用`dynamic_cast`
##### 理由
`dynamic_cast`转换允许检测一个指针是否指向一个在层次结构中指定类的多态对象。由于在找不到类的情况下仅仅返回一个空值，它可以在运行时进行测试。这样可以写出依赖返回值选择分支路径的代码。

与C.147不同的是，它的失败是一个错误，不应该用在条件式执行上。

##### 示例
下面的例子描述了`Shape_owner`的`add`方法，该方法接管了已构造对象`Shape`的所有权。根据它们的几何属性，这些对象也会在不同视图中排序。在这个示例中，`Shape`没有继承于`Geometric_attributes`。只有它的子类会。
```cpp
void add(Shape* const item)
{
  // 所有权总是被接管
  owned_shapes.emplace_back(item);

  // 检查Geometric_attributes，然后把shape添加到零个/一个/几个/全部视图中

  if (auto even = dynamic_cast<Even_sided*>(item))
  {
    view_of_evens.emplace_back(even);
  }

  if (auto trisym = dynamic_cast<Trilaterally_symmetrical*>(item))
  {
    view_of_trisyms.emplace_back(trisym);
  }
}
```

##### 注意
找不到需要的类会导致`dynamic_cast`返回一个空值，而且解引用一个空值的指针会导致未定义行为。因此`dynamic_cast`的结果应该总是认为可能会包含空值，并且要去检查。

##### 实施
* （复杂）除非在指针类型上的`dynamic_cast`已经有对结果进行空值检查，否则对指针上的解引用发出警告。

### C.149: 使用`unique_ptr`或`shared_ptr`来避免忘记用`delete`删除由`new`创建的对象
##### 理由
避免资源泄露。

##### 示例
```cpp
void use(int i)
{
    auto p = new int {7};           // 糟糕：用new初始化局部指针
    auto q = make_unique<int>(9);   // 没问题：保证释放用内存分配的9
    if (0 < i) return;              // 可能在这里返回并导致泄露
    delete p;                       // 太晚了
}
```

##### 实施
* 标记出用`new`的结果初始化的裸露指针。
* 标记出作用在局部变量上的`delete`。

### C.150: 使用`make_unique()`来构造由`unique_ptr`持有的对象
##### 理由
`make_unique`提供了更简洁的构造语句。它也确保了在复杂表达式中的异常安全性。

##### 示例
```cpp
unique_ptr<Foo> p {new<Foo>{7}};   // 没问题：但是重复

auto q = make_unique<Foo>(7);      // 好多了：没有重复Foo

// 不是异常安全的：编译器可能会把参数的计算按以下方式打乱：
//
// 1. 为Foo分配内存，
// 2. 构造Foo，
// 3. 调用bar，
// 4. 构造unique_ptr<Foo>。
//
// 如果bar抛出异常，Foo不会被销毁，为它分配的内存会泄露。
f(unique_ptr<Foo>(new Foo()), bar());

// 异常安全地：调用函数永远不会被打乱。
f(make_unique<Foo>(), bar());
```

##### 实施
* 标记出模板特化列表`<Foo>`的重复使用。
* 标记出声明为`unique_ptr<Foo>`的变量。

### C.151: 使用`make_shared()`来构造由`shared_ptr`持有的对象
##### 理由
`make_shared`提供了更简洁的构造语句。它也提供了一个机会来消除为引用计数的单独分配，通过把`shared_ptr`的使用计数放到它指向的对象旁边来达到这个目的。

##### 示例
```cpp
void test() {
    // 没问题：但是重复；而且Bar和shared_ptr的使用计数是单独分配的
    shared_ptr<Bar> p {new<Bar>{7}};

    auto q = make_shared<Bar>(7);   // 好多了：没有重复Bar；只有一个对象
}
```

##### 实施
* 标记出模板特化列表`<Bar>`的重复使用。
* 标记出声明为`shared_ptr<Bar>`的变量。

### C.152: 永不将指向派生类对象数组的指针赋值给指向其基类的指针
##### 理由
对这样的基类指针执行下标操作会导致无效的对象访问，并且可能导致内存损坏。

##### 示例
```cpp
struct B { int x; };
struct D : B { int y; };

void use(B*);

D a[] = {{1, 2}, {3, 4}, {5, 6}};
B* p = a;     // 糟糕的：衰变成&a[0]，同时转换成B*
p[1].x = 7;   // 覆写了D[0].y

use(a);       // 糟糕的：衰变成&a[0]，同时转换成B*
```

##### 实施
* 标记出所有数组衰变和基类到派生类转换的组合。
* 通过`span`传递数组而不是通过指针，并且在生成`span`之前不要让数组的名称遭受派生类到基类的转换。

### C.153: 优先使用虚拟函数而不是类型转换
##### 理由
虚拟函数的调用是安全地，而类型转换容易出错。虚拟函数调用会到达最底层的派生函数，而类型转换可能会到达一个中间的类，因而会得到错误的结果（特别是在维护的过程中层次结构被修改）。

##### 示例
```cpp
???
```

##### 实施
参阅C.146和???

## C.over: 重载和重载操作符
你可以重载普通函数、模板函数和操作符。你不能重载函数对象。

重载准则概要：
* C.160: 定义操作符来主要地模拟习惯用法
* C.161: 对于对称操作符使用非成员函数
* C.162: 重载严格相等的操作
* C.163: 只重载严格相等的操作
* C.164: 避免使用转换操作符
* C.165: 为自定义的扩展点使用`using`
* C.166: 只重载一元的`&`作为智能指针和引用系统的一部分
* C.167: 以操作符的惯用含义执行操作
* C.168: 在操作数的名称空间中定义重载操作符
* C.170: 如果你想重载lambda，使用泛型lambda

### C.160: 定义操作符来主要地模拟习惯用法
##### 理由
最小化意料之外的事情。

##### 示例
```cpp
class X {
public:
    // ...
    X& operator=(const X&); // 定义为成员函数的赋值
    friend bool operator==(const X&, const X&); // == 需要访问内部表示
                                                // 执行了 a = b 之后我们有 a == b
    // ...
};
```
这里，维持了惯用的语义：拷贝、比较和相等。

##### 示例，糟糕的
```cpp
X operator+(X a, X b) { return a.v - b.v; }   // 糟糕的：使 + 做减法
```

##### 注意
非成员操作符应该是友元，或者定义在与操作数相同的名称空间内。二元操作符应该同等地对待它们的操作数。

##### 实施
大概是不可能的。

### C.161: 对于对称的操作符使用非成员函数
##### 理由
如果你使用了成员函数，你需要两个。除非你为（举例）`==`使用了非成员函数，否则`a == b`和`b == a`会有微妙的差别。

##### 示例
```cpp
bool operator==(Point a, Point b) { return a.x == b.x && a.y == b.y; }
```

##### 实施
标记出成员操作符函数。

### C.162: 重载严格相等的操作
##### 理由
逻辑上相等的操作在不同参数类型上有不同名字是令人困惑的，会导致在函数名称中编码类型信息，而且会妨碍泛型编程。

##### 示例
考虑以下代码：
```cpp
void print(int a);
void print(int a, int base);
void print(const string&);
````
这三个函数都会（合适地）打印出它们的参数。相反：
```cpp
void print_int(int a);
void print_based(int a, int base);
void print_string(const string&);
```
这三个函数都会（合适地）打印出它们的参数。往名称中添加只会引入冗余并且妨碍泛型代码。

##### 实施
???

### C.163: 只重载严格相等的操作
##### 理由
逻辑上不同的函数有相同的名字是令人困惑的，并且在使用泛型编程的时候会导致错误。

##### 示例
考虑以下代码：
```cpp
void open_gate(Gate& g);   // 从车库的出口通道移除障碍
void fopen(const char* name, const char* mode);   // 打开文件
```
这两个操作基本上是不同的（而且也不相关），因此它们的名称不一样是准确的。相反：
```cpp
void open(Gate& g);   // 从车库的出口通道移除障碍
void open(const char* name, const char* mode ="r");   // 打开文件
```
这两个操作基本上仍然是不同的（而且也不相关），但它们的名称缩减到它们（共同）的最少量，敞开了令人困惑的机会。幸运的是，类型系统会捕捉到很多这种错误。

##### 注意
要特别注意通用和常见的名称，例如`open`、`move`、`+`和`==`。

##### 实施
???

### C.164: 避免转换操作符
##### 理由
隐式转换可能是必要的（例如`double`到`int`），但通常会导致意料之外的情况（例如`String`到C风格字符串）。

##### 注意
应优先使用显式的具名转换，直到重要的需求表露出来。“重要的需求”是指在应用程序领域中很基础（例如整数到复数的转换）并且被频繁的需要的原因。不要仅仅为了得到一点便利而引入隐式转换。

##### 示例，不好的
```cpp
class String {   // 处理所有权，以及访问字符序列
    // ...
    String(czstring p); // 从 *p 拷贝到 *(this->elem)
    // ...
    operator zstring() { return elem; }
    // ...
};

void user(zstring p)
{
    if (*p == "") {
        String s {"Trouble ahead!"};
        // ...
        p = s;
    }
    // 使用 p
}
```
分配给`s`并且赋值给`p`的字符串在使用之前就被销毁了。

##### 实施
标记出所有转换操作符。

### C.165: 为自定义的扩展点使用`using`
##### 理由
查找定义在另一个名称空间中的函数对象和函数，来“自定义”一个通用的函数。

##### 示例
考虑`swap`。这是一个通用的（标准库）函数，它被定义成可以作用于任何类型。然而，对于特定的类型，它需要为其定义特定的`swap()`函数。例如，通用的`swap()`会拷贝两个被交换的`vector`中的元素，而一个好的特定实现根本不会拷贝元素。
```cpp
namespace N {
    My_type X { /* ... */ };
    void swap(X&, X&);   // 为N::X的交换进行过优化
    // ...
}

void f1(N::X& a, N::X& b)
{
    std::swap(a, b);   // 很可能不是我们想要的：调用std::swap()
}
```
`f1()`中的`std::swap()`准确地做了我们要求做的事情：它调用了`std`名称空间中的`swap()`。不幸的是，这很可能不是我们想要的。我们该如何让`N::X`被考虑进来呢？
```cpp
void f2(N::X& a, N::X& b)
{
    swap(a, b);   // 调用N::swap
}
```
但这可能不是我们在泛型代码中想要的。在那里，我们通常想在特定函数存在的时候使用它，不存在的时候使用通用函数。通过在函数的查找域中包含通用函数，即可达到这个目的：
```cpp
void f3(N::X& a, N::X& b)
{
    using std::swap;  // 使std::swap可用
    swap(a, b);       // 如果N::swap存在的话调用它，否则调用std::swap
}
```

##### 实施
不太可能，除了已知的自定义扩展点，例如`swap`。这里的问题是未限定的和限定的查找域会同时使用。

### C.166: 只重载一元的`&`作为智能指针和引用系统的一部分
##### 理由
`&`操作符在C++是基本的。C++语义的很多部分会假定它是默认的含义。

##### 示例
```cpp
class Ptr { // 某种智能指针
    Ptr(X* pp) :p(pp) { /* 检查 */ }
    X* operator->() { /* 检查 */ return p; }
    X operator[](int i);
    X operator*();
private:
    T* p;
};

class X {
    Ptr operator&() { return Ptr{this}; }
    // ...
};
```

##### 注意
如果你“搞混”了`&`操作符，要确保它的定义与`->`、`[]`和`.`在结果类型上有匹配的含义。要注意`.`操作符目前不能被重载，所以完美的系统是不可能存在的。我们希望弥补这个问题：http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4477.pdf。要注意`std::addressof()`总是产出一个内置指针。

##### 实施
棘手的。如果`&`是用户定义的，而且没有同时为结果类型定义`->`，发出警告。

### C.167: 以操作符的惯用含义执行操作
##### 理由
可读性。符合习惯。可复用性。支持泛型代码。

##### 示例
```cpp
void cout_my_class(const My_class& c) // 令人困惑的，非习惯用法，非泛型代码
{
    std::cout << /* 类成员在这里 */;
}

std::ostream& operator<<(std::ostream& os, const my_class& c) // 没问题
{
    return os << /* 类成员在这里 */;
}
```
对它自己来说，`count_my_class`是没问题的，但对于那些依赖`<<`作为惯用输出方式的代码，它并非可用/可组合的：
```cpp
My_class var { /* ... */ };
// ...
cout << "var = " << var << '\n';
```

##### 注意
大部分操作符有强烈且有力的惯用含义，例如
* 比较（`==`、`!=`、`<`、`<=`、`>`和`>=`）
* 算术操作（`+`、`-`、`*`、`/`和`%`）
* 访问操作（`.`、`->`、一元`*`和`[]`）
* 赋值（`=`）
不要定义那些不符合习惯的，也不要为它们发明你自己的名称。

##### 实施
棘手的。需要洞察出语义。

### C.168: 在操作数的名称空间中定义重载操作符
##### 理由
可读性。具有使用ADL查找操作符的能力。避免在不同的名称空间中有不一致的定义。

##### 示例
```cpp
struct S { };
bool operator==(S, S);   // 没问题：在与S相同的名称空间中，甚至就在S的旁边
S s;

bool x = (s == s);
```
这是`==`默认要做的，如果我们需要这种默认的话。

##### 示例
```cpp
namespace N {
    struct S { };
    bool operator==(S, S);   // 没问题：在与S相同的名称空间中，甚至就在S的旁边
}

N::S s;

bool x = (s == s);  // 通过ADL找到 N::operator==()
```

##### 示例，不好的
```cpp
struct S { };
S s;

namespace N {
    S::operator!(S a) { return true; }
    S not_s = !s;
}

namespace M {
    S::operator!(S a) { return false; }
    S not_s = !s;
}
```
这里，`!s`的含义在`N`和`M`中不一样。这会非常令人困惑的。移除了`namespace M`的定义后，这个困惑会变成制造错误的机会。

##### 注意
如果一个二元操作符是为两个在不同名称空间中的类型定义的，你不能遵守这个准则。例如：
```cpp
Vec::Vector operator*(const Vec::Vector&, const Mat::Matrix&);
```
这种东西可能最好要避免。

##### 另见
这是“辅助函数应该与它们的类定义在相同名称空间中”的特殊情况。

##### 实施
* 标记出不在操作数所在名称空间中的操作符定义。

### C.170: 如果你想重载lambda，使用泛型lambda
##### 理由
你不能用相同的名称定义两个不同的lambda来进行重载。

##### 示例
```cpp
void f(int);
void f(double);
auto f = [](char);   // 错误：不能重载变量和函数

auto g = [](int) { /* ... */ };
auto g = [](double) { /* ... */ };   // 错误：不能重载变量

auto h = [](auto) { /* ... */ };   // 没问题
```

##### 实施
编译器会捕捉试图重载lambda的错误。

## C.union: 联合体
`union`是一个`struct`，它的所有成员都在同一个地址开始，因此在同一时刻它只能持有一个成员。`union`不会记录保存了哪个成员，所以程序员必须要正确地处理；这是本质上容易出错的，但有方法去弥补。

由一个`union`加上一个指示当前持有的是哪个成员的指示符组成的类型称为标签联合体、可区分联合体或者变体。

联合体准则概要：
* C.180: 使用`union`来节省内存
* C.181: 避免“裸露”的`union`
* C.182: 使用匿名的`union`来实现标签联合体
* C.183: 不要使用`union`作为类型双关语
* ???

### C.180: 使用`union`来节省内存
##### 理由
`union`允许一块内存在不同时刻用于不同类型的对象。因此，当我们有多个从来不会同时使用的对象时，它可以用来节省内存。

##### 示例
```cpp
union Value {
    int x;
    double d;
};

Value v = { 123 };  // 现在v持有一个int
cout << v.x << '\n';    // 写入123
v.d = 987.654;  // 现在v持有一个double
cout << v.d << '\n';    // 写入987.654
```
不过要留意这个警告：避免“裸露”的`union`。

##### 示例
```cpp
// 短字符串优化

constexpr size_t buffer_size = 16; // 稍微比指针的大小大一点

class Immutable_string {
public:
    Immutable_string(const char* str) :
        size(strlen(str))
    {
        if (size < buffer_size)
            strcpy_s(string_buffer, buffer_size, str);
        else {
            string_ptr = new char[size + 1];
            strcpy_s(string_ptr, size + 1, str);
        }
    }

    ~Immutable_string()
    {
        if (size >= buffer_size)
            delete string_ptr;
    }

    const char* get_str() const
    {
        return (size < buffer_size) ? string_buffer : string_ptr;
    }

private:
    // 如果字符串足够短，我们保存字符串本身，而不是保存字符串的指针。
    union {
        char* string_ptr;
        char string_buffer[buffer_size];
    };

    const size_t size;
};
```

##### 实施
???

### C.181: 避免“裸露”的`union`
##### 理由
裸露的联合体没有一个关联的指示符来指示它持有哪个成员（如果有的话），所以程序员必须自己来跟踪。裸露联合体是类型错误的来源。

##### 示例，不好的
```cpp
union Value {
    int x;
    double d;
};

Value v;
v.d = 987.654;  // v持有一个double
```
目前为止没什么问题，但我们会容易误用`union`：
```cpp
cout << v.x << '\n';    // 糟糕，未定义行为：v持有一个double，但我们把它当成int来读取
```
要注意，类型错误发生的时候没有任何显式的转换。当我们测试的时候，程序最后打印的值是`1683627180`，这是`987.654`在位模式下的整型值。在这里我们有一个“不可见”的类型错误，它发生时导致的结果很容易看起来是无害的。

而且，说到“不可见”，下面的代码没有产生输出：
```cpp
v.x = 123;
cout << v.d << '\n';    // 糟糕的：未定义行为
```

##### 替代方案
把`union`与一个类型字段一起包装在一个类中。

即将成为标准的`variant`类型（可以在`<variant>`中找到）为你做了这些事情：
```cpp
variant<int, double> v;
v = 123;        // v持有一个int
int x = get<int>(v);
v = 123.456;    // v持有一个double
w = get<double>(v);
```

##### 实施
???

### C.182: 使用匿名的`union`来实现标签联合体
##### 理由
设计良好的标签联合体是类型安全的。匿名的联合体简化了带有一对（标签，联合体）的类的定义。

##### 示例
这个例子大部分从TC++PL4 pp216-218借用过来。你可以看看那里的说明。

这里的代码有点精妙。处理具有用户定义的赋值和析构函数是棘手的。把程序员从必须写这些代码拯救出来是在标准中包含`variant`的一个原因。
```cpp
class Value { // 把两个可选的内部表示表示为一个联合体
private:
    enum class Tag { number, text };
    Tag type; // 用作区分判断

    union { // 内部表示（注意：匿名联合体）
        int i;
        string s; // string有默认构造函数、拷贝构造函数和析构函数
    };
public:
    struct Bad_entry { }; // 用于异常

    ~Value();
    Value& operator=(const Value&);   // 必需的，因为有string变量
    Value(const Value&);
    // ...
    int number() const;
    string text() const;

    void set_number(int n);
    void set_text(const string&);
    // ...
};

int Value::number() const
{
    if (type != Tag::number) throw Bad_entry{};
    return i;
}

string Value::text() const
{
    if (type != Tag::text) throw Bad_entry{};
    return s;
}

void Value::set_number(int n)
{
    if (type == Tag::text) {
        s.~string();      // 显式销毁string
        type = Tag::number;
    }
    i = n;
}

void Value::set_text(const string& ss)
{
    if (type == Tag::text)
        s = ss;
    else {
        new(&s) string{ss};   // placement new：显式构造string
        type = Tag::text;
    }
}

Value& Value::operator=(const Value& e)   // 必需的，因为有string变量
{
    if (type == Tag::text && e.type == Tag::text) {
        s = e.s;    // 普通的字符串赋值
        return *this;
    }

    if (type == Tag::text) s.~string(); // 显式销毁

    switch (e.type) {
    case Tag::number:
        i = e.i;
        break;
    case Tag::text:
        new(&s)(e.s);   // placement new：显式构造
        type = e.type;
    }

    return *this;
}

Value::~Value()
{
    if (type == Tag::text) s.~string(); // 显式销毁
}
```

##### 实施
???

### C.183: 不要使用`union`作为类型双关语
##### 理由
以不同的类型分别读取和写入`union`成员是未定义行为。这种双关语是不可见的，或者至少比使用具名的转换更难发现。使用`union`作为类型双关语是错误的来源。

##### 示例，不好的
```cpp
union Pun {
    int x;
    unsigned char c[sizeof(int)];
};
```
`Pun`的意图是能够查看一个`int`的字符表示。
```cpp
void bad(Pun& u)
{
    u.x = 'x';
    cout << u.c[0] << '\n';     // 未定义行为
}
```
如果你想看看`int`的字节，使用（具名的）转换：
```cpp
void if_you_must_pun(int& x)
{
    auto p = reinterpret_cast<unsigned char*>(&x);
    cout << p[0] << '\n';     // 没问题；好多了
    // ...
}
```
使用`reinterpret_cast`将对象转换成与其声明类型不同的类型，并且访问它的结果是已定义的行为（即使不鼓励使用`reinterpret_cast`），但是至少我们可以看到一些诡异的事情在发生。

##### 注意
不幸的是，`union`通常用做类型双关语。我们不认为“有时候它会如预期执行”是一个强力的论据。

C++17引入了一个不同的类型`std:byte`来促进在原始对象表示上的操作。为这些操作使用该类型来代替`unsigned char`或`char`。

##### 实施
???

## Enum: 枚举
枚举用于定义整型数值的集合，同时为这些值的集合定义类型。枚举有两种类型，“纯”`enum`和`class enum`。

枚举准则概要：
* Enum.1: 优先使用枚举而不是宏
* Enum.2: 使用枚举来表示相关的具名常量集合
* Enum.3: 优先使用`enum class`而不是“纯”`enum`
* Enum.4: 为了安全和简易使用，在枚举上定义操作
* Enum.5: 不要为枚举值使用`ALL_CAPS`名称
* Enum.6: 避免没有名称的枚举
* Enum.7: 只在必要的时候指定枚举的基础类型
* Enum.8: 只在必要的时候指定枚举值

### Enum.1: 优先使用枚举而不是宏
##### 理由
宏不遵守作用域和类型规则。而且，宏的名称在预处理期间会被移除，所以通常不会在比如调试器的工具中出现。

##### 示例
首先是一些糟糕的旧代码：
```cpp
// webcolors.h (第三方头文件)
#define RED   0xFF0000
#define GREEN 0x00FF00
#define BLUE  0x0000FF

// productinfo.h
// 下面基于颜色定义了产品的子类型
#define RED    0
#define PURPLE 1
#define BLUE   2

int webby = BLUE;   // webby == 2；可能不是预期的结果
```
使用`enum`来代替：
```cpp
enum class Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF };
enum class Product_info { red = 0, purple = 1, blue = 2 };

int webby = blue;   // 错误：要具体指定
Web_color webby = Web_color::blue;
```
我们使用`enum class`来避免名称冲突。

##### 实施
标记出定义了整型数值的宏。

### Enum.2: 使用枚举来表示相关的具名常量集合
##### 理由
枚举展示了有关联、并且可以成为具名类型的枚举值。

##### 示例
```cpp
enum class Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF };
```

##### 注意
把枚举用在`switch`语句中是很常见的，而且编译器会对不寻常的`case`标签模式发出警告。例如：
```cpp
enum class Product_info { red = 0, purple = 1, blue = 2 };

void print(Product_info inf)
{
    switch (inf) {
    case Product_info::red: cout << "red"; break;
    case Product_info::purple: cout << "purple"; break;
    }
}
```
这种缺少一个标签的`switch`语句往往是添加了枚举值并且没有充分测试的结果。

##### 实施
* 标记出在`case`中覆盖了一个枚举大部分但不是全部枚举值的`switch`语句。
* 标记出在`case`中覆盖了一个枚举少量枚举值，但是没有`default`的`switch`语句。

### Enum.3: 优先使用`enum class`而不是“纯”`enum`
##### 理由
最小化意外情况：传统的枚举太容易转换成整型。

##### 示例
```cpp
void Print_color(int color);

enum Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF };
enum Product_info { Red = 0, Purple = 1, Blue = 2 };

Web_color webby = Web_color::blue;

// 显然，这些调用中至少有一个存在问题。
Print_color(webby);
Print_color(Product_info::Blue);
```
使用`enum class`来代替：
```cpp
void Print_color(int color);

enum class Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF };
enum class Product_info { red = 0, purple = 1, blue = 2 };

Web_color webby = Web_color::blue;
Print_color(webby);  // 错误：不能将Web_color转换成int。
Print_color(Product_info::Red);  // 错误：不能将Product_info转换成int。
```

##### 实施
（简单）对任何非`enum class`定义发出警告。

### Enum.4: 为了安全和简易使用，在枚举上定义操作
##### 理由
便于使用，以及避免错误。

##### 示例
```cpp
enum Day { mon, tue, wed, thu, fri, sat, sun };

Day& operator++(Day& d)
{
    return d = (d == Day::sun) ? Day::mon : static_cast<Day>(static_cast<int>(d)+1);
}

Day today = Day::sat;
Day tomorrow = ++today;
```
使用`static_cast`并不好，但像下面那样：
```cpp
Day& operator++(Day& d)
{
    return d = (d == Day::sun) ? Day::mon : Day{++d};    // 错误
}
```
会是无穷的递归，而且假如不用转换，而是在所有分支上使用`switch`则太过冗长。

##### 实施
标记出把数值转换回枚举的重复表达式。

### Enum.5: 不要为枚举值使用`ALL_CAPS`名称
##### 理由
避免与宏冲突。

##### 示例，不好的
```cpp
 // webcolors.h（第三方头文件）
#define RED   0xFF0000
#define GREEN 0x00FF00
#define BLUE  0x0000FF

// productinfo.h
// 下面基于颜色定义产品的子类型
enum class Product_info { RED, PURPLE, BLUE };   // 语法错误
```

##### 实施
标记出所有带有`ALL_CAPS`名称的枚举。

### Enum.6: 避免没有名称的枚举
##### 理由
如果你不能为枚举命名，那么它的值是不相关的。

##### 示例，不好的
```cpp
enum { red = 0xFF0000, scale = 4, is_signed = 1 };
```
在有更方便的替代方法来指定整型常量之前，这种代码并不罕见。

##### 替代方法
使用`constexpr`值来代替。例如：
```cpp
constexpr int red = 0xFF0000;
constexpr short scale = 4;
constexpr bool is_signed = true;
```

##### 实施
标记出没有名称的枚举。

### Enum.7: 只在必要的时候指定枚举的基础类型
##### 理由
默认方式是最容易读和写的。`int`是默认的整型类型。`int`与C的`enum`兼容。

##### 示例
```cpp
enum class Direction : char { n, s, e, w,
                              ne, nw, se, sw };  // 指定基础类型来节省空间

enum class Web_color : int { red   = 0xFF0000,
                             green = 0x00FF00,
                             blue  = 0x0000FF };  // 指定基础类型是冗余的
```

##### 注意
在前置声明枚举的时候，指定基础类型是必要的：
```cpp
enum Flags : char;

void f(Flags);

// ....

enum flags : char { /* ... */ };
```

##### 实施
???

### Enum.8: 只在必要的时候指定枚举值
##### 理由
这是最简单的。它避免了重复的枚举值。默认的做法提供了连续值的集合，对`switch`语句的实现有好处。

##### 示例
```cpp
enum class Col1 { red, yellow, blue };
enum class Col2 { red = 1, yellow = 2, blue = 2 }; // 输入错误
enum class Month { jan = 1, feb, mar, apr, may, jun,
                   jul, august, sep, oct, nov, dec }; // 从1开始连续的
enum class Base_flag { dec = 1, oct = dec << 1, hex = dec << 2 }; // 位的集合
```
为了匹配惯用的值（例如`Month`），并且不希望使用连续值的时候（例如，像`Base_flag`那样获定义单独的位），指定枚举值是必要的。

##### 实施
* 标记出重复的枚举值。
* 标记出显式指定了所有连续值的枚举值。

## R: 资源管理
这部分包含与资源相关的准则。资源是任何必须获取以及（显式或隐式）释放的东西，例如内存、文件句柄、套接字和锁。资源必须释放的原因通常是由于它是短缺的，因此即便是延迟释放也会带来损害。这里基本的目标是要保证我们不会泄露任何资源，以及我们持有资源的时间不会比我们真正需要的长。负责释放资源的实体称为所有者。

有些情况下，泄露是可接受的，甚至是一种优化：如果你正在写一个程序，它单纯地基于输入来产生输出，而且所需的内存与输入的大小是成比例的，在这种情况下，优化策略（为了性能以及编程的便利）有时会简单地不删除任何东西。如果你有足够的内存来处理最大的输入，那就让它泄露，但要确保如果你做错了的话，会给出良好的错误信息。在这里，我们忽略这类情况。

* 资源管理准则概要：
	* R.1: 使用资源句柄和RAII（资源获取即初始化）自动地管理资源
	* R.2: 在接口中，（只）使用原始指针来指示单独的对象
	* R.3: 原始指针（`T*`）不具有所有权
	* R.4: 原始引用（`T&`）不具有所有权
	* R.5: 优先使用作用域对象，避免不必要的堆分配
	* R.6: 避免非`const`全局变量
* 分配的释放准则概要：
	* R.10: 避免`malloc()`和`free()`
	* R.11: 避免显式地调用`new`和`delete`
	* R.12: 立即把显式资源分配的结果赋予管理对象
	* R.13: 在单个表达式语句中至多执行一次显式资源分配
	* R.14: ??? 数组与指针参数
	* R.15: 总是重载配对的分配/释放
* 智能指针准则概要：
	* R.20: 使用`unique_ptr`或`shared_ptr`来表示所有权
	* R.21: 优先使用`unique_ptr`而不是`shared_ptr`，除非你需要共享所有权
	* R.22: 使用`make_shared()`来生成`shared_ptr`
	* R.23: 使用`make_unique()`来生成`unique_ptr`
	* R.24: 使用`std::weak_ptr`来破除`shared_ptr`的循环
	* R.30: 只有在显式表达生命周期语义的时候才使用智能指针作为参数
	* R.31: 如果你有不属于`std`的智能指针，遵守`std`中的基本模式
	* R.32: 使用`unique_ptr<widget>`作为参数，来表示函数要获取`widget`的所有权
	* R.33: 使用`unique_ptr<widget>&`作为参数，来表示函数要重设`widget`
	* R.34: 使用`shared_ptr<widget>`作为参数，来表示函数是部分所有者
	* R.35: 使用`shared_ptr<widget>&`作为参数，来表示函数可能会重设共享的指针
	* R.36: 使用`const shared_ptr<widget>&`作为参数，来表示函数可能会持有对象的引用计数???
	* R.37: 不要传递从别名智能指针获取的指针或引用

### R.1: 使用资源句柄和RAII（资源获取即初始化）自动地管理资源
##### 理由
避免泄露和手动管理资源的复杂性。C++语言保证执行的构造函数/析构函数的对称性与资源的获取/释放函数的对称性吻合，例如`fopen`/`fclose`、`lock`/`unlock`和`new`/`delete`。不论何时，当你要处理那些需要配对的获取/释放函数调用的资源时，把资源封装到对象中，让它为你确保执行了配对的函数——在它的构造函数中获取资源，然后在它的析构函数中释放资源。

##### 示例，不好的
考虑以下代码：
```cpp
void send(X* x, cstring_span destination)
{
    auto port = open_port(destination);
    my_mutex.lock();
    // ...
    send(port, x);
    // ...
    my_mutex.unlock();
    close_port(port);
    delete x;
}
```
在这里的代码中，你必须记住在所有路径上调用`unlock`、`close_port`和`delete`，而且每个函数只调用一次。另外，如果标记为`...`中的任意代码抛出了异常，那么`x`会被泄露，`my_mutex`会维持上锁状态。

##### 示例
考虑以下代码：
```cpp
void send(unique_ptr<X> x, cstring_span destination)  // x拥有X
{
    Port port{destination};            // port拥有PortHandle
    lock_guard<mutex> guard{my_mutex}; // guard拥有锁
    // ...
    send(port, x);
    // ...
} // 自动解锁my_mutex和删除x的指针
```
现在所有资源的清理都是自动的，在所有路径上都只执行一次，不管有没有发生异常。作为额外的好处，该函数现在声明了它会接管指针的所有权。

`Port`是什么？它是封装了资源的一个便利的包装类：
```cpp
class Port {
    PortHandle port;
public:
    Port(cstring_span destination) : port{open_port(destination)} { }
    ~Port() { close_port(port); }
    operator PortHandle() { return port; }

    // 端口句柄一般不能克隆，因此如果有必要的话禁用拷贝和赋值
    Port(const Port&) = delete;
    Port& operator=(const Port&) = delete;
};
```

##### 注意
当一个“表现不正常”的资源没有表示成具有析构函数的类时，把它包装到一个类中或者使用`finally`。

*另见*：RAII

### R.2: 在接口中，（只）使用原始指针来指示单独的对象
##### 理由
数组最好通过容器类型（例如`vector`（有所有权））或者`span`（无所有权）来表示。这类容器和视图持有足够的信息来做范围检查。

##### 示例，不好的
```cpp
void f(int* p, int n)   // n是p[]中元素的数量
{
    // ...
    p[2] = 7;   // 不好的：对原始指针取下标
    // ...
}
```
编译器不会阅读注释，而且没有阅读其它代码的话，你不知道`p`是否真的指向`n`个元素。应使用`span`来代替。

##### 示例
```cpp
void g(int* p, int fmt)   // 使用#fmt的格式打印*p
{
    // ... 只使用*p和p[0] ...
}
```

##### 例外
C风格的字符串用单个指向以零结尾的字符序列的指针来传递。使用`zstring`而不是`char*`来指示你依赖于这个约定。

##### 注意
目前许多指向单个元素的指针用法可以使用引用。然而，当`nullptr`是可能的取值时，引用也许不是合理的选择。

##### 实施
* 标记出作用于指针上的指针算术（包括`++`），该指针不是容器、视图或者迭代器的一部分。如果应用于老的代码库，该准则会生成大量错误。
* 标记出以单个指针传递的数组名称。

### R.3: 原始指针（`T*`）不具有所有权
##### 理由
（在C++标准或者在大部分代码中）不存在与这个说法不同的东西，而且大部分原始指针都是不拥有资源的。我们希望拥有资源的指针能够被辨识出来，因而我们可以可靠且有效地删除被所有者指针指向的对象。

##### 示例
```cpp
void f()
{
    int* p1 = new int{7};           // 不好的：原始的所有者指针
    auto p2 = make_unique<int>(7);  // 好的：int由唯一的指针所拥有
    // ...
}
```
`unique_ptr`通过保证对象的删除来防止泄露（即使在发生了异常的情况下）。而`T*`不能。

##### 示例
```cpp
template<typename T>
class X {
    // ...
public:
    T* p;   // 不好的：p是否具有所有权是不清晰的
    T* q;   // 不好的：q是否具有所有权是不清晰的
};
```
我们可以通过显式指定所有权来修复这个问题：
```cpp
template<typename T>
class X2 {
    // ...
public:
    owner<T*> p;  // 没问题：p具有所有权
    T* q;         // 没问题：q不具有所有权
};
```

##### 例外
一个主要的例外类别是遗留代码，特别是必须与C维持兼容的代码，或者通过ABI在C和C风格的C++之间维持兼容接口的代码。事实上，有数十亿行的代码违反了该准则关于`T*`的所有权，这些代码不能被忽略。我们喜于看到程序转换工具把20年历史的“遗留”代码转换成焕然一新的现代代码， 我们鼓励开发、部署以及使用这类工具，我们希望这些指南能帮助这类工具的开发，我们甚至收到在这个领域研究和开发的贡献（同时也主动贡献）。然而，这会消耗时间：“遗留代码”产生的速度快于我们翻新旧代码的速度，因此这将需要好几年时间。

这些代码不能全部重写（即使是假设在有好的代码转换软件的情况下），尤其是不能快速地重写。这个问题不能通过把全部所有者指针转换成`unique_ptr`和`shared_ptr`来（成规模地）解决，部分是因为在我们基础的资源句柄的实现中需要/使用具有所有权的“原始指针”以及简单指针。例如，常见的`vector`实现有一个具有所有权的指针和两个无所有权的指针。许多ABI（基本上所有针对C代码的接口）都使用`T*`，有些是具有所有权的。有些接口不能简单地用`owner`作标记，因为它们需要维持与C的兼容（虽然这里可以使用宏来实现，它只在C++模式下展开成`owner`。这种正确使用宏的场景是罕见的）。

##### 注意
`owner<T*>`没有超出`T*`的默认语义。使用它不需要修改任何代码，也不会影响ABI。它只是给程序员和分析工具的指示器。例如，如果`owner<T*>`是类的成员，那个类最好有析构函数来用`delete`删除它。

##### 示例，不好的
返回一个（原始）指针给调用者强加了不确定的生命周期管理；也就是说，应该由谁来删除被指向的对象？
```cpp
Gadget* make_gadget(int n)
{
    auto p = new Gadget{n};
    // ...
    return p;
}

void caller(int n)
{
    auto p = make_gadget(n);   // 记得删除p
    // ...
    delete p;
}
```
除了会遇到泄露的问题外，这也增加了无谓的分配和释放操作，而且是不必要地啰嗦。如果Gadget从函数中移动出来是廉价的（例如它很小型或者有一个高效的移动操作），那么只要以“值”返回它就行了（参阅“输出”返回值）：
```cpp
Gadget make_gadget(int n)
{
    Gadget g{n};
    // ...
    return g;
}
```

##### 注意
这个准则适用于工厂函数。

##### 注意
如果需要指针语义（例如，由于返回类型需要指向类层次结构中的基类（一个接口）），那么返回一个“智能指针”。

##### 实施
* （简单）对作用于不是`owner<T>`的原始指针上的`delete`发出警告。
* （中等）对于没有在每个代码路径上调用`reset`或者显式用`delete`删除`owner<T>`指针的情况发出警告。
* （简单）如果`new`的返回值赋值给原始指针，发出警告。
* （简单）如果一个函数返回的对象是在函数内分配的，而且有移动构造函数，发出警告。建议考虑以值返回它来代替。

### R.4: 原始引用（`T&`）不具有所有权
##### 理由
（在C++标准或者在大部分代码中）不存在与这个说法不同的东西，而且大部分原始引用都是不具有所有权的。我们希望所有者能够被辨识出来，因而我们可以可靠且有效地删除被所有者指针指向的对象。

##### 示例
```cpp
void f()
{
    int& r = *new int{7};  // 不好的：原始的具有所有权的引用
    // ...
    delete &r;             // 不好的：违反了删除原始指针的准则
}
```
*另见*：原始指针准则

##### 实施
参阅原始指针准则。

### R.5: 优先使用作用域对象，避免不必要的堆分配
##### 理由
作用域对象是局部对象、全局对象或者成员。这意味着除了用于包含它的作用域或对象的成本之外，没有单独的分配和释放开销。作用域对象的成员自身也是在作用域中的，而且作用域对象的构造函数和析构函数管理成员的生命周期。

##### 示例
下面的例子是低效的（因为它有不必要的分配和释放），极容易受到在`...`部分中抛出异常和返回（导致泄露），而且是啰嗦的：
```cpp
void f(int n)
{
    auto p = new Gadget{n};
    // ...
    delete p;
}
```
相反，应使用局部变量：
```cpp
void f(int n)
{
    Gadget g{n};
    // ...
}
```

##### 实施
* （中等）如果一个对象在函数的所有路径中分配然后又释放，发出警告。建议应该把它定义成局部的`auto`栈对象来代替。
* （简单）如果一个局部的`unique_ptr`或者`shared_ptr`在它的生命周期结束之前没有被移动、拷贝、重新赋值或者调用`reset`，发出警告。

### R.6: 避免非`const`全局变量
##### 理由
全局变量可以在任何地方访问，因此它们会在明显无关的对象之间引入意料之外的依赖。它们是著名的错误源头。

*警告*：全局对象的初始化不是完全有序的。如果你使用了全局对象，要用常量来初始化它。要注意，即使对于`const`对象，也有可能出现未定义的初始化顺序。

##### 例外
全局对象通常比单例更好。

##### 例外
一个不可变（`const`）的全局变量不会引入我们尝试通过禁用全局对象避免的问题。

##### 实施
（??? NM: 显然我们可以对非`const`的静态变量进行警告……我们想要这样做吗？）

## R.alloc: 分配和释放
### R.10: 避免`malloc()`和`free()`
##### 理由
`malloc()`和`free()`不支持构造函数和析构函数，也不能很好地与`new`和`delete`混合使用。

##### 示例
```cpp
class Record {
    int id;
    string name;
    // ...
};

void use()
{
    // p1可能为nullptr
    // *p1没有被初始化；特别是，它的string不是一个string，而是一个
    // 与string同等大小的位结构
    Record* p1 = static_cast<Record*>(malloc(sizeof(Record)));

    auto p2 = new Record;

    // 除非抛出了异常，*p2是经过默认初始化的
    auto p3 = new(nothrow) Record;
    // p3可能为nullptr；否则，*p3是经过默认初始化的

    // ...

    delete p1;    // 错误：不能用delete删除由malloc()分配的对象
    free(p2);    // 错误：不能用free()释放由new分配的对象
}
```
在一些实现中，上面的`delete`和`free()`也许能执行，否则可能他们会导致运行时错误。

##### 例外
在有些程序和部分代码中，异常是不可接受的。一些这类最好的例子是在生命攸关的硬实时代码中。要注意许多禁止使用异常的情况是基于迷信（很糟糕），或者担心存在杂乱资源管理的旧代码库（很不幸，但有时这是必要的）。在这种情况下，考虑使用带`nothrow`版本的`new`。

##### 实施
标记出显式使用的`malloc`和`free`。

### R.11: 避免显式的调用`new`和`delete`
##### 理由
`new`返回的指针应该属于资源句柄（它可以调用`delete`）。如果`new`返回的指针被赋值给纯的/裸露的指针，该对象可能会泄露。

##### 注意
在大型程序中，裸露的`delete`（即应用代码中的`delete`，而不是用于资源管理代码中的）很可能是缺陷：如果你有N个`delete`，你如何确定你不需要N+1或者N-1个呢？这个缺陷可能是潜在的：它可能只会在维护期间出现。如果你有一个裸露的`new`，你可能在其它地方需要一个裸露的`delete`，因此你可能有一个缺陷。

##### 实施
（简单）对任何显式使用的`new`和`delete`发出警告。建议使用`make_unique`来代替。

### R.12: 立即把显式资源分配的结果赋予管理对象
##### 理由
如果你不这样做，异常或者返回会导致泄露。

##### 示例，不好的
```cpp
void f(const string& name)
{
    FILE* f = fopen(name, "r");            // 打开文件
    vector<char> buf(1024);
    auto _ = finally([f] { fclose(f); });  // 记得关闭文件
    // ...
}
```
`buf`的分配可能会失败，导致泄露了文件句柄。

##### 示例
```cpp
void f(const string& name)
{
    ifstream f{name};   // 打开文件
    vector<char> buf(1024);
    // ...
}
```
（在`ifstream`中）对文件句柄的使用是简单、高效而且安全的。

##### 实施
* 标记出用来初始化指针的显式分配（问题：我们能够识别多少直接的资源分配？）。

### R.13: 在单个表达式语句中至多执行一次显式资源分配
##### 理由
如果你在一个语句中执行了两次显式资源分配，你可能会泄露资源，因为许多子表达式，包括函数参数的求值顺序是不确定的。

##### 示例
```cpp
void fun(shared_ptr<Widget> sp1, shared_ptr<Widget> sp2);
```
这个`fun`函数可能会被这样调用：
```cpp
// 糟糕的：潜在的泄露
fun(shared_ptr<Widget>(new Widget(a, b)), shared_ptr<Widget>(new Widget(c, d)));
```
这是异常不安全地，因为编译器可能会对创建函数两个参数的表达式重新排序。特别是，编译器会交叉执行两个表达式：两个对象的内存分配（通过调用`operator new`）可能会首先执行，接着会调用两个`Widget`的构造函数。如果其中一个构造函数抛出了异常，那么另一个对象的内存永远不会释放！

这个微妙的问题有简单的解决方法：永远不要在单个表达式语句中执行多于一次的显式资源分配。例如：
```cpp
shared_ptr<Widget> sp1(new Widget(a, b)); // 好多了，但有点杂乱
fun(sp1, new Widget(c, d));
```
最好的解决方法是使用返回具有所有权对象的工厂函数来完全避免显式分配：
```cpp
fun(make_shared<Widget>(a, b), make_shared<Widget>(c, d)); // 最好的
```
如果没有这样的工厂包裹函数，那么写一个你自己的。

##### 实施
* 标记出有多个显式资源分配的表达式（问题：我们可以识别多少直接的资源分配？）。

### R.14: ??? 数组与指针参数
##### 理由
数组会衰变成指针，因而丢失了它的大小，为范围错误敞开了机会。

##### 示例
```cpp
??? 我们建议使用哪种：f(int*[]) 还是 f(int**) ???
```

*替代方案*：使用`span`来保留大小信息。

##### 实施
标记出`[]`参数。

### R.15: 总是重载配对的分配/释放
##### 理由
否则你会遇到不匹配的操作和混乱。

##### 示例
```cpp
class X {
    // ...
    void* operator new(size_t s);
    void operator delete(void*);
    // ...
};
```

##### 注意
如果你想要不能被释放的内存，用`=delete`删除释放操作。不要让它未声明。

##### 实施
标记出不完整的配对。

## R.smart: 智能指针

### R.20: 使用`unique_ptr`或`shared_ptr`来表示所有权

##### 理由

它们可以防止资源泄露。

##### 示例

考虑以下代码：

```cpp
void f()
{
    X x;
    X* p1 { new X };              // 参阅：???
    unique_ptr<T> p2 { new X };   // 唯一的所有权；参阅???
    shared_ptr<T> p3 { new X };   // 共享的所有权；参阅???
    auto p4 = make_unique<X>();   // 唯一的所有权，比显式使用“new”更好
    auto p5 = make_shared<X>();   // 共享的所有权，比显式使用“new”更好
}
```

这里（只）会泄露用来初始化`p1`的对象。

##### 实施

（简单）如果`new`的返回值或者返回值为指针类型的函数调用被赋值给原始指针，发出警告。

### R.21: 优先使用`unique_ptr`而不是`shared_ptr`，除非你需要共享所有权

##### 理由

`unique_ptr`在概念上更简单，更可预见（你知道什么时候发生析构），以及更快（你不用隐式地维护使用计数）。

##### 示例，不好的

这里不必要地添加和维护了一个引用计数。

```cpp
void f()
{
    shared_ptr<Base> base = make_shared<Derived>();
    // 局部地使用base，没有拷贝它——引用计数永远不会超过1
} // 销毁base
```

##### 示例

这样会更加高效：

```cpp
void f()
{
    unique_ptr<Base> base = make_unique<Derived>();
    // 局部地使用base
} // 销毁base
```

##### 实施

（简单）如果一个函数将`shared_ptr`与一个在函数内分配的对象一起使用，但永远不会返回这个`shared_ptr`，或者把它传递给需要`shared_ptr&`的函数，那么发出警告。建议使用`unique_ptr`来代替。

### R.22: 使用`make_shared()`来生成`shared_ptr`

##### 理由

如果你先创建一个对象然后把它传给`shared_ptr`的构造函数，比起使用`make_shared()`，你（很可能）会执行了一次额外的分配（以及稍后的释放），因为引用计数必须在对象之外另外分配。

##### 示例

考虑以下代码：

```cpp
shared_ptr<X> p1 { new X{2} }; // 不好
auto p = make_shared<X>(2);    // 好
```

`make_shared()`版本只需提及`X`一次，所以比起用显式`new`的版本它通常更短（也更快）。

##### 实施

（简单）如果`shared_ptr`由`new`的结果而不是`make_shared`来构造，发出警告。

### R.23: 使用`make_unique()`来生成`unique_ptr`

##### 理由

为了方便，以及与`shared_ptr`保持一致。

##### 注意

`make_unique()`是在C++14中的，但普遍都可以使用（同时也容易自己写出来）。

##### 实施

（简单）如果`unique_ptr`由`new`的结果而不是`make_unique`来构造，发出警告。

### R.24: 使用`std::weak_ptr`来破除`shared_ptr`的循环

##### 理由

`shared_ptr`依赖使用计数，而在环形结构中使用计数永远不会降到0，因此我们需要一个机制来打破环形结构。

##### 示例

```cpp
#include <memory>

class bar;

class foo
{
public:
    explicit foo(const std::shared_ptr<bar>& forward_reference)
    : forward_reference_(forward_reference)
    { }
private:
    std::shared_ptr<bar> forward_reference_;
};

class bar
{
public:
    explicit bar(const std::weak_ptr<foo>& back_reference)
    : back_reference_(back_reference)
    { }
    void do_something()
    {
    if (auto shared_back_reference = back_reference_.lock()) {
        // 使用 *shared_back_reference
    }
    }
private:
    std::weak_ptr<foo> back_reference_;
};
```

##### 注意

???（HS：很多人说“要打破循环”，但我认为“临时的共享所有权”更关键）
???（BS：打破循环是你必须要做的事情；临时地共享所有权是你如何去做这个事情）
你可以通过简单地使用另一个`shared_ptr`来“临时地共享所有权”。

##### 实施

??? 也许是不可能的。如果我们可以静态地检测出循环，我们就不需要`weak_ptr`。

### R.30: 只有在显式表达生命周期语义的时候才使用智能指针作为参数

##### 理由

如果函数只需要`widget`本身，那么它接受一个`widget`的智能指针是错误的。它应该能够接受任意`widget`对象，不仅仅是那些由特定智能指针管理生命周期的对象。不需要维护生命周期的函数应该使用原始指针或者引用来代替。

##### 示例，不好的

```cpp
// 被调用者
void f(shared_ptr<widget>& w)
{
    // ...
    use(*w); // 只使用了w——生命周期根本没有使用
    // ...
};

// 调用者
shared_ptr<widget> my_widget = /* ... */;
f(my_widget);

widget stack_widget;
f(stack_widget); // 出错
```

##### 示例，好的

```cpp
// 被调用者
void f(widget& w)
{
    // ...
    use(w);
    // ...
};

// 调用者
shared_ptr<widget> my_widget = /* ... */;
f(*my_widget);

widget stack_widget;
f(stack_widget); // 没问题——现在正常了
```

##### 实施

* （简单）如果一个函数接受智能指针类型（重载了`operator->`或者`operator*`的类型）作为参数，该类型是可拷贝的，但函数只调用了`operator*`、`operator->`或`get()`中的一个，那么发出警告。建议使用`T*`或`T&`来代替。
* 标记出这样的智能指针类型参数（重载了`operator->`或者`operator*`的类型）：它可拷贝/可移动，但从来不在函数体中拷贝/移动，而且从来不被修改，也不会被传递给其它会这样做的函数。这意味着所有权语义没有使用。建议使用`T*`或`T&`来代替。

### R.31: 如果你有不属于`std`的智能指针，遵守`std`中的基本模式

##### 理由

下面的规则同样适用于任何类型的的第三方和自定义智能指针，而且对诊断那些常见的导致性能和正确性问题的智能指针错误很有用。你会希望这些规则适用于你使用的所有智能指针上。

任何类型（包括主模板或者特化类型）如果重载了一元的`*`和`->`，就会认为是一个智能指针：

* 如果它是可拷贝的，它会被当作基于引用计数的`shared_ptr`。
* 如果它不可拷贝，它会被当作唯一的`unique_ptr`。

##### 示例

```cpp
// 使用Boost的intrusive_ptr
#include <boost/intrusive_ptr.hpp>
void f(boost::intrusive_ptr<widget> p)  // 在“shared_ptr参数”的准则下是错误的
{
    p->foo();
}

// 使用Microsoft的CComPtr
#include <atlbase.h>
void f(CComPtr<widget> p)               // 在“shared_ptr参数”的准则下是错误的
{
    p->foo();
}
```

这两个例子在“shared_ptr参数”准则下都是错误的：`p`是一个`shared_ptr`，但它的共享特性没有在这里使用，而且按值来传递它是隐含的劣化；这些函数应该只在它们需要参与`widget`的生命周期管理时才接受智能指针。否则，它们应该接受`widget*`，如果参数可以为`nullptr`的话。否则，更理想的是，这些函数应该接受`widget&`。这些智能指针符合`shared_ptr`的概念，因此相关指南的实施规则可以立即应用于这些智能指针上，同时可以暴露出这些常见的劣化。

### R.32: 使用`unique_ptr<widget>`作为参数，来表示函数要获取`widget`的所有权

##### 理由

以这种方式使用`unique_ptr`，可以同时说明和保证函数调用的所有权转移。

##### 示例

```cpp
void sink(unique_ptr<widget>); // 消费widget

void uses(widget*);            // 只是使用widget
```

##### 示例，不好的

```cpp
void thinko(const unique_ptr<widget>&); // 通常不是你想要的
```

##### 实施

* （简单）如果一个函数以左值引用接受`unique_ptr<T>`作为参数，而没有至少在一个代码路径上对它赋值或者调用它的`reset()`，发出警告。建议接受`T*`或者`T&`代替。
* （简单）（（基本的））如果一个函数以`const`引用接受`unique_ptr<T>`参数，发出警告。建议接受`const T*`或者`const T&`代替。

### R.33: 使用`unique_ptr<widget>&`作为参数，来表示函数要重设`widget`

##### 理由

以这种方式使用`unique_ptr`，可以同时说明和保证函数调用的重设语义。

##### 注意

“重设”的意思是“使指针或智能指针指向另一个对象”。

##### 示例

```cpp
void reseat(unique_ptr<widget>&); // “将会”或者“可能”重设指针
```

##### 示例，不好的

```cpp
void thinko(const unique_ptr<widget>&); // 通常不是你想要的
```

##### 实施

* （简单）如果一个函数以左值引用接受`unique_ptr<T>`作为参数，而没有至少在一个代码路径上对它赋值或者调用它的`reset()`，发出警告。建议接受`T*`或者`T&`代替。
* （简单）（（基本的））如果一个函数以`const`引用接受`unique_ptr<T>`参数，发出警告。建议接受`const T*`或者`const T&`代替。

### R.34: 使用`shared_ptr<widget>`作为参数，来表示函数是部分所有者

##### 理由

这会使得函数的所有权共享意图更清晰。

##### 示例，好的

```cpp
void share(shared_ptr<widget>);            // 共享——“将会”持有引用计数

void may_share(const shared_ptr<widget>&); // “可能”持有引用计数

void reseat(shared_ptr<widget>&);          // “可能”重设指针
```

##### 实施

* （简单）如果一个函数以左值引用接受`shared_ptr<T>`作为参数，而没有至少在一个代码路径上对它赋值或者调用它的`reset()`，发出警告。建议接受`T*`或者`T&`代替。
* （简单）（（基本的））如果一个函数以值或者以`const`引用接受`shared_ptr<T>`参数，而没有至少在一个代码路径上拷贝或移动给另一个`shared_ptr`，发出警告。建议接受`T*`或者`T&`代替。
* （简单）（（基本的））如果一个函数以右值引用接受`shared_ptr<T>`，发出警告。建议以值来接受。

### R.35: 使用`shared_ptr<widget>&`作为参数，来表示函数可能会重设共享的指针

##### 理由

这会使得函数的重设意图更清晰。

##### 注意

“重设”的意思是“使指针或智能指针指向另一个对象”。

##### 示例，好的

```cpp
void share(shared_ptr<widget>);            // 共享——“将会”持有引用计数

void reseat(shared_ptr<widget>&);          // “可能”重设指针

void may_share(const shared_ptr<widget>&); // “可能”持有引用计数
```

##### 实施

* （简单）如果一个函数以左值引用接受`shared_ptr<T>`作为参数，而没有至少在一个代码路径上对它赋值或者调用它的`reset()`，发出警告。建议接受`T*`或者`T&`代替。
* （简单）（（基本的））如果一个函数以值或者以`const`引用接受`shared_ptr<T>`参数，而没有至少在一个代码路径上拷贝或移动给另一个`shared_ptr`，发出警告。建议接受`T*`或者`T&`代替。
* （简单）（（基本的））如果一个函数以右值引用接受`shared_ptr<T>`，发出警告。建议以值来接受。

### R.36: 使用`const shared_ptr<widget>&`作为参数，来表示函数可能会持有对象的引用计数???

##### 理由

这会使得函数的???意图更清晰。

##### 示例，好的

```cpp
void share(shared_ptr<widget>);            // 共享——“将会”持有引用计数

void reseat(shared_ptr<widget>&);          // “可能”重设指针

void may_share(const shared_ptr<widget>&); // “可能”持有引用计数
```

##### 实施

* （简单）如果一个函数以左值引用接受`shared_ptr<T>`作为参数，而没有至少在一个代码路径上对它赋值或者调用它的`reset()`，发出警告。建议接受`T*`或者`T&`代替。
* （简单）（（基本的））如果一个函数以值或者以`const`引用接受`shared_ptr<T>`参数，而没有至少在一个代码路径上拷贝或移动给另一个`shared_ptr`，发出警告。建议接受`T*`或者`T&`代替。
* （简单）（（基本的））如果一个函数以右值引用接受`shared_ptr<T>`，发出警告。建议以值来接受。

### R.37: 不要传递从别名智能指针获取的指针或引用

##### 理由

违反该准则是导致丢失引用计数和遇到悬挂指针的头号原因。在调用链上，函数应该优先传递原始指针和引用。在你从保持对象存活的智能指针中获得原始指针或引用的调用树顶端，你需要确保这个智能指针在调用树的下方不会被意外地重置或者赋值。

##### 注意

为了做到这一点，有时你需要获取智能指针的局部拷贝，在函数和调用树的过程中它稳固地保持对象存活。

##### 示例

考虑以下代码：

```cpp
// 全局变量（静态分配或者堆分配），或者是另一个局部变量的别名…
shared_ptr<widget> g_p = ...;

void f(widget& w)
{
    g();
    use(w);  // A
}

void g()
{
    g_p = ...; // 糟糕，如果这是最后一个指向widget的shared_ptr，会销毁widget
}
```

下面的代码不应该通过代码评审：

```cpp
void my_code()
{
    // 不好的：传递从非局部智能指针获取的指针或引用，
    // 该智能指针可能会在f内部或者它调用的函数中意外地重置
    f(*g_p);

    // 不好的：相同的原因，只作为“this”指针来传递它
    g_p->func();
}
```

修复方法很简单——获取指针的局部拷贝来为你的调用树“保持引用计数”：

```cpp
void my_code()
{
    // 廉价的：增加1个计数可以覆盖整个函数以及其下的全部调用树
    auto pin = g_p;

    // 没问题：传递从局部的、非别名的智能指针获取的指针或引用
    f(*pin);

    // 没问题：相同的原因
    pin->func();
}
```

##### 实施

* （简单）如果一个用于函数调用的指针或引用是从智能指针变量（`unique_ptr`或`shared_ptr`）获取的，而该变量是非局部的，或者它是局部的但可能是其它变量的别名，发出警告。如果智能指针是`shared_ptr`，那么建议获取智能指针的局部拷贝，然后从这个拷贝获取指针或引用。

## ES: 表达式和语句

表达式和语句是表达行为和计算的最低层级和最直接的方式。局部作用域中的声明即语句。

对于命名、注释以及缩进规则，参阅NL: 命名和布局。

一般准则：

* ES.1: 优先使用标准库而不是其它库以及“手工打造的代码”
* ES.2: 优先使用合适的抽象而不是直接使用语言特性

声明准则：

* ES.5: 保持作用域短小
* ES.6: 在for语句的初始化器和条件中声明名称来限制作用域
* ES.7: 保持常见和局部的名称短小，同时使不常见和非局部的名称更长一些
* ES.8: 避免看起来相似的名称
* ES.9: 避免`ALL_CAPS`形式的名称
* ES.10: 在每个声明中（只）声明一个名称
* ES.11: 使用`auto`避免冗余的重复类型名称
* ES.12: 不要在嵌套作用域中复用名称
* ES.20: 总是初始化对象
* ES.21: 不要在你需要使用之前引入变量（或常量）
* ES.22: 不要在拥有初始值之前声明变量
* ES.23: 优先使用`{}`初始化器语法
* ES.24: 使用`unique_ptr<T>`持有指针
* ES.25: 把对象声明为`const`或`constexpr`，除非你以后想修改它的值
* ES.26: 不要为两个不相关的目的使用同一个变量
* ES.27: 为栈上的数组使用`std::array`或`stack_array`
* ES.28: 对于复杂的初始化使用lambda，特别是`const`变量
* ES.30: 不要使用宏进行程序文本操作
* ES.31: 不要使用宏作为常量或“函数”
* ES.32: 使用`ALL_CAPS`的形式作为所有宏的名称
* ES.33: 如果你必须使用宏，给它们唯一的名称
* ES.34: 不要定义（C风格的）可变参数函数

表达式准则：

* ES.40: 避免复杂的表达式
* ES.41: 如果对操作符的优先级有疑问，加上括号
* ES.42: 保持指针的使用简单直接
* ES.43: 避免求值顺序不确定的表达式
* ES.44: 不要依赖函数参数的求值顺序
* ES.45: 避免“魔法常量”；使用符号常量
* ES.46: 避免收缩转换
* ES.47: 使用`nullptr`而不是`0`或`NULL`
* ES.48: 避免转型
* ES.49: 如果你必须使用转型，使用具名的转型
* ES.50: 不要丢弃`const`
* ES.55: 避免进行范围检查
* ES.56: 只有当你需要显式地移动对象到另一个作用域时才使用`std::move()`
* ES.60: 避免在资源管理函数外部使用`new`和`delete`
* ES.61: 使用`delete[]`删除数组以及使用`delete`删除非数组
* ES.62: 不要比较指向不同数组的指针
* ES.63: 不要发生对象切割
* ES.64: 使用`T{e}`表示法来构造
* ES.65: 不要解引用无效的指针

语句准则：

* ES.70: 当可以选择的时候，优先使用`switch`语句而不是`if`语句
* ES.71: 当可以选择的时候，优先使用基于范围的`for`语句而不是普通的`for`语句
* ES.72: 当存在明显的循环变量时，优先使用`for`语句而不是`while`语句
* ES.73: 当不存在明显的循环变量时，优先使用`while`语句而不是`for`语句
* ES.74: 优先在`for`语句的初始化器部分声明循环变量
* ES.75: 避免`do`语句
* ES.76: 避免`goto`
* ES.77: 最小化循环中`break`和`continue`的使用
* ES.78: 总是用`break`结束不为空的`case`
* ES.79: （只）使用`default`来处理通用情况
* ES.84: 不要（试图）声明没有名称的局部变量
* ES.85: 使空语句可见
* ES.86: 避免在原始`for`循环的循环体中修改循环控制变量
* ES.87: 不要在条件中添加冗余的`==`或`!=`

算术准则：

* ES.100: 不要混合有符号和无符号算术
* ES.101: 对位操作使用无符号类型
* ES.102: 对算术使用有符号类型
* ES.103: 不要溢出
* ES.104: 不要下溢
* ES.105: 不要除以0
* ES.106: 不要试图通过使用`unsigned`来避免负值
* ES.107: 不要使用`unsigned`作为下标，优先使用`gsl::index`

### ES.1: 优先使用标准库而不是其它库以及“手工打造的代码”

##### 理由

使用库的代码比起直接使用语言特性的代码更容易写，更短，有更高层次的抽象，而且库的代码一般都是已经测试好的。ISO C++标准库是最广为人知而且测试得最好的库。它作为所有C++实现中的一部分来提供使用。

##### 示例

```cpp
auto sum = accumulate(begin(a), end(a), 0.0);   // 好
```

基于范围的`accumulate`版本甚至会更好：

```cpp
auto sum = accumulate(v, 0.0); // 更好
```

但不要自己手写一个已知的算法：

```cpp
int max = v.size();   // 不好：啰嗦，目的不明确
double sum = 0.0;
for (int i = 0; i < max; ++i)
    sum = sum + v[i];
```

##### 例外

标准库的很多部分依赖动态分配（自由存储）。这些部分，尤其是容器但不包括算法，对于硬实时和嵌入式程序是不合适的。在这种情况下，考虑提供/使用类似的设施，例如，具有标准库风格的基于池分配器实现的容器。

##### 实施

不容易。???查找混乱的循环，嵌套的循环，长函数，缺少函数调用，缺乏使用非内置类型。圈复杂度？

### ES.2: 优先使用合适的抽象而不是直接使用语言特性

##### 理由

“合适的抽象”（例如库或者类）比原始的语言更接近应用概念，生成更短和更整洁的代码，而且可以更好地测试。

##### 示例

```cpp
vector<string> read1(istream& is)   // 好的
{
    vector<string> res;
    for (string s; is >> s;)
        res.push_back(s);
    return res;
}
```

更传统和更低层级的近似等价物会更长、更混乱、更难正确执行以及很可能会更慢：

```cpp
char** read2(istream& is, int maxelem, int maxstring, int* nread)   // 不好的：啰嗦和不完整
{
    auto res = new char*[maxelem];
    int elemcount = 0;
    while (is && elemcount < maxelem) {
        auto s = new char[maxstring];
        is.read(s, maxstring);
        res[elemcount++] = s;
    }
    nread = &elemcount;
    return res;
}
```

一旦加入了溢出检查和错误处理，这个代码会完全变得混乱，而且有个问题是要记住用`delete`删除返回的指针以及该数组中包含的C风格字符串。

##### 实施

不容易。???查找混乱的循环，嵌套的循环，长函数，缺少函数调用，缺乏使用非内置类型。圈复杂度？

## ES.dcl: 声明

声明是一个语句。声明把名称引入作用域，以及可能会使具名的对象进行构造。

### ES.5: 保持作用域短小

##### 理由

可读性。最小化资源存留。避免值的意外误用。

**另一种表述**：不要在不必要大的作用域中声明名称。

##### 示例

```cpp
void use()
{
    int i;    // 不好的：i在循环后仍然可以访问是不必要的
    for (i = 0; i < 20; ++i) { /* ... */ }
    // 这里没有使用i的打算
    for (int i = 0; i < 20; ++i) { /* ... */ }  // 好的：i对于for循环是局部的

    if (auto pc = dynamic_cast<Circle*>(ps)) {  // 好的：pc对于if语句是局部的
        // ... 处理Circle ...
    }
    else {
        // ... 处理错误 ...
    }
}
```

##### 示例，不好的

```cpp
void use(const string& name)
{
    string fn = name + ".txt";
    ifstream is {fn};
    Record r;
    is >> r;
    // ... 200行代码，没有使用fn或is的打算 ...
}
```

这个函数不管怎样都太长了，但关键点是`fn`使用的资源以及`is`持有的文件句柄被保留得比所需的时间长得多，而且对`is`和`fn`意料之外的使用可能会出现在函数的后面。在这个情况下，把读取重构出来也许是一个好的想法：

```cpp
Record load_record(const string& name)
{
    string fn = name + ".txt";
    ifstream is {fn};
    Record r;
    is >> r;
    return r;
}

void use(const string& name)
{
    Record r = load_record(name);
    // ... 200行代码 ...
}
```

##### 实施

* 标记出声明在循环外部，而在循环后又没有使用的变量。
* 当昂贵的资源，例如文件句柄和锁超过N行代码（N为合适的值）没有使用时，发出警告。

### ES.6: 在for语句的初始化器和条件中声明名称来限制作用域

##### 理由

可读性。最小化资源存留。

##### 示例

```cpp
void use()
{
    for (string s; cin >> s;)
        v.push_back(s);

    for (int i = 0; i < 20; ++i) {   // 好的：i对于for循环是局部的
        // ...
    }

    if (auto pc = dynamic_cast<Circle*>(ps)) {   // 好的：pc对于if语句是局部的
        // ... 处理Circle ...
    }
    else {
        // ... 处理错误 ...
    }
}
```

##### 实施

* 标记出在循环之前声明而在循环之后又没有使用的循环变量。
* （困难）标记出在循环之前声明而在循环之后用于不相关目的的循环变量。

##### C++17示例

注意：C++17也添加了`if`和`switch`的初始化器语句。这些特性需要C++17的支持。

```cpp
map<int, string> mymap;

if (auto result = mymap.insert(value); result.second) {
    // 插入成功，result在这个代码块中有效
    use(result.first);  // 没问题
    // ...
} // result在这里销毁
```

##### C++17实施（如果正在使用C++17编译器）

* 标记出在代码体之前声明而在代码体之后又没有使用的分支/循环变量。
* （困难）标记出在代码体之前声明而在代码体之后用于不相关目的的分支/循环变量。

### ES.7: 保持常见和局部的名称短小，同时使不常见和非局部的名称更长一些

##### 理由

可读性。减少无关的非局部名称之间冲突的机会。

##### 示例

符合惯例的、短小的局部名称增加了可读性：

```cpp
template<typename T>    // 好的
void print(ostream& os, const vector<T>& v)
{
    for (gsl::index i = 0; i < v.size(); ++i)
        os << v[i] << '\n';
}
```

索引按照惯例称为`i`，而且在这个泛型函数中没有关于vector含义的提示，所以`v`也是好名称。作为对比：

```cpp
template<typename Element_type>   // 不好的：啰嗦，难以阅读
void print(ostream& target_stream, const vector<Element_type>& current_vector)
{
    for (gsl::index current_element_index = 0;
            current_element_index < current_vector.size();
            ++current_element_index
    )
    target_stream << current_vector[current_element_index] << '\n';
}
```

是的，这是一个夸张的示例，但我们见过比这更糟糕的。

##### 示例

不符合惯例且短小的非局部名称使代码难以理解：

```cpp
void use1(const string& s)
{
    // ...
    tt(s);   // 不好的：什么是tt()？
    // ...
}
```

更好的做法是，给非局部的实体取可读的名称：

```cpp
void use1(const string& s)
{
    // ...
    trim_tail(s);   // 好多了
    // ...
}
```

这里，读者有机会了解`trim_trail`的含义，而且读者在查找之后可以记住它。

##### 示例，不好的

大型函数的参数名称实际上是非局部的，因而应该是有含义的：

```cpp
void complicated_algorithm(vector<Record>& vr, const vector<int>& vi, map<string, int>& out)
// 根据vi中的索引从vr中的事件读取，把（名称，索引）对放进out
{
    // ... 使用vr、vi和out的500行代码 ...
}
```

我们建议保持函数短小，但这个准则不是普遍适用的，所以在命名上应该反映出含义。

##### 实施

检查局部和非局部名称的长度。同时也要考虑函数的长度。

### ES.8: 避免看起来相似的名称

##### 理由

代码清晰性和可读性。太相似的名称会减慢理解速度以及增加出错的可能性。

##### 示例；不好的

```cpp
if (readable(i1 + l1 + ol + o1 + o0 + ol + o1 + I0 + l0)) surprise();
```

##### 示例；不好的

不要在同一个作用域中把非类型名称与类型名称声明成一样。这去掉了使用关键字如`struct`或`enum`来消除歧义的需要。这同时也去掉了错误的来源，因为如果查找失败的话`struct X`可以隐式地声明`X`。

```cpp
struct foo { int n; };
struct foo foo();       // 不好的，foo已经是作用域中的类型
struct foo x = foo();   // 需要消除歧义
```

##### 例外

古老的头文件可能会在同一个作用域中把非类型名称和类型名称声明得一样。

##### 实施

* 对照一份已知的会导致困惑的字母和数字组合来检查名称。
* 如果一个变量、函数或者枚举器的声明隐藏了在相同作用域中声明的类或枚举，标记出来。

### ES.9: 避免`ALL_CAPS`形式的名称

##### 理由

这种名字通常用于宏。因此，`ALL_CAPS`形式的名称容易受到非预期的宏替换的破坏。

##### 示例

```cpp
// 在某个头文件中的某个地方
#define NE !=

// 在其它头文件中的某个地方
enum Coord { N, NE, NW, S, SE, SW, E, W };

// 在某个可怜程序员的.cpp中的某个地方：
switch (direction) {
case N:
    // ...
case NE:
    // ...
// ...
}
```

##### 注意

不要只是因为常量以前用宏来定义就使用`ALL_CAPS`作为常量的名称。

##### 实施

标记出所有`ALL_CAPS`形式名称的使用。对于旧代码，接受`ALL_CAPS`形式的名称用于宏，并且标记出所有不是`ALL_CAPS`形式的宏名称。

### ES.10: 在每个声明中（只）声明一个名称

##### 理由

一行一个声明增加了可读性，而且避免了与C/C++语法器有关的错误。同时这为更具描述性的行末注释提供了空间。

##### 示例，不好的

```cpp
char *p, c, a[7], *pp[7], **aa[10];   // 真恶心！
```

##### 例外

函数的声明会包含多个函数参数声明。

##### 例外

结构化绑定（C++17）特意设计来引入多个变量：

```cpp
auto [iter, inserted] = m.insert_or_assign(k, val);
if (inserted) { /* 插入了新的项 */ }
```

##### 示例

```cpp
template <class InputIterator, class Predicate>
bool any_of(InputIterator first, InputIterator last, Predicate pred);
```

或者更好的是使用概念：

```cpp
bool any_of(InputIterator first, InputIterator last, Predicate pred);
```

##### 示例

```cpp
double scalbn(double x, int n);   // 没问题：x * pow(FLT_RADIX, n)；FLT_RADIX通常是2
```

或者：

```cpp
double scalbn(    // 好多了：x * pow(FLT_RADIX, n)；FLT_RADIX 通常是2
    double x,     // 基值
    int n         // 指数
);
```

或者：

```cpp
// 好多了：x * pow(FLT_RADIX, n)；FLT_RADIX 通常是2
double scalbn(double base, int exponent);
```

##### 示例

```cpp
int a = 7, b = 9, c, d = 10, e = 3;
```

在一长串声明中，很容易看漏了未初始化的变量。

##### 实施

标记出使用了多个声明的变量和常量（例如`int* p, q;`）。

### ES.11: 使用`auto`避免冗余的重复类型名称

##### 理由

* 单调的重复是冗长且容易出错的。
* 当你使用`auto`的时候，被声明实体的名称在声明语句中的位置是固定的，增加了可读性。
* 在模板函数的声明中，返回值可以是成员类型。

##### 示例

考虑以下代码：

```cpp
auto p = v.begin();   // vector<int>::iterator
auto h = t.future();
auto q = make_unique<int[]>(s);
auto f = [](int x){ return x + 10; };
```

在每种情况下，我们省去了写出很长的、难以记住的类型，这些类型编译器已经知道，而程序员有可能会写错。

##### 示例

```cpp
template<class T>
auto Container<T>::first() -> Iterator;   // Container<T>::Iterator
```

##### 例外

避免为初始化器列表使用`auto`，在那种情况下你明确知道你想要的类型，而且初始化器可能需要转换。

##### 示例

```cpp
auto lst = { 1, 2, 3 };   // list是一个初始化器列表
auto x{1};   // x是一个int（在C++14标准修正后；在C++11中是一个initializer_list）
```

##### 注意

当可以使用概念的时候，我们可以（也应该）更明确地说明我们正在推导的类型：

```cpp
// ...
ForwardIterator p = algo(x, y, z);
```

##### 示例（C++17）

```cpp
auto [ quotient, remainder ] = div(123456, 73);   // 拆解出div_t结果的成员
```

##### 实施

标记出在声明中冗余的重复类型名称。

### ES.12: 不要在嵌套作用域中复用名称

##### 理由

哪个变量被使用很容易使人疑惑。会导致维护问题。

##### 示例，不好的

```cpp
int d = 0;
// ...
if (cond) {
    // ...
    d = 9;
    // ...
}
else {
    // ...
    int d = 7;
    // ...
    d = value_to_be_returned;
    // ...
}

return d;
```

如果这是一个大型的`if`语句，很容易看漏在内部作用域中引入了新的`d`。这是已知的缺陷来源。有时这种在内部作用域中的名称重用称为“遮盖”。

##### 注意

当函数太大太复杂时，遮盖是一个主要的问题。

##### 示例

在最外层的块中遮盖函数参数是不被语言允许的：

```cpp
void f(int x)
{
    int x = 4;  // 错误：重用函数参数名称

    if (x) {
        int x = 7;  // 允许，但不好
        // ...
    }
}
```

##### 示例，不好的

重用成员名称作为局部变量也是一个问题：

```cpp
struct S {
    int m;
    void f(int x);
};

void S::f(int x)
{
    m = 7;    // 赋值给成员
    if (x) {
        int m = 9;
        // ...
        m = 99; // 赋值给成员
        // ...
    }
}
```

##### 例外

我们通常在派生类中重用来自基类的名称：

```cpp
struct B {
    void f(int);
};

struct D : B {
    void f(double);
    using B::f;
};
```

这是容易出错的。例如，当我们忘记使用using声明时，调用`d.f(1)`不会找到`f`的`int`版本。

???我们是否需要指定关于在类层次结构中遮盖/隐藏的准则？

##### 实施

* 标记出在内嵌局部作用域中重用的名称。
* 标记出在成员函数中重用为局部变量的成员名称。
* 标记出重用为局部变量或成员名称的全局名称。
* 标记出在派生类中重用的基类成员名称（除了函数名称）。

### ES.20: 总是初始化对象

##### 理由

避免“在设置之前使用”的错误以及与这些错误相关的未定义行为。避免复杂初始化的理解问题。简化重构。

##### 示例

```cpp
void use(int arg)
{
    int i;   // 不好的：未初始化的变量
    // ...
    i = 7;   // 初始化i
}
```

不，`i = 7`并不是初始化`i`；而是赋值给它。而且，`i`可以在`...`部分被读取。更好的是：

```cpp
void use(int arg)   // 没问题
{
    int i = 7;   // 没问题：经过初始化
    string s;    // 没问题：经过默认初始化
    // ...
}
```

##### 注意

*总是初始化*准则有意强于*对象在使用之前必须设置*的语言准则。后者作为更宽松的准则，捕捉了技术上的缺陷，但是：

* 它会导致更低可读性的代码
* 它鼓励人们在大于所需作用域的范围声明名称
* 它会导致更难以阅读的代码
* 它鼓励复杂的代码，会导致逻辑缺陷
* 它会阻碍重构

*总是初始化*准则是一个代码风格准则，旨在提高可维护性，同时它也是一个针对“在设置之前使用”错误的准则。

##### 示例

这里的例子通常用来说明对更宽松的初始化准则的需要：

```cpp
widget i;    // “widget”类型的初始化高昂，可能是一个大型的POD
widget j;

if (cond) {  // 不好的：i和j被“推迟”初始化
    i = f1();
    j = f2();
}
else {
    i = f3();
    j = f4();
}
```

这不能简单地重写成用初始化器来初始化`i`和`j`。要注意对于具有默认构造函数的类型，试图延迟初始化只会导致在默认初始化之后紧跟一个赋值。这类例子受欢迎的一个的理由是“效率”，但是一个可以检测我们是否出现了“在设置之前使用”错误的编译器同时也可以消除任何冗余的双重初始化。

假设在`i`和`j`之间存在逻辑上的联系，该联系很可能应该在代码中表示：

```cpp
pair<widget, widget> make_related_widgets(bool x)
{
    return (x) ? {f1(), f2()} : {f3(), f4() };
}

auto [i, j] = make_related_widgets(cond);    // C++17
```

##### 注意

几十年来，复杂的初始化一直受到聪明的程序员的欢迎。它同时也是错误和复杂性的主要来源。在最初的实现之后，在多年的维护中，许多这类错误被引入。

##### 示例

该准则涵盖了成员变量。

```cpp
class X {
public:
    X(int i, int ci) : m2{i}, cm2{ci} {}
    // ...

private:
    int m1 = 7;
    int m2;
    int m3;

    const int cm1 = 7;
    const int cm2;
    const int cm3;
};
```

编译器会标记出未初始化的`cm3`，因为它是`const`的，但编译器不会捕捉到缺少初始化的`m3`。通常，罕见谬误的成员初始化是值得不出现缺少初始化的错误，而且通常优化器可以消除冗余的初始化（例如，在赋值之前立即进行初始化）。

##### 例外

如果你要声明一个即将从输入进行初始化的对象，初始化它会导致双重初始化。然而，要记住在输入之后这可能会留下未初始化的数据——这是错误和安全缺口的一大来源：

```cpp
constexpr int max = 8 * 1024;
int buf[max];         // 没问题，但值得怀疑：未经初始化
f.read(buf, max);
```

初始化那个数组的代价在某些场景下是明显的。然而，这类例子的确让未初始化的变量能够访问，因此应该用怀疑的态度看待它们。

```cpp
constexpr int max = 8 * 1024;
int buf[max] = {};   // 用零填充所有元素；在某些场景下更好
f.read(buf, max);
```

如果可以的话，应使用一个不会发生溢出的库函数。例如：

```cpp
string s;   // s默认初始化未""
cin >> s;   // s经过扩充来持有字符串
```

不要考虑把作为输入操作目标的简单变量作为该准则的例外：

```cpp
int i;   // 不好的
// ...
cin >> i;
```

在并非不常见的情况下，输入目标和输入操作被分离（原本不应该分离），使“在设置之前使用”的可能性大增。

```cpp
int i2 = 0;   // 好多了
// ...
cin >> i2;
```

好的优化器应该了解输入操作，然后消除冗余的操作。

##### 示例

使用`uninitialized`或者哨兵值是问题的症状而不是解决方法：

```cpp
widget i = uninit;  // 不好的
widget j = uninit;

// ...
use(i);         // 可能在设置之前使用了
// ...

if (cond) {     // 不好的：i和j被“推迟”初始化
    i = f1();
    j = f2();
}
else {
    i = f3();
    j = f4();
}
```

现在编译器甚至不能简单地检测“在设置之前使用”了。而且，我们在widget的状态空间引入了复杂性：哪些操作在`uninit` widget上有效，哪些无效？

##### 注意

有时，lambda可以用作初始化器来避免未初始化变量：

```cpp
error_code ec;
Value v = [&] {
    auto p = get_value();   // get_value()返回pair<error_code, Value>
    ec = p.first;
    return p.second;
}();
```

或者是：

```cpp
Value v = [] {
    auto p = get_value();   // get_value()返回pair<error_code, Value>
    if (p.first) throw Bad_value{p.first};
    return p.second;
}();
```

**参阅**：ES.28

##### 实施

* 标记出每一个未初始化的变量。不要标记具有默认构造函数的用户定义类型变量。
* 检查未初始化的缓冲区是否在声明之后*立即*写入。以非`const`引用参数的方式传递未初始化变量，可以认为是写入变量。

### ES.21: 不要在你需要使用之前引入变量（或常量）

##### 理由

可读性。限制变量可以被使用的范围。

##### 示例

```cpp
int x = 7;
// ... 这里没有使用x ...
++x;
```

##### 实施

标记出那些远离首次使用的变量声明。

### ES.22: 不要在拥有初始值之前声明变量

##### 理由

可读性。限制变量可以被使用的范围。不会冒“在设置之前使用”的风险。初始化通常比赋值更高效。

##### 示例，不好的

```cpp
string s;
// ... 这里没有使用s ...
s = "what a waste";
```

##### 示例，不好的

```cpp
SomeLargeType var;   // 丑陋的驼峰风格变量

if (cond)   // 一些有意义的条件
    Set(&var);
else if (cond2 || !cond3) {
    var = Set2(3.14);
}
else {
    var = 0;
    for (auto& e : something)
        var += e;
}

// 使用var；只通过控制流就可以静态地保证这不会发生得太早
```

如果`SomeLargeType`有一个开销不怎么昂贵的默认初始化，这是没问题的。否则，程序员会非常疑惑是否在混乱的条件中每个可能的代码路径都被覆盖到了。如果不是，我们就会遇到“在设置之前使用”的缺陷。这是一个维护的陷阱。

对于适度复杂的初始化，包括对`const`变量的初始化，考虑使用lambda表达式进行初始化；参阅[ES.28]。

##### 实施

* 标记出使用了默认初始化的声明，这些声明在它们的首次读取之前被赋值。
* 标记出复杂的计算，这些计算位于未初始化的变量之后，以及在变量的使用之前。

### ES.23: 优先使用`{}`初始化器语法

##### 理由

使用`{}`初始化的规则比其它形式的初始化更简单，更通用，更明确，以及更安全。

##### 示例

```cpp
int x {f(99)};
vector<int> v = {1, 2, 3, 4, 5, 6};
```

##### 例外

对于容器，有一个传统是使用`{...}`来表示元素列表，以及使用`(...)`来表示大小：

```cpp
vector<int> v1(10);    // vector有10个默认值为0的元素
vector<int> v2 {10};   // vector有1个值为10的元素
```

##### 注意

`{}`初始化器不允许收缩转换。

##### 示例

```cpp
int x {7.9};   // 错误：被收缩
int y = 7.9;   // 没问题：y变成了7。希望能有编译器警告。
```

##### 注意

`{}`初始化可以用于所有初始化；而其它形式的初始化不能：

```cpp
auto p = new vector<int> {1, 2, 3, 4, 5};   // 已初始化的vector
D::D(int a, int b) :m{a, b} {   // 成员初始化器（例如，m可能是一个pair）
    // ...
};
X var {};   // 初始化var为空
struct S {
    int m {7};   // 成员的默认初始化器
    // ...
};
```

##### 注意

用单一的值来初始化使用`auto`声明的变量，例如`{v}`，在C++17之前会有意外的结果。C++17的规则稍微更少出现意外：

```cpp
auto x1 {7};        // x1是值为7的int
auto x2 = {7};  // x2是含有元素7的initializer_list<int>

auto x11 {7, 8};    // 错误：两个初始化器
auto x22 = {7, 8};  // x2是含有元素7和8的initializer_list<int>
```

所以如果你真的想要一个`initializer_list<T>`，使用`={...}`：

```cpp
auto fib10 = {1, 1, 2, 3, 5, 8, 13, 21, 34, 55};   // fib10是一个列表
```

##### 注意

旧习惯很难改掉，所以这个准则难以持续地应用，特别是在很多情况下`=`是无害的。

##### 示例

```cpp
template<typename T>
void f()
{
    T x1(1);    // 用1来初始化T
    T x0();     // 错误的：函数声明（通常是一个错误）

    T y1 {1};   // 用1来初始化T
    T y0 {};    // 默认初始化T
    // ...
}
```

**另见**：讨论

##### 实施

棘手的。

* 不要标记用在简单初始化器上的`=`。
* 查找出现在`auto`之后的`=`。

### ES.24: 使用`unique_ptr<T>`持有指针

##### 理由

使用`std::unique_ptr`是防止泄露的最简单方式。它是可靠的，它使类型系统做了很多工作来验证所有权的安全性，它增加了可读性，而且它拥有零或接近于零的运行时开销。

##### 示例

```cpp
void use(bool leak)
{
    auto p1 = make_unique<int>(7);   // 没问题
    int* p2 = new int{7};            // 不好的：可能会泄露
    // ... 没有对p2赋值 ...
    if (leak) return;
    // ... 没有对p2赋值 ...
    vector<int> v(7);
    v.at(7) = 0;                    // 抛出异常
    // ...
}
```

如果`leak == true`，`p2`指向的对象会被泄露，而`p1`指向的对象不会。当`at()`抛出异常的时候会有同样的情况。

##### 实施

查找原始指针，这些原始指针是`new`、`malloc()`或者会返回这类指针的函数的目标。

### ES.25: 把对象声明为`const`或`constexpr`，除非你以后想修改它的值

##### 理由

通过这种方式你不会错误地改变对象的值。使用这种方式可能会给编译器提供优化的机会。

##### 示例

```cpp
void f(int n)
{
    const int bufmax = 2 * n + 2;  // 好的：我们不能意外地修改bufmax
    int xmax = n;                  // 可疑的：xmax是否有意要修改？
    // ...
}
```

##### 实施

查看变量是否实际可变的，如果不是则标记出来。不幸的是，当一个非`const`变量并不是*有意*改变时，不太可能检测得出来（比起当它没有被改变时）。

### ES.26: 不要为两个不相关的目的使用同一个变量

##### 理由

可读性和安全性。

##### 示例，不好的

```cpp
void use()
{
    int i;
    for (i = 0; i < 20; ++i) { /* ... */ }
    for (i = 0; i < 200; ++i) { /* ... */ } // 不好的：i重复使用
}
```

##### 注意

作为优化，你可能想复用一个缓冲区作为临时存储区域，但即使是这样，也要优先考虑尽可能地限制变量的作用域，并且小心地避免重用缓冲区中遗留数据导致的缺陷，因为这是安全缺陷常见的来源。

```cpp
void write_to_file() {
    std::string buffer;             // 避免在每次循环重复分配
    for (auto& o : objects)
    {
        // First part of the work.
        generate_first_String(buffer, o);
        write_to_file(buffer);

        // Second part of the work.
        generate_second_string(buffer, o);
        write_to_file(buffer);

        // 其它...
    }
}
```

##### 实施

标记出重复使用的变量。

### ES.27: 为栈上的数组使用`std::array`或`stack_array`

##### 理由

它们可读性高，并且不会隐式转换成指针。它们不会与内置数组的非标准扩展产生混淆。

##### 示例，不好的

```cpp
const int n = 7;
int m = 9;

void f()
{
    int a1[n];
    int a2[m];   // 错误：不是ISO C++
    // ...
}
```

##### 注意

`a1`的定义是合法的C++，一直都是。存在很多这样的代码。然而这是容易出错的，特别是当边界是非局部变量时。而且，这是一个“流行的”错误来源（缓冲区溢出、数组衰变成指针等）。`a2`的定义是C但不是C++，而且这是一个安全隐患。

##### 示例

```cpp
const int n = 7;
int m = 9;

void f()
{
    array<int, n> a1;
    stack_array<int> a2(m);
    // ...
}
```

##### 实施

* 标记出非常量边界的数组（C风格的VLA）。
* 标记出非局部常量边界的数组。

### ES.28: 对复杂的初始化使用lambda，特别是`const`变量

##### 理由

它很好地封装了局部的初始化，包括去掉只需要在初始化用到的临时变量，不需要创建不必要的非局部且不可复用的函数。它同时也适用于应该为`const`，但只在进行了一些初始化后才有效的变量。

##### 示例，不好的

```cpp
widget x;   // 应该为const，但是：
for (auto i = 2; i <= N; ++i) {          // 这里可能是一些
    x += some_obj.do_something_with(i);  // 用来初始化x的
}                                        // 任意长代码
// 从这里开始，x应该是const，但在这种方式下我们不能这样说
```

##### 示例，好的

```cpp
const widget x = [&]{
    widget val;                                // 假设widget有默认构造函数
    for (auto i = 2; i <= N; ++i) {            // 这里可能是一些
        val += some_obj.do_something_with(i);  // 用来初始化x的
    }                                          // 任意长代码
    return val;
}();
```

##### 示例

```cpp
string var = [&]{
    if (!in) return "";   // 默认
    string s;
    for (char c : in >> c)
        s += toupper(c);
    return s;
}(); // 注意()
```

如果可能的话，将条件减少到一组简单的可选值（例如`enum`），并且不要混淆选择和初始化。

##### 实施

困难的。最好是启发式的。查找未初始化的变量，后面紧跟着对它赋值的循环。

### ES.30: 不要使用宏进行程序文本操作

##### 理由

宏是缺陷的主要来源。宏不遵守平常的作用域和类型规则。宏会导致人类读者看到的东西与编译器看到的东西不一样。宏使工具的创建更复杂。

##### 示例，糟糕的

```cpp
#define Case break; case   /* 糟糕的 */
```

这个看似无害的宏会使单个小写的`c`而不是`C`引起糟糕的流控制缺陷。

##### 注意

这个准则不禁止用于`#ifdef`等语句上的“配置控制”宏。

##### 实施

当你看到一个宏不仅仅用于源代码控制（例如`#ifdef`）时，尖叫吧。

### ES.31: 不要使用宏作为常量或“函数”

##### 理由

宏是缺陷的主要来源。宏不遵守平常的作用域和类型规则。宏会导致人类读者看到的东西与编译器看到的东西不一样。宏使工具的创建更复杂。

##### 示例，不好的

```cpp
#define PI 3.14
#define SQUARE(a, b) (a * b)
```

即使我们没有在`SQUARE`中留下众所周知的缺陷，也有表现得更好的替代品；例如：

```cpp
constexpr double pi = 3.14;
template<typename T> T square(T a, T b) { return a * b; }
```

##### 实施

当你看到一个宏不仅仅用于源代码控制（例如`#ifdef`）时，尖叫吧。

### ES.32: 使用`ALL_CAPS`的形式作为所有宏的名称

##### 理由

惯用法。可读性。能辨别出宏。

##### 示例

```cpp
#define forever for (;;)   /* 非常糟糕 */

#define FOREVER for (;;)   /* 仍然是不好的，但至少对人来说是可见的 */
```

##### 实施

当你看到一个小写的宏，尖叫吧。

### ES.33: 如果你必须使用宏，给它们唯一的名称

##### 理由

宏不遵守作用域规则。

##### 示例

```cpp
#define MYCHAR        /* 糟糕的，最终会与其它地方的MYCHAR冲突 */

#define ZCORP_CHAR    /* 仍然是不好的，但更少机会发生冲突 */
```

##### 注意

如果可以的话避免使用宏：ES.30，ES.31以及ES.32。然而，有无数的代码到处都是宏，而且有很久的传统使用和过度使用宏。如果你被迫要使用宏，应使用长名称和假定是唯一的前缀（例如你所在组织的名称）来降低冲突的可能性。

##### 实施

对短的宏名称发出警告。

### ES.34: 不要定义（C风格的）可变参数函数

##### 理由

不是类型安全的。需要杂乱的充满转型和宏的代码才能正常运作。

##### 示例

```cpp
#include <cstdarg>

// “severity”后面跟随以零结尾的char*列表；把C风格字符串写进cerr
void error(int severity ...)
{
    va_list ap;             // 一个持有参数的魔法类型
    va_start(ap, severity); // 可变参数开始：“severity”是error()的第一个参数

    for (;;) {
        // 把下一个变量视为char*；没有检查：这是经过伪装的转型
        char* p = va_arg(ap, char*);
        if (!p) break;
        cerr << p << ' ';
    }

    va_end(ap);             // 清理可变参数（不要忘记这个）

    cerr << '\n';
    if (severity) exit(severity);
}

void use()
{
    error(7, "this", "is", "an", "error", nullptr);
    error(7); // crash
    error(7, "this", "is", "an", "error");  // 崩溃
    const char* is = "is";
    string an = "an";
    error(7, "this", "is", an, "error"); // 崩溃
}
```

**替代方案**：使用重载、模板、以及可变参数模板。

```cpp
#include <iostream>

void error(int severity)
{
    std::cerr << '\n';
    std::exit(severity);
}

template <typename T, typename... Ts>
constexpr void error(int severity, T head, Ts... tail)
{
    std::cerr << head;
    error(severity, tail...);
}

void use()
{
    error(7); // 不会崩溃！
    error(5, "this", "is", "not", "an", "error"); // 不会崩溃！

    std::string an = "an";
    error(7, "this", "is", "not", an, "error"); // 不会崩溃！

    error(5, "oh", "no", nullptr); // 编译错误！不需要nullptr
}
```

##### 注意

这基本上是实现`printf`的方式。

##### 实施

* 标记出C风格可变参数函数的定义。
* 标记出`#include <stdarg>`和`#include <stdar.h>`。

## ES.expr: 表达式

表达式操作值。

### ES.40: 避免复杂的表达式

##### 理由

复杂的表达式容易出错。

##### 示例

```cpp
// 不好的：赋值隐藏在子表达式中
while ((c = getc()) != -1)

// 不好的：两个非局部变量在一个子表达式中赋值
while ((cin >> c1, cin >> c2), c1 == c2)

// 好多了，但可能还是太复杂
for (char c1, c2; cin >> c1 >> c2 && c1 == c2;)

// 没问题：如果i和j没有不是别名
int x = ++i + ++j;

// 没问题：如果 i != j 且 i != k
v[i] = v[j] + v[k];

// 不好的：多个赋值隐藏在子表达式中
x = a + (b = f()) + (c = g()) * 7;

// 不好的：依赖于通常被误解的优先权规则
x = a & b + c * d && e ^ f == 7;

// 不好的：未定义行为
x = x++ + x++ + ++x;
```

这里的表达式有一些是无条件地糟糕（例如，它们依赖未定义行为）。其它的只是单纯太复杂，以及/或者太不常见，以至于即使好的程序员也会误解，或者在匆忙中看漏了问题。

##### 注意

C++17收紧了求值顺序的规则（在赋值中从左到右而不是从右到左，并且没有指定函数参数的求值顺序），但这并没有改变复杂表达式难以理解的事实。

##### 注意

程序员应该了解和使用表达式的基本规则。

##### 示例

```cpp
x = k * y + z;             // 没问题

auto t1 = k * y;           // 不好的：不必要地啰嗦
x = t1 + z;

if (0 <= x && x < max)   // 没问题

auto t1 = 0 <= x;        // 不好的：不必要地啰嗦
auto t2 = x < max;
if (t1 && t2)            // ...
```

##### 实施

棘手的。多复杂的表达式才认为是复杂？一个语句只执行一个操作的方式同样是难以理解的。需要考虑的事情：

* 副作用：在多个非局部变量上的副作用是可疑的（对于一些非局部的定义），特别是当副作用在不同的子表达式中。
* 写入别名变量。
* 超过N个操作（N应该是多少？）。
* 对微妙的优先权规则的依赖。
* 使用了未定义行为（我们能否捕捉到所有未定义行为）。
* 由具体实现定义的行为？
* ???

### ES.42: 保持指针的使用简单直接

##### 理由

复杂的指针操作是错误的主要来源。

##### 注意

使用`gsl::span`来代替。指针应该只指向单一的对象。指针算法是脆弱的并且容易出错，是许许多多糟糕的缺陷和安全性违规的来源。`span`是带有边界检查，用来访问数组数据的安全类型。使用常量作为下标来访问一个已知边界的数组可以由编译器来验证。

##### 示例，不好的

```cpp
void f(int* p, int count)
{
    if (count < 2) return;

    int* q = p + 1;    // 不好的

    ptrdiff_t d;
    int n;
    d = (p - &n);      // 没问题
    d = (q - p);       // 没问题

    int n = *p++;      // 不好的

    if (count < 6) return;

    p[4] = 1;          // 不好的

    p[count - 1] = 2;  // 不好的

    use(&p[0], 3);     // 不好的
}
```

##### 示例，好的

```cpp
void f(span<int> a) // 好多了：在函数声明使用span
{
    if (a.size() < 2) return;

    int n = a[0];      // 没问题

    span<int> q = a.subspan(1); // 没问题

    if (a.size() < 6) return;

    a[4] = 1;          // 没问题

    a[count - 1] = 2;  // 没问题

    use(a.data(), 3);  // 没问题
}
```

##### 注意

用变量作为下标对工具和人来说都是难以验证安全的。`span`是具有运行时边界检查，用来访问数组数据的安全类型。`at()`是另一个可选方案来确保单次访问是经过边界检查的。如果需要用迭代器来访问数组，使用以该数组构造的`span`的迭代器。

##### 示例，不好的

```cpp
void f(array<int, 10> a, int pos)
{
    a[pos / 2] = 1; // 不好的
    a[pos - 1] = 2; // 不好的
    a[-1] = 3;    // 不好的（但容易被工具捕捉）——没有替代品，不要这样做
    a[10] = 4;    // 不好的（但容易被工具捕捉）——没有替代品，不要这样做
}
```

##### 示例，好的

使用`span`：

```cpp
void f1(span<int, 10> a, int pos) // A1：参数类型改成使用span
{
    a[pos / 2] = 1; // 没问题
    a[pos - 1] = 2; // 没问题
}

void f2(array<int, 10> arr, int pos) // A2：添加局部的span并且使用它
{
    span<int> a = {arr, pos};
    a[pos / 2] = 1; // 没问题
    a[pos - 1] = 2; // 没问题
}
```

使用`at()`：

```cpp
void f3(array<int, 10> a, int pos) // 可选方案B：使用at()来访问
{
    at(a, pos / 2) = 1; // 没问题
    at(a, pos - 1) = 2; // 没问题
}
```

##### 示例，不好的

```cpp
void f()
{
    int arr[COUNT];
    for (int i = 0; i < COUNT; ++i)
        arr[i] = i; // 不好的，不能使用非常量索引器
}
```

##### 示例，好的

使用`span`：

```cpp
void f1()
{
    int arr[COUNT];
    span<int> av = arr;
    for (int i = 0; i < COUNT; ++i)
        av[i] = i;
}
```

使用`span`和基于范围的`for`：

```cpp
void f1a()
{
    int arr[COUNT];
    span<int, COUNT> av = arr;
    int i = 0;
    for (auto& e : av)
        e = i++;
}
```

使用`at()`来访问：

```cpp
void f2()
{
    int arr[COUNT];
    for (int i = 0; i < COUNT; ++i)
        at(arr, i) = i;
}
```

使用基于范围的`for`：

```cpp
void f3()
{
    int arr[COUNT];
    for (auto& e : arr)
            e = i++;
}
```

##### 注意

利用工具可以把使用动态索引表达式的数组访问重写成用`at()`代替：

```cpp
static int a[10];

void f(int i, int j)
{
    a[i + j] = 12;      // 不好的，可以重写成…
    at(a, i + j) = 12;  // 没问题——经过边界检查
}
```

##### 示例

数组转成指针（语言基本上都这样做）去掉了检查的可能，因此要避免。

```cpp
void g(int* p);

void f()
{
    int a[5];
    g(a);        // 不好的：我们是否想要传递数组？
    g(&a[0]);    // 没问题：传递一个对象
}
```

如果你想要传递一个数组，要明确地说出来：

```cpp
void g(int* p, size_t length);  // 老的（危险的）代码

void g1(span<int> av); // 好多了：修改g()

void f2()
{
    int a[5];
    span<int> av = a;

    g(av.data(), av.size());   // 没问题，如果你没得选择
    g1(a);                     // 没问题——这里没有衰变，相反使用了隐式的span构造函数
}
```

##### 实施

* 标记出任何指针类型的算术操作表达式，表达式的结果是指针类型的值。
* 标记出任何作用于表达式或数组类型（静态数组或`std::array`）变量上的索引表达式，该索引器不是编译时常量表达式，或者表达式的值不在`0`和数组的上边界之间。
* 标记出任何依赖于数组类型到指针类型隐式转换的表达式。

该准则是边界安全性配置的一部分。

### ES.43: 避免求值顺序不确定的表达式

##### 理由

你不知道这些代码会做什么事情。可移植性。即使它做的事情对你来说是合理的，但在另一个编译器上（例如，你正在使用的编译器的下一个发行版本）或者在不同的优化器设置下，它可能会做不一样的事情。

##### 注意

C++17收紧了求值顺序的规则：在赋值中从左到右而不是从右到左，并且没有指定函数参数的求值顺序。

然而，记住你的代码可能会用C++17之前的编译器来编译（例如，剪切粘贴代码），因此不要过于机智。

##### 示例

```cpp
v[i] = ++i;  // 结果是未定义的
```

一个很好的经验总结是，你不应该在写入变量的表达式中读取该变量两次。

##### 实施

可以由好的分析器来检测。

### ES.44: 不要依赖函数参数的求值顺序

##### 理由

因为这个顺序是不确定的。

##### 注意

C++17收紧了求值顺序的规则，但是函数参数的求值顺序仍然没有明确指定。

##### 示例

```cpp
int i = 0;
f(++i, ++i);
```

这个调用很可能是`f(0, 1)`或者`f(1, 0)`，但你不知道是哪个。从技术上来说，这个行为是未定义的。在C++17中，这个代码没有了未定义行为，但是哪个参数会首先求值仍然没有确定。

##### 示例

重载操作符会导致求值顺序问题：

```cpp
f1()->m(f2());          // m(f1(), f2())
cout << f1() << f2();   // operator<<(operator<<(cout, f1()), f2())
```

在C++17中，这个例子能如预期执行（从左到右），并且赋值操作是从右到左求值（正如=的绑定是从右到左）。

```cpp
f1() = f2();    // 在C++14中是未定义行为；在C++17中，f2()在f1()之前求值
```

##### 实施

可以由好的分析器来检测。

### ES.45: 避免“魔法常量”；使用符号常量

##### 理由

表达式中的未命名常量容易看漏，并且常常难以理解：

##### 示例

```cpp
for (int m = 1; m <= 12; ++m)   // 不要这样做：魔法常量12
    cout << month[m] << '\n';
```

不，并不是所有人都知道一年中的12个月的编号是从1到12。更好的做法：

```cpp
// 月份的索引由1到12
constexpr int first_month = 1;
constexpr int last_month = 12;

for (int m = first_month; m <= last_month; ++m)   // 好多了
    cout << month[m] << '\n';
```

仍然有更好的做法，不好暴露常量：

```cpp
for (auto m : month)
    cout << m << '\n';
```

##### 实施

标记出代码中的字面量。把`0`、`1`、`nullptr`、`\n`、`""`以及其它添加到白名单中。

### ES.46: 避免丢失精度（收缩、截断）的算术转换

##### 理由

收缩转换摧毁了信息，这通常不是预期的行为。

##### 示例，不好的

一个关键的例子是基本的收缩：

```cpp
double d = 7.9;
int i = d;    // 不好的：收缩：i变成了7
i = (int) d;  // 不好的：我们意图说明进行收缩，但仍然不够明显

void f(int x, long y, double d)
{
    char c1 = x;   // 不好的：收缩
    char c2 = y;   // 不好的：收缩
    char c3 = d;   // 不好的：收缩
}
```

##### 注意

指南支持库提供了`narrow_cast`操作来指定收缩是可接受的，还有`narrow`（“如果收缩了”），如果收缩会丢失信息的话，它会抛出异常：

```cpp
i = narrow_cast<int>(d);   // 没问题（你要求的）：收缩：i变成了7
i = narrow<int>(d);        // 没问题：抛出narrowing_error
```

我们也包含了丢失精度的算术转型，例如从一个负的浮点类型到一个无符号的整型：

```cpp
double d = -7.9;
unsigned u = 0;

u = d;                          // 不好的
u = narrow_cast<unsigned>(d);   // 没问题（你要求的）：u变成了0
u = narrow<unsigned>(d);        // 没问题：抛出narrowing_error
```

##### 实施

好的分析器能够检测出所有收缩转换。然而，标记出所有收缩转换会导致很多误报。建议：

* 标记出所有浮点数到整数的转换（也许只需要标记`float`->`char`和`double`->`int`。这个做法有危险！我们需要数据）。
* 标记出所有`long`->`char`（我觉得`int`->`char`是很常见的。这个做法有危险！我们需要数据）。
* 考虑把函数参数的收缩转换视为特别值得怀疑的点。

### ES.47: 使用`nullptr`而不是`0`或`NULL`

##### 理由

可读性。最小化意外的发生：`nullptr`不能与`int`混淆。`nullptr`也有经过良好规范（非常严格）的类型，因此可以使用于更多场景，在这些场景中类型推导可能对`NULL`或者`0`做了错误的事情。

##### 示例

考虑以下代码：
```cpp
void f(int);
void f(char*);
f(0);         // 调用f(int)
f(nullptr);   // 调用f(char*)
```

##### 实施

标记出作为指针使用的`0`和`NULL`。可以使用一个简单的转换程序来帮助转换成`nullptr`。

### ES.48: 避免转型

##### 理由

转型是广为人知的错误来源。导致一些优化不可靠。

##### 示例，不好的

```cpp
double d = 2;
auto p = (long*)&d;
auto q = (long long*)&d;
cout << d << ' ' << *p << ' ' << *q << '\n';
```

你觉得这段代码会打印出什么？结果最好也只是由实现定义。我得到的是：

```cpp
2 0 4611686018427387904
```

添加了一点代码后：

```cpp
*q = 666;
cout << d << ' ' << *p << ' ' << *q << '\n';
```

我得到：

```cpp
3.29048e-321 666 666
```

感到意外吗？我只是庆幸没有把程序弄崩溃。

##### 注意

写出转型的程序员通常认为他们知道自己在做什么，或者认为写转型会让程序“更易读”。事实上，他们通常禁用了使用值的一般规则。重载解析和模板实例化一般会挑选正确的函数，如果有的话。否则，也许该函数本来就应该存在，而不是使用局部的修复（转型）。

##### 注意

在系统编程语言中，转型是必需的。例如，不这样做的话，我们如何把设备寄存器的地址存到指针中？然而，转型被严重地滥用，同时也是错误的主要来源。

##### 注意

如果你觉得需要很多转型，那可能存在一个基本的设计问题。

##### 例外

转型到`(void)`是经由标准认可的方式来关闭`[[nodiscard]]`警告。如果你调用带有`[[nodiscard]]`返回的函数，并且你有意要丢弃结果，那么首先要认真想一下这是否真的是好主意（首先函数或者返回类型的作者一般都有正确的理由使用`[[nodiscard]]`），但如果你仍然认为这是合适的并且你的代码评审人也同意，那么用`(void)`来关闭这个警告。

##### 替代方案

转型被广泛地（错误）使用。现代C++有了规则和构件来消除在许多上下文中使用转型的需要，例如：

* 使用模板
* 使用`std::variant`
* 依赖在指针类型之间定义良好的、安全的隐式转换

##### 实施

* 强制消除C风格的转型，除了使用在带有`[[nodiscard]]`返回函数上的。
* 如果存在许多函数风格的的转型，发出警告（在确定“许多”的数量上存在明显的问题）。
* 类型配置禁止`reinterpret_cast`。
* 对于指针类型之间的相等转换发出警告，即来源和目标类型相同。
* 如果指针的转型可能是隐式的，发出警告。

### ES.49: 如果你必须使用转型，使用具名的转型

##### 理由

可读性。避免出错。具名的转型比C风格或函数式转型更明确，允许编译器捕捉一些错误。

具名的转型有：

* `static_cast`
* `const_cast`
* `reinterpret_cast`
* `dynamic_cast`
* `std::move`         // `move(x)`是`x`的右值引用
* `std::forward`      // `forward(x)`是`x`的右值引用
* `gsl::narrow_cast`  // `narrow_cast<T>(x)`即`static_cast<T>(x)`
* `gsl::narrow`       // 如果`static_cast<T>(x) == x`，`narrow<T>(x)`即`static_cast<T>(x)`，否则它抛出`narrowing_error`

##### 示例

```cpp
class B { /* ... */ };
class D { /* ... */ };

template<typename D> D* upcast(B* pb)
{
    D* pd0 = pb;                        // 错误：从B*到D*没有隐式的转换
    D* pd1 = (D*)pb;                    // 合法的，但做了什么事情？
    D* pd2 = static_cast<D*>(pb);       // 错误：D没有从B派生
    D* pd3 = reinterpret_cast<D*>(pb);  // 没问题：你要对此负责！
    D* pd4 = dynamic_cast<D*>(pb);      // 没问题：返回nullptr
    // ...
}
```

这个例子来源于真实世界的缺陷，在这个缺陷中，`D`曾经派生于`B`，但后来有人重构了层次结构。C风格的转型是危险的，因为它可以做任何种类的转换，剥夺了我们对（现在或未来的）错误的任何保护。

##### 注意

当类型之间的转换没有信息丢失时（例如从`float`到`double`，或者从`int32`到`int64`），可能会使用大括号初始化来代替。

```cpp
double d {some_float};
int64_t i {some_int32};
```

这使得类型转换的意图更清晰，而且避免了类型之间可能导致精度丢失的转换（例如，试图用`double`初始化`float`会出现编译错误）。

##### 注意

`reinterpret_cast`是低层的转型，但是低层的用法（例如把机器地址转成指针）并不是类型安全的：

```cpp
auto p = reinterpret_cast<Device_register>(0x800);  // 危险的
```

##### 实施

* 标记出C风格和函数式转型。
* 类型配置禁止了`reinterpret_cast`。
* 当在算术类型之间使用`static_cast`时，类型配置会发出警告。

### ES.50: 不要丢弃`const`

##### 理由

这制造了一个没有`const`的谎言。如果变量真的被声明为`const`，“丢弃`const`”的结果是未定义行为。

##### 示例，不好的

```cpp
void f(const int& i)
{
    const_cast<int&>(i) = 42;   // 不好的
}

static int i = 0;
static const int j = 0;

f(i); // 无声的副作用
f(j); // 未定义行为
```

##### 示例

有时，你可能会受到求助`const_cast`来避免代码重复的诱惑，例如，当两个只在`const`属性上不同的访问器函数有相似的实现时。例如：

```cpp
class Bar;

class Foo {
public:
    // 不好的，重复的逻辑
    Bar& get_bar() {
        /* 复杂的逻辑，获取my_bar的非const引用 */
    }

    const Bar& get_bar() const {
        /* 复杂的逻辑，获取my_bar的const引用 */
    }
private:
    Bar my_bar;
};
```

替代方案是，共享实现。通常，你可以简单地让非`const`函数调用`const`函数。然而，有时还是会存在复杂的逻辑导致下面这种仍然使用`const_cast`的模式：

```cpp
class Foo {
public:
    // 并不是很好，非const调用了const版本，但还是使用了const_cast
    Bar& get_bar() {
        return const_cast<Bar&>(static_cast<const Foo&>(*this).get_bar());
    }
    const Bar& get_bar() const {
        /* 复杂的逻辑，获取my_bar的const引用 */
    }
private:
    Bar my_bar;
};
```

在正确使用的情况下，这种模式是安全的，因为调用者必须首先有一个非`const`对象。即使如此，这也不是理想的做法，因为这个安全性难以作为检查器规则自动地保证。

替代方案是，把通用代码放到一个通用的辅助函数中——并且使其成为模板，以让它可以推导出`const`。这根本不会用到任何`const_cast`：

```cpp
class Foo {
public:                         // 好的
          Bar& get_bar()       { return get_bar_impl(*this); }
    const Bar& get_bar() const { return get_bar_impl(*this); }
private:
    Bar my_bar;

    template<class T>           // 好的，可以推导出T是const或非const
    static auto get_bar_impl(T& t) -> decltype(t.get_bar())
        { /* 复杂的逻辑，获取my_bar的引用，可能是const引用 */ }
};
```

##### 例外

当调用带有不正确`const`的函数时，你可能需要用转型去掉`const`。应把这些函数包装在一个内联的带有正确`const`的包装器中，把转型封装到一个地方。

##### 示例

有时，“丢弃`const`”允许更新一个在其它情况下是不可变的对象的一些瞬时信息。这方面的例子是缓存、记忆化和预计算。这些例子通常也使用`const_cast`来处理，或者使用了更好的`mutable`或间接访问。

考虑为开销大的操作保留上一次的计算结果：

```cpp
int compute(int x); // 计算x的值；假设这是开销大的

class Cache {   // 有些类型为int->int操作实现了缓存
public:
    pair<bool, int> find(int x) const;   // 是否有x的对应值？
    void set(int x, int y);             // 使y为x的对应值
    // ...
private:
    // ...
};

class X {
public:
    int get_val(int x)
    {
        auto p = cache.find(x);
        if (p.first) return p.second;
        int val = compute(x);
        cache.set(x, val); // 插入x的对应值
        return val;
    }
    // ...
private:
    Cache cache;
};
```

这里，`get_val()`在逻辑上是常量的，所以我们想让它为`const`成员。这样做之后我们仍然需要改变`cache`，所以人们有时会求助于`const_cast`：

```cpp
class X {   // 基于转型的值得怀疑的解决方法
public:
    int get_val(int x) const
    {
        auto p = cache.find(x);
        if (p.first) return p.second;
        int val = compute(x);
        const_cast<Cache&>(cache).set(x, val);   // 丑陋的
        return val;
    }
    // ...
private:
    Cache cache;
};
```

幸运的是，有一个更好的解决方法：把`cache`声明为可变的，即使对于`const`对象也是：

```cpp
class X {   // 更好的解决方法
public:
    int get_val(int x) const
    {
        auto p = cache.find(x);
        if (p.first) return p.second;
        int val = compute(x);
        cache.set(x, val);
        return val;
    }
    // ...
private:
    mutable Cache cache;
};
```

另一个可选的解决方法是保存指向`cache`的指针：

```cpp
class X {   // 没问题，但稍微有点凌乱的解决方法
public:
    int get_val(int x) const
    {
        auto p = cache->find(x);
        if (p.first) return p.second;
        int val = compute(x);
        cache->set(x, val);
        return val;
    }
    // ...
private:
    unique_ptr<Cache> cache;
};
```

这个解决方法是最灵活的，但需要显式地构造和析构`*cache`（很可能是在`X`的构造函数和析构函数中）。

在任何变种情况下，我们都必须防止`cache`在多线程代码下出现数据竞争，可能会使用`std::mutex`。

##### 实施

* 标记出`const_cast`。
* 该准则是相关配置中类型安全配置的一部分。

### ES.55: 避免进行范围检查

##### 理由

不会发生溢出的构件永远不会溢出（而且常常运行地更快）。

##### 示例

```cpp
for (auto& x : v)      // 打印出v的所有元素
    cout << x << '\n';

auto p = find(v, x);   // 在v中查找x
```

##### 实施

查找显式的范围检查，并且启发式地建议可选方案。

### ES.56: 只有当你需要显式地移动对象到另一个作用域时才使用`std::move()`

##### 理由

我们使用移动而不是拷贝来避免复制，以及提高性能。

移动一般会留下一个空对象（C.64），该对象可能会令人惊讶，甚至是危险的，因此我们尽量避免移动左值对象（它们稍后可能会被访问）。

##### 注意

当源对象是右值时，移动会隐式地执行，所以不要在那些情况下显式地使用`move`来让代码毫无意义地复杂化。相反，写出一个返回了值的简短函数，函数返回和调用者接收返回都会自然地被优化。

一般情况下，遵守这份文档中的指南（包括不要让变量的作用域不必要的大、写出会返回值的简短函数、返回局部变量）有助于消除大部分显式使用`std::move`的需要。

显式的`move`用来显式地移动对象到另一个作用域，尤其是用于把对象传递给一个“接收器”函数，以及在移动操作自身（移动构造函数、移动赋值操作符）的实现中，还有交换操作中。

##### 示例，不好的

```cpp
void sink(X&& x);   // sink接管x的所有权

void user()
{
    X x;
    // 错误：不能把左值绑定到右值
    sink(x);
    // 没问题：sink取走了x的内容，x现在必须假设是空的
    sink(std::move(x));

    // ...

    // 可能是一个错误
    use(x);
}
```

通常，`std::move()`用来传递给`&&`参数。在你这样做之后，要认为对象已经被移走（参阅C.64），并且不要再读取它的状态，直到你首次给它设置新的值。

```cpp
void f() {
    string s1 = "supercalifragilisticexpialidocious";

    string s2 = s1;             // 没问题，取一份拷贝
    assert(s1 == "supercalifragilisticexpialidocious");  // 没问题

    // 不好的，如果你想继续使用s1的值
    string s3 = move(s1);

    // 不好的，断言很可能失败，s1很可能被修改了
    assert(s1 == "supercalifragilisticexpialidocious");
}
```

##### 示例

```cpp
void sink(unique_ptr<widget> p);  // 传递p的所有权给sink()

void f() {
    auto w = make_unique<widget>();
    // ...
    sink(std::move(w));               // 没问题，给了sink()
    // ...
    sink(w);    // 错误：unique_ptr经过谨慎的设计，因此你不能拷贝它
}
```

##### 注意

`std::move()`是转型到`&&`的伪装；它自身不会移动任何东西，只是把一个具名对象标记成可以被移走的候选对象。语言已经知道对象可以被移走的常见情况，特别是从函数中返回值时，因此不要用冗余的`std::move()`使代码复杂化。

永远不要只是因为你听说“它更高效”而使用`std::move`。一般情况下，不要相信没有数据的“效率”宣言（???）。一般情况下，不要在没有理由的情况下使你的代码复杂化（???）。

##### 示例，不好的

```cpp
vector<int> make_vector() {
    vector<int> result;
    // ... 用数据填充result
    return std::move(result);       // 不好的：只写“return result;”就行了
}
```

永远不要写`return move(local_variable);`，因为语言已经知道变量是移动的候选者。在这个代码中写`move`没有帮助，而且实际上可能会有损害，因为在一些编译器上它创建了一个额外的对局部变量的引用别名，妨碍了RVO（返回值优化）。

##### 示例，不好的

```cpp
vector<int> v = std::move(make_vector());   // 不好的：std::move完全是冗余的
```

永远不要在已返回的值上写`move`，例如`x = move(f());`，`f`以值返回。语言已经知道返回值是临时对象，可以被移走。

##### 示例

```cpp
void mover(X&& x) {
    call_something(std::move(x));         // 没问题
    call_something(std::forward<X>(x));   // 不好的，不要在右值引用上使用std::forward
    call_something(x);                    // 可疑的，为什么不用std::move？
}

template<class T>
void forwarder(T&& t) {
    call_something(std::move(t));         // 不好的，不要在转发引用上使用std::move
    call_something(std::forward<T>(t));   // 没问题
    call_something(t);                    // 可疑的，为什么不用std::forward？
}
```

##### 实施

* 标记出`std::move(x)`的使用，其中`x`是一个右值，或者语言已将其视为右值，包括`return std::move(local_variable);`，以及在以值返回的函数上的`std::move(f())`。
* 标记出接受`S&&`参数的函数，如果没有`const S&`的重载来处理左值的话。
* 标记出`std::move`参数，除非参数类型是以下几种：`X&&`右值引用；`T&&`转发引用，其中`T`是模板参数类型；或者按值传递并且被传递类型只能移动。
* 标记出用在转发引用（即`T&&`，其中`T`是模板参数类型）上的`std::move`。使用`std::forward`代替。
* 标记出用在非右值引用上的`std::move`（上一条规则的更通用情况，以覆盖非转发的情况）。
* 标记出用在右值引用（即`X&&`，其中`X`是具体类型）上的`std::forward`。使用`std::move`代替。
* 标记出用在非转发引用上的`std::forward`。（上一条规则的更通用情况，以覆盖非移动的情况）
* 标记出对象可能被移走后，对它的下一个操作是`const`操作的情况；这里首先应该有一个非`const`操作介入，理想的是一个赋值操作，来首次重设对象的值。

### ES.60: 避免在资源管理函数外部使用`new`和`delete`

##### 理由

在应用代码中直接的资源管理是容易出错且冗长的。

##### 注意

也被称为“没有裸露的`new`！”。

##### 示例，不好的

```cpp
void f(int n)
{
    auto p = new X[n];   // n个默认构造的X
    // ...
    delete[] p;
}
```

在`...`部分可能存在一些代码导致`delete`永远不会执行。

**另见**：R: 资源管理

##### 实施

标记出裸露的`new`和裸露的`delete`。

### ES.61: 使用`delete[]`删除数组以及使用`delete`删除非数组

##### 理由

这是语言要求的，错误的用法会导致资源释放错误以及/或者内存损坏。

##### 示例，不好的

```cpp
void f(int n)
{
    auto p = new X[n];   // n个默认构造的X
    // ...
    delete p;   // 错误：只是删除对象p，而不是删除数组p[]
}
```

##### 注意

这个例子不仅违反了上一个示例的没有裸露的`new`准则，它还有更多的问题。

##### 实施

* 如果`new`和`delete`在同一个作用域中，可以标记出其中的错误用法。
* 如果`new`和`delete`在构造函数/析构函数对中，可以标记出其中的错误用法。

### ES.62: 不要比较指向不同数组的指针

##### 理由

这样做的结果是未定义的。

##### 示例，不好的

```cpp
void f(int n)
{
    int a1[7];
    int a2[9];
    if (&a1[5] < &a2[7]) {}       // 不好的：未定义
    if (0 < &a1[5] - &a2[7]) {}   // 不好的：未定义
}
```

##### 注意

这个例子有很多问题。

##### 实施

???

### ES.63: 不要发生对象切割

##### 理由

对象切割——即通过赋值或初始化只拷贝对象的一部分——这通常会导致错误，因为对象被认为是一个整体。在罕见的情况下，有意使用对象切割的代码是令人惊讶的。

##### 示例

```cpp
class Shape { /* ... */ };
class Circle : public Shape { /* ... */ Point c; int r; };

Circle c {{0, 0}, 42};
Shape s {c};    // 拷贝Circle的Shape部分
```

这个结果是无意义的，因为中点和半径不会从`c`拷贝到`s`。对此的第一个防御是在定义基类`Shape`的时候不允许这样做。

##### 替代方案

如果你想要切割，定义一个显式的操作来执行。这样可以减少读者的困惑。例如：

```cpp
class Smiley : public Circle {
    public:
    Circle copy_circle();
    // ...
};

Smiley sm { /* ... */ };
Circle c1 {sm};  // 理想地被Circle的定义阻止了
Circle c2 {sm.copy_circle()};
```

##### 实施

对对象切割进行警告。

### ES.64: 使用`T{e}`表示法来构造

##### 理由

`T{e}`构造语法显式地说明构造是期望的操作。`T{e}`构造语法不允许收缩转换。`T{e}`是唯一安全和通用的表达式来用表达式`e`构造类型`T`的值。转型表示法`T(e)`和`(T)e`都不是安全和通用的。

##### 示例

对于内置类型，这个构造表示法可以防止收缩转换和重新解析：

```cpp
void use(char ch, int i, double d, char* p, long long lng)
{
    int x1 = int{ch};     // 没问题，但是啰嗦
    int x2 = int{d};      // 错误：double->int收缩转换；如果你需要的话使用转型
    int x3 = int{p};      // 错误：指针->int；如果你真的需要的话使用reinterpret_cast
    int x4 = int{lng};    // 错误：long long->int收缩转换；如果你需要的话使用转型

    int y1 = int(ch);     // 没问题，但是啰嗦
    int y2 = int(d);      // 不好的：double->int收缩转换；如果你需要的话使用转型
    int y3 = int(p);      // 不好的：指针->int；如果你真的需要的话使用reinterpret_cast
    int y4 = int(lng);    // 不好的：long long->int收缩转换；如果你需要的话使用转型

    int z1 = (int)ch;     // 没问题，但是啰嗦
    int z2 = (int)d;      // 不好的：double->int收缩转换；如果你需要的话使用转型
    int z3 = (int)p;      // 不好的：指针->int；如果你真的需要的话使用reinterpret_cast
    int z4 = (int)lng;    // 不好的：long long->int收缩转换；如果你需要的话使用转型
}
```

当使用`T(e)`或`(T)e`表示法的时候，整型和指针之间的转换是由实现定义的，而且在具有不同整型和指针大小的平台之间不具备可移植性。

##### 注意

避免转型（显式类型转换），如果你必须要这样做，优先使用具名的转型。

##### 注意

当没有歧义的时候，`T`可以从`T{e}`中去掉。

```cpp
complex<double> f(complex<double>); 

auto z = f({2*pi, 1});
```

##### 注意

这个构造表示法是最普遍的初始化器表示法。

##### 例外

`std::vector`和其它容器在我们拥有`{}`作为构造表示法之前就已经定义了。考虑以下代码：

```cpp
vector<string> vs {10};                           // 10个空字符串
vector<int> vi1 {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};  // 10个元素，从1到10
vector<int> vi2 {10};                             // 1个元素，值为10
```

我们如何得到含有10个被默认初始化的`int`的`vector`？

```cpp
vector<int> v3(10); // 值为0的10个元素
```

在元素数量上使用`()`而不是`{}`是传统习惯（回到1980年代初），这很难改变，但仍然是一个设计错误：对于元素类型会与元素数量发生混淆的容器，我们有一个必须要解决的歧义。传统的解决方法是把`{10}`解析为只有一个元素的列表，并且使用`(10)`来区分大小。

在新的代码中不需要重复犯这个错误。我们可以定义一个类型来表示元素的数量：

```cpp
struct Count { int n; };

template<typename T>
class Vector {
public:
    Vector(Count n);                     // n个默认初始化的元素
    Vector(initializer_list<T> init);    // init.size()个元素
    // ...
};

Vector<int> v1{10};
Vector<int> v2{Count{10}};
Vector<Count> v3{Count{10}};    // 是的，仍然有一个非常小的问题
```

剩下的主要问题是为`Count`找一个合适的名称。

##### 实施

标记出C风格的`(T)e`和函数式风格的`T(e)`转型。

### ES.65: 不要解引用无效的指针

##### 理由

解引用无效的指针，例如`nullptr`，是未定义的行为，通常会导致立即的崩溃，错误的结果，或者内存损坏。

##### 注意

这个准则是显然的，并且广为人知的语言准则，但很难遵守。它需要良好的编码风格、库支持、以及静态分析在没有重大开销的情况下消除违规行为。这是关于C++资源和类型安全模型讨论的主要部分。

**另见**：

* 使用[RAII]避免生命周期问题。
* 使用[unique_ptr]避免生命周期问题。
* 使用[shared_ptr]避免生命周期问题。
* 当`nullptr`不是可能的取值时，使用引用。
* 使用`not_null`来尽早捕捉非预期的`nullptr。
* 使用边界配置来避免范围错误。

##### 示例

```cpp
void f()
{
    int x = 0;
    int* p = &x;

    if (condition()) {
        int y = 0;
        p = &y;
    } // p变成无效值

    *p = 42;            // 糟糕，如果分支执行了，p是无效的
}
```

为了解决这个问题，可以延长指针指向对象的生命周期，或者缩短指针的生命周期（把解引用移动到被指向对象的生命周期结束之前）。

```cpp
void f1()
{
    int x = 0;
    int* p = &x;

    int y = 0;
    if (condition()) {
        p = &y;
    }

    *p = 42;            // 没问题，p指向x或者y，两者仍在作用域中
}
```

不幸的是，大部分无效指针问题更难定位，更难修复。

##### 示例

```cpp
void f(int* p)
{
    int x = *p; // 不好的：我们怎么知道p是有效的？
}
```

有大量这样的代码存在。大部分能工作——经过许多测试之后——但孤立来看，这不可能说明`p`是否可能为`nullptr`。因此，这也是错误的主要来源。有许多方法来处理这个潜在的问题：

```cpp
void f1(int* p) // 处理nullptr
{
    if (!p) {
        // 处理nullptr（分配、返回、抛异常、让p指向某些东西，都可以）
    }
    int x = *p;
}
```

检测是否为`nullptr`存在两个潜在问题：

* 如果我们找到了`nullptr`，需要做些什么事情？这并不总是清晰的。
* 检测可能是冗余的，并且/可能相对来说开销更大。
* 检测是用来防止违规还是所需逻辑的一部分，这是不清晰的。

```cpp
void f2(int* p) // 声明p不应该为nullptr
{
    assert(p);
    int x = *p;
}
```

这只会在断言检查开启之后才会带来开销，而且能给编译器/分析器带来有用的信息。如果/当C++获得了契约的直接支持，这甚至能执行得更好：

```cpp
void f3(int* p) // 声明p不应该为nullptr
    [[expects: p]]
{
    int x = *p;
}
```

另外，我们可以使用`gsl::not_null`来确保`p`不为`nullptr`。

```cpp
void f(not_null<int*> p)
{
    int x = *p;
}
```

这些补救措施只处理`nullptr`。要记住还有其它途径可以得到无效的指针。

##### 示例

```cpp
void f(int* p)  // 旧代码，不使用owner
{
    delete p;
}

void g()        // 旧代码：使用裸露的new
{
    auto q = new int{7};
    f(q);
    int x = *q; // 糟糕：解引用无效指针
}
```

##### 示例

```cpp
void f()
{
    vector<int> v(10);
    int* p = &v[5];
    v.push_back(99); // 可能重新分配v的元素
    int x = *p; // 糟糕：解引用了可能无效的指针
}
```

##### 实施

这个准则是生命周期配置的一部分。

* 标记出对指针的解引用，该指针指向的对象已经超出了作用域。
* 标记出对指针的解引用，该指针可能已经被赋值为`nullptr`而失效。
* 标记出对指针的解引用，该指针可能已经被`delete`删除而失效。
* 标记出对指针的解引用，该指针指向容器元素，而该元素可能已经被解引用而失效。

## ES.stmt: 语句

语句控制了代码的控制流（除了函数调用和异常抛出，这些是表达式）。

### ES.70: 当可以选择的时候，优先使用`switch`语句而不是`if`语句

##### 理由

* 可读性。
* 效率：`switch`与常量进行比较，通常比`if`-`then`-`else`链路中的一系列检测有更好的优化。
* `switch`可以启用一些启发式的一致性检查。例如，是否`enum`中的所有值都覆盖了？如果不是，是否有`default`？

##### 示例

```cpp
void use(int n)
{
    switch (n) {   // 好的
    case 0:   // ...
    case 7:   // ...
    }
}
```

而不是：

```cpp
void use2(int n)
{
    if (n == 0)   // 不好的：if-then-else链路与一系列常量进行比较
        // ...
    else if (n == 7)
        // ...
}
```

##### 实施

标记出（只）检查常量的`if`-`then`-`else`链路。

### ES.71: 当可以选择的时候，优先使用基于范围的`for`语句而不是普通的`for`语句

##### 理由

可读性。避免出错。效率。

##### 示例

```cpp
for (gsl::index i = 0; i < v.size(); ++i)   // 不好的
        cout << v[i] << '\n';

for (auto p = v.begin(); p != v.end(); ++p)   // 不好的
    cout << *p << '\n';

for (auto& x : v)    // 没问题
    cout << x << '\n';

for (gsl::index i = 1; i < v.size(); ++i) // 访问两个元素：不能使用基于范围的for
    cout << v[i] + v[i - 1] << '\n';

for (gsl::index i = 0; i < v.size(); ++i) // 可能有副作用：不能使用基于范围的for
    cout << f(v, &v[i]) << '\n';

for (gsl::index i = 0; i < v.size(); ++i) { // 循环体与循环变量混杂：不能使用基于范围的for
    if (i % 2 == 0)
        continue;   // skip even elements
    else
        cout << v[i] << '\n';
}
```

人或者好的静态分析器可以知道`f(v, &v[i])`实际上对`v`没有副作用，所以这个循环可以重写。

在循环体中，最好避免“与循环变量混杂”。

##### 注意

不要在基于范围的`for`循环中使用昂贵的循环变量拷贝：

```cpp
for (string s : vs) // ...
```

这会把`vs`中的每个元素拷贝到`s`。更好的做法是：

```cpp
for (string& s : vs) // ...
```

仍然有更好的做法，如果循环变量不被修改或拷贝：

```cpp
for (const string& s : vs) // ...
```

##### 实施

查看循环，如果一个传统的循环只是按顺序地访问每个元素，并且它对元素做的事情没有副作用，那么把这个循环重写成基于范围的`for`循环。

### ES.72: 当存在明显的循环变量时，优先使用`for`语句而不是`while`语句

##### 理由

可读性：循环的完整逻辑是“预先”可见的。循环变量的作用域可以被限制。

##### 示例

```cpp
for (gsl::index i = 0; i < vec.size(); i++) {
    // 做事情
}
```

##### 示例，不好的

```cpp
int i = 0;
while (i < vec.size()) {
    // 做事情
    i++;
}
```

##### 实施

???

### ES.73: 当不存在明显的循环变量时，优先使用`while`语句而不是`for`语句

##### 理由

可读性。

##### 示例

```cpp
int events = 0;
for (; wait_for_event(); ++events) {  // 不好的，令人困惑
    // ...
}
```

这个“事件循环”是有误导性的，因为`events`计数器与循环条件（`wait_for_event()`）没有关系。更好的做法：

```cpp
int events = 0;
while (wait_for_event()) {      // 好多了
    ++events;
    // ...
}
```

##### 示例

标记出与`for`条件无关的`for`初始化和`for`增量行为。

### ES.74: 优先在`for`语句的初始化器部分声明循环变量

##### 理由

限制循环变量的可见性只在循环的作用域内。避免循环变量在循环之后用于其它目的。

##### 示例

```cpp
for (int i = 0; i < 100; ++i) {   // 好的：变量i只在循环内可见
        // ...
    }
```

##### 示例，不要这样做

```cpp
int j;                            // 不好的：j在循环外可见
for (j = 0; j < 100; ++j) {
    // ...
}
// j在这里仍然可见，这是不需要的
```

**另见**：不要为两个不相关的目的使用同一个变量。

##### 示例

```cpp
for (string s; cin >> s; ) {
    cout << s << '\n';
}
```

##### 实施

当一个会在`for`语句内修改的变量声明于循环外部，并且没有在循环外使用时，进行警告。

**讨论**：把循环变量的作用域限制在循环体内对代码优化也有很大帮助。识别出这个只能在循环体内访问的变量可以进行一些优化，例如，提升、强度降低、循环不变式代码移动等。

### ES.75: 避免`do`语句

##### 理由

可读性，避免出错。循环的终结条件在末尾（可能会看漏），并且这个条件在第一次执行的时候没有检查。

##### 示例

```cpp
int x;
do {
    cin >> x;
    // ...
} while (x < 0);
```

##### 注意

没错，存在一些真实的例子，在这些例子中`do`语句是解决问题的清晰语句，但同时也有许多缺陷。

##### 实施

标记出`do`语句。

### ES.76: 避免`goto`

##### 理由

可读性，避免出错。对人们来说有更好的控制结构；`goto`是用于机器生成的代码。

##### 例外

跳出内嵌的循环。在这种情况下，总是向前跳。

```cpp
for (int i = 0; i < imax; ++i)
    for (int j = 0; j < jmax; ++j) {
        if (a[i][j] > elem_max) goto finished;
        // ...
    }
finished:
// ...
```

##### 示例，不好的

有很多地方使用C的goto-exit惯用法：

```cpp
void f()
{
    // ...
        goto exit;
    // ...
        goto exit;
    // ...
exit:
    // ... 通用的清理代码 ...
}
```

这是对析构函数的模拟。把你的资源声明为带有析构函数的句柄，在析构函数中做清理。如果由于某些原因，你不能为所使用的变量在析构函数中处理所有清理，考虑使用`gsl::finally()`作为清理器，这是比`goto exit`更可靠的替代方案。

##### 实施

* 标记出`goto`。最好是标记出所有没有从内嵌循环跳到紧随内嵌循环的语句的`goto`。

### ES.77: 最小化循环中`break`和`continue`的使用

##### 理由

在一个有相当内容的循环体中，容易看漏`break`或`continue`。

在循环中的`break`与`switch`语句中的`break`有显著不同的含义（而且你可能会在循环中使用`switch`，或在`switch`的`case`中使用循环）。

##### 示例

```cpp
???
```

##### 替代方案

通常，需要用到`break`的循环是抽取成函数（算法）的很好的候选者，这时`break`会变成`return`。

```cpp
???
```

通常，使用`continue`的循环可以等价且同样清晰地用`if`语句表示。

```cpp
???
```

##### 注意

如果你真的需要跳出循环，`break`通常比其它方法更好，例如修改循环变量或者`goto`。

##### 实施

???

### ES.78: 总是用`break`结束不为空的`case`

##### 理由

意外地遗漏了`break`是相当常见的缺陷。故意让执行流穿过给维护带来危险。

##### 示例

```cpp
switch (eventType) {
case Information:
    update_status_bar();
    break;
case Warning:
    write_event_log();
    // 不好的——隐式地穿过
case Error:
    display_error_window();
    break;
}
```

执行流穿过很容易被看漏。要清楚地说明：

```cpp
switch (eventType) {
case Information:
    update_status_bar();
    break;
case Warning:
    write_event_log();
    // fallthrough
case Error:
    display_error_window();
    break;
}
```

在C++17中，使用`[[fallthrough]]`标注：

```cpp
switch (eventType) {
case Information:
    update_status_bar();
    break;
case Warning:
    write_event_log();
    [[fallthrough]];        // C++17
case Error:
    display_error_window();
    break;
}
```

##### 注意

单个语句的多个`case`标签是没问题的：

```cpp
switch (x) {
case 'a':
case 'b':
case 'f':
    do_something(x);
    break;
}
```

##### 实施

标记出所有非空`case`中执行流的穿过。

### ES.79: （只）使用`default`来处理通用情况

##### 理由

代码清晰性。增加错误检测的机会。

##### 示例

```cpp
enum E { a, b, c , d };

void f1(E x)
{
    switch (x) {
    case a:
        do_something();
        break;
    case b:
        do_something_else();
        break;
    default:
        take_the_default_action();
        break;
    }
}
```

这里清楚地表明有一个默认的行为，以及`a`和`b`两个特殊行为。

##### 示例

但是，如果没有默认行为，而你只想处理特定情况的话怎么办呢？在这种情况下，添加一个空的`default`，否则不可能知道你是否想处理所有情况：

```cpp
void f2(E x)
{
    switch (x) {
    case a:
        do_something();
        break;
    case b:
        do_something_else();
        break;
    default:
        // 对于余下的情况什么也不做
        break;
    }
}
```

如果你遗漏了`default`，维护的人以及/或者编译器可能会合理地假设你想处理所有情况：

```cpp
void f2(E x)
{
    switch (x) {
    case a:
        do_something();
        break;
    case b:
    case c:
        do_something_else();
        break;
    }
}
```

你是忘记了`d`情况还是故意忽略它呢？忘记处理情况通常发生在枚举中添加了值，而添加的人没有在每个对应的`switch`中也添加。

##### 实施

标记出作用于枚举上的`switch`语句，该语句没有处理所有枚举值，而且也没有`default`。这可能会在一些代码库中产生很多误报；如果是这样的话，只标记那些处理了大部分但不是所有情况的`switch`（这是首个C++编译器的策略）。

### ES.84: 不要（试图）声明没有名称的局部变量

##### 理由

不存在这样的东西。人们看起来像是没有名称的变量的东西，对于编译器来说是由临时变量组成的语句，这些临时变量会立即超出作用域。为了避免不愉快的意外。

##### 示例，不好的

```cpp
void f()
{
    lock<mutex>{mx};   // 不好的
    // ...
}
```

这里声明了一个没有名称的`lock`对象，它会立即在分号的地方超出作用域。这并非是不常见的错误。尤其是，这个特殊的例子会导致难以发现的竞态条件。这个“惯用法”有非常聪明的用途，但它们远远比错误罕见得多。

##### 注意

没有名称的函数参数是没问题的。

##### 实施

标记出仅仅是一个临时变量的语句。

### ES.85: 使空语句可见

##### 理由

可读性。

##### 示例

```cpp
for (i = 0; i < max; ++i);   // 不好的：空语句容易看漏
v[i] = f(v[i]);

for (auto x : v) {           // 好多了
    // 什么都不做
}
v[i] = f(v[i]);
```

##### 实施

标记出不是语句块而且不包含注释的空语句。

### ES.86: 避免在原始`for`循环的循环体中修改循环控制变量

##### 理由

在开头的循环控制应该能够正确地说明循环内部发生了什么事情。同时在迭代表达式和在循环体内修改循环计数是意外和缺陷的经常性来源。

##### 示例

```cpp
for (int i = 0; i < 10; ++i) {
    // 没有修改i——没问题
}

for (int i = 0; i < 10; ++i) {
    //
    if (/* something */) ++i; // 不好的
    //
}

bool skip = false;
for (int i = 0; i < 10; ++i) {
    if (skip) { skip = false; continue; }
    //
    if (/* something */) skip = true;  // 好多了：为两个概念使用两个变量
    //
}
```

##### 实施

标记出在循环控制的迭代表达式和循环体中会被同时修改的变量。

### ES.87: 不要在条件中添加冗余的`==`或`!=`

##### 理由

这样做可以避免冗长，并且消除一些出错的可能。有助于让代码风格保持一致，以及符合使用习惯。

##### 示例

根据定义，`if`语句、`while`语句和`for`语句中的条件在`true`和`false`之间进行选择。数值会与`0`比较，指针值会与`nullptr`比较。

```cpp
// 这里全部的意思都是“如果`p`不为`nullptr`”
if (p) { ... }            // 好的
if (p != 0) { ... }       // 冗余的`!=0`；不好的：不要对指针使用0
if (p != nullptr) { ... } // 冗余的`!=nullptr`，不建议
```

通常，`if (p)`读作“如果`p`是有效的”，这是对程序员意图的直接表达，而`if (p != nullptr)`是啰嗦的方式。

##### 示例

当声明用作条件时，这个准则特别有用：

```cpp
if (auto pc = dynamic_cast<Circle>(ps)) { ... } // 当ps指向一种Circle时执行条件分支，不错

if (auto pc = dynamic_cast<Circle>(ps); pc != nullptr) { ... } // 不建议
```

##### 示例

注意，在条件中会执行到布尔值的隐式转换。例如：

```cpp
for (string s; cin >> s; ) v.push_back(s);
```

这会调用`istream`的`operator bool()`。

##### 注意

显式地与整型值`0`进行比较通常不是冗余的。原因是（与指针和布尔值相比）一个整数通常有多于两个的合理值。而且`0`（零）通常用于表示成功。所以，最好是明确表明这个比较。

```cpp
void f(int i)
{
    if (i)            // 可疑的
    // ...
    if (i == success) // 可能更好
    // ...
}
```

总是要记住整数会有超过两个的值。

##### 示例，不好的

有个要注意的地方是：

```cpp
if(strcmp(p1, p2)) { ... }   // 两个C风格的字符串是否相等？（错误！）
```

这是常见的初学者错误。如果你使用C风格字符串，你必须同时了解`<cstring>`中的函数。冗长地把比较写出来：

```cpp
if(strcmp(p1, p2) != 0) { ... }   // 两个C风格的字符串是否相等？（错误！）
```

这本身并不能拯救你。

##### 注意

使用取反最容易表示相反的条件：

```cpp
// These all mean "if `p` is `nullptr`"
if (!p) { ... }           // 好的
if (p == 0) { ... }       // 冗余的`== 0`；不好的：不要对指针使用`0`
if (p == nullptr) { ... } // 冗余的`== nullptr`，不建议
```

##### 实施

简单，只要检查在条件中使用的冗余的`!=`和`==`即可。

## 算术

### ES.100: 不要混合有符号和无符号算术

##### 理由

避免错误的结果。

##### 示例

```cpp
int x = -3;
unsigned int y = 7;

cout << x - y << '\n';  // 无符号结果，可能是4294967286
cout << x + y << '\n';  // 无符号结果：4
cout << x * y << '\n';  // 无符号结果，可能是4294967275
```

在更实际的例子中，更加难以定位问题。

##### 注意

不幸的是，C++使用有符号整数作为数组下标，而标准库使用无符号整数作为容器下标。这阻碍了一致性。应使用`gsl::index`作为下标；参阅ES.107。

##### 实施

* 编译器已经知道这些情况，并且有时会发出警告。
* （为了避免干扰，）在混合了有符号/无符号的比较中，如果其中一个参数是`sizeof`或者是对容器`.size()`的调用，并且另一个参数是`ptrdiff_t`时，不要标记出来。

### ES.101: 对位操作使用无符号类型

##### 理由

在无符号类型上的位操作不会出现由符号位导致的意外情况。

##### 示例

```cpp
unsigned char x = 0b1010'1010;
unsigned char y = ~x;   // y == 0b0101'0101;
```

##### 注意

无符号类型对摸运算也是有用的。但是，如果你想使用模运算，要根据需要添加注释，注明对回绕行为的依赖，因为这样的代码对很多程序员来说都是令人惊讶的。

##### 实施

* 通常几乎是不可能的，因为在标准库中使用无符号的下标。
* ???

### ES.102: 对算术使用有符号类型

##### 理由

因为大部分算术都认为是有符号的；当`y > x`时，`x - y`会得到负数，除非在罕见的情况下你真的想要进行摸运算。

##### 示例

无符号运算会得到意外的结果，如果这不是你预期的话。当混合了有符号和无符号运算时，这一点更加突出。

```cpp
template<typename T, typename T2>
T subtract(T x, T2 y)
{
    return x - y;
}

void test()
{
    int s = 5;
    unsigned int us = 5;
    cout << subtract(s, 7) << '\n';       // -2
    cout << subtract(us, 7u) << '\n';     // 4294967294
    cout << subtract(s, 7u) << '\n';      // -2
    cout << subtract(us, 7) << '\n';      // 4294967294
    cout << subtract(s, us + 2) << '\n';  // -2
    cout << subtract(us, s + 2) << '\n';  // 4294967294
}
```

在这里我们非常清楚会发生什么，但是假如你见到`us - (s + 2)`或者`s += 2; ...; us - s`时，你会有把握地认为结果会打印出`4294967294`吗？

##### 例外

如果你真的想要摸运算，使用无符号类型——根据需要添加注释，注明对溢出行为的依赖，因为这样的代码对很多程序员来说都是令人惊讶的。

##### 示例

标准库使用无符号类型作为下标。内置数组使用有符号类型作为下标。这不可避免地导致意外（和缺陷）。

```cpp
int a[10];
for (int i = 0; i < 10; ++i) a[i] = i;
vector<int> v(10);
// 比较有符号数和无符号数；有些编译器会警告，但我们应该不会
for (gsl::index i = 0; v.size() < 10; ++i) v[i] = i;

int a2[-2];         // 错误：负的大小

// 可以，但是整数的值（4294967294）太大，我们应该会得到异常
vector<int> v2(-2);
```

使用`gsl::index`作为下标；参阅ES.107。

##### 实施

* 标记出混合有符号和无符号的算术。
* 标记出作为有符号数来赋值或打印的无符号运算结果。
* 标记出用作容器下标的无符号字面量（例如`-2`）。
* （为了避免干扰，）在混合了有符号/无符号的比较中，如果其中一个参数是`sizeof`或者是对容器`.size()`的调用，并且另一个参数是`ptrdiff_t`时，不要标记出来。

## ES.103: 不要溢出

##### 理由

溢出一般会导致你的数值算法无意义。把数值增加到超出最大值会导致内存损坏和未定义行为。

##### 示例，不好的

```cpp
int a[10];
a[10] = 7;   // 不好的

int n = 0;
while (n++ < 10)
    a[n - 1] = 9; // 不好的（两次）
```

##### 示例，不好的

```cpp
int n = numeric_limits<int>::max();
int m = n + 1;   // 不好的
```

##### 示例，不好的

```cpp
int area(int h, int w) { return h * w; }

auto a = area(10'000'000, 100'000'000);   // 不好的
```

##### 例外

如果你真的想要摸运算，使用无符号类型。

**可选方案**：对于可以承受一些开销的重要程序，使用能够检查范围整数以及/或者浮点数类型。

##### 实施

???

### ES.104: 不要下溢

##### 理由

把数值减少到超出最小值会导致内存损坏和未定义行为。

##### 示例，不好的

```cpp
int a[10];
a[-2] = 7;   // 不好的

int n = 101;
while (n--)
    a[n - 1] = 9;   // 不好的（两次）
```

##### 例外

如果你真的想要模运算，使用无符号类型。

##### 实施

???

### ES.105: 不要除以0

##### 理由

这样做的结果是未定义的，很可能是崩溃。

##### 注意

这同样适用于`%`。

##### 示例；不好的

```cpp
double divide(int a, int b) {
    // 不好的，应该检查一下参数（例如在前置条件中）
    return a / b;
}
```

##### 示例；好的

```cpp
double divide(int a, int b) {
    // 好的，通过前置条件来定位（并且一旦C++支持的话可以替换成契约）
    Expects(b != 0);
    return a / b;
}

double divide(int a, int b) {
    // 好的，通过检查来定位
    return b ? a / b : quiet_NaN<double>();
}
```

**可选方案**：对于可以承受一些开销的重要程序，使用能够检查范围整数以及/或者浮点数类型。

##### 实施

* 标记整数除法，其中的除数可能为0。

### ES.106: 不要试图通过使用`unsigned`来避免负值

##### 理由

选择`unsigned`意味着会对整数的常见行为，包括模运算，带来许多改变，会隐藏掉与溢出相关的警告，以及为有符号/无符号混合相关的错误打开了大门。使用`unsigned`实际上并没有消除负值的可能性。

##### 示例

```cpp
unsigned int u1 = -2;   // 有效的：u1的值是4294967294
int i1 = -2;
unsigned int u2 = i1;   // 有效的：u2的值是4294967294
int i2 = u2;            // 有效的：i2的值是-2
```

包含这类（完全合法的）结构的问题在实际代码中难以定位，而且是许多现实错误的来源。考虑以下代码：

```cpp
unsigned area(unsigned height, unsigned width) { 
    return height*width; 
} // [参阅](#Ri-expects)
// ...
int height;
cin >> height;
auto a = area(height, 2);   // 如果输入是-2，a变成4294967292
```

记住，当`-1`赋值给`unsigned int`时，会变成最大的`unsigned int`。同时，由于无符号运算是模运算，它的操作不会溢出，只是回绕。

##### 示例

```cpp
unsigned max = 100000;    // “意外的拼写错误”，我想要指定10'000
unsigned short x = 100;
while (x < max) x += 100; // 无限循环
```

如果`x`是一个有符号的`short`，我们会收到溢出导致未定义行为的警告。

##### 可选方案

* 使用有符号整数并且检查`x >= 0`
* 使用正整数类型
* 使用整数子范围类型
* `Assert(-1 < x)`

例如：

```cpp
struct Positive {
    int val;
    Positive(int x) :val{x} { Assert(0 < x); }
    operator int() { return val; }
};

int f(Positive arg) { return arg; }

int r1 = f(2);
int r2 = f(-2);  // throws
```

##### 注意

???

##### 实施

困难：有很多代码正在使用`unsigned`，而且我们没有提供一个切实可行的正数类型。

### ES.107: 不要使用`unsigned`作为下标，优先使用`gsl::index`

##### 理由

为了避免有符号/无符号的困扰。为了启用更好的优化。为了启用更好的错误检测。为了避免`auto`和`int`的陷阱。

##### 示例，不好的

```cpp
vector<int> vec = /*...*/;

for (int i = 0; i < vec.size(); i += 2)                    // 可能不够大
    cout << vec[i] << '\n';
for (unsigned i = 0; i < vec.size(); i += 2)               // 有回绕的风险
    cout << vec[i] << '\n';
for (auto i = 0; i < vec.size(); i += 2)                   // 可能不够大
    cout << vec[i] << '\n';
for (vector<int>::size_type i = 0; i < vec.size(); i += 2) // 啰嗦的
    cout << vec[i] << '\n';
for (auto i = vec.size()-1; i >= 0; i -= 2)                // 有问题
    cout << vec[i] << '\n';
for (int i = vec.size()-1; i >= 0; i -= 2)                 // 可能不够大
    cout << vec[i] << '\n';
```

##### 示例，好的

```cpp
vector<int> vec = /*...*/;

for (gsl::index i = 0; i < vec.size(); i += 2)             // 没问题
    cout << vec[i] << '\n';
for (gsl::index i = vec.size()-1; i >= 0; i -= 2)          // 没问题
    cout << vec[i] << '\n';
```

##### 注意

内置数组使用有符号数作为下标。标准库容器使用无符号数作为下标。因此，不可能存在完美且完全兼容的解决方案（除非并且直到标准库容器在将来的某天改成使用有符号数作为下标）。对于已知的无符号数以及有符号数/无符号数混合问题，最好是使用足够大小的（有符号）整数来解决，这是通过`gsl::index`来保证的。

##### 示例

```cpp
template<typename T>
struct My_container {
public:
    // ...
    T& operator[](gsl::index i);    // 不是无符号数
    // ...
};
```

##### 示例

```cpp
??? 演示经过改进的代码生成以及错误检测的可能 ???
```

##### 可选方案

给用户的可选方案：

* 使用算法
* 使用基于范围的for
* 使用迭代器/指针

##### 实施

* 只要标准库容器有错误，就会非常棘手。
* （为了避免干扰，）在混合了有符号/无符号的比较中，如果其中一个参数是`sizeof`或者是对容器`.size()`的调用，并且另一个参数是`ptrdiff_t`时，不要标记出来。

# Per: 性能

??? 这部分内容是否应该放在主要指南中 ???

这部分包含的准则是为需要高性能和低延迟的人准备的。也就是说，这些准则涉及到如何在可预测的短时间内使用尽可能少的时间和尽可能少的资源来完成任务。这部分准则比许多（大多数）应用程序所需的限制性和侵入性更强。不要在普通代码中盲目地遵守它们：达到低延迟的目标需要额外的工作。

性能准则概要：

* Per.1: 不要无理由地优化
* Per.2: 不要过早地优化
* Per.3: 不要优化不是性能悠关的东西
* Per.4: 不要认为复杂的代码必然比简单的代码更快
* Per.5: 不要认为低层级代码必然比高层级代码更快
* Per.6: 不要在没有经过测量的情况下作出性能断言
* Per.7: 为启用优化而设计
* Per.10: 依赖静态类型系统
* Per.11: 把计算从运行时转移到编译时
* Per.12: 消除冗余的别名
* Per.13: 消除冗余的间接访问
* Per.14: 最小化分配和释放的数量
* Per.15: 不要在关键的分支上分配
* Per.16: 使用紧凑的数据结构
* Per.17: 最先声明时间悠关结构中最常用的成员
* Per.18: 空间即时间
* Per.19: 可预测地访问内存
* Per.30: 避免在关键路径上发生上下文切换

### Per.1: 不要无理由地优化

##### 理由

如果不存在优化的需要，这份努力的主要结果将会是更多的错误和更高的维护代价。

##### 注意

有些人出于习惯进行优化，或者只是因为它有趣。

???

### Per.2: 不要过早地优化

##### 理由

精巧的优化代码通常比未优化代码更大且更难修改。

???

### Per.3: 不要优化不是性能悠关的东西

##### 理由

优化程序的非性能悠关部分对系统的性能没有影响。

##### 注意

如果你的程序在等待网络或用户上花费了大部分时间，优化在内存中的计算很可能没有用。

换个方式说：如果你的程序在计算A上花费了4%的处理器时间，以及在计算B上花费了40%的时间，在A上50%的提升只相当于在B上5%的提升。（如果你甚至不知道在A或B上花费了多少时间，看看Per.1和Per.2）

### Per.4: 不要认为复杂的代码必然比简单的代码更快

##### 理由

简单的代码会非常快。优化器有时会在简单代码上做令人惊叹的事情。

##### 示例，好的

```cpp
// 清楚地表达意图，快速地执行

vector<uint8_t> v(100000);

for (auto& c : v)
    c = ~c;
```

##### 示例，不好的

```cpp
// 想要执行得更快，但实际上更慢

vector<uint8_t> v(100000);

for (size_t i = 0; i < v.size(); i += sizeof(uint64_t))
{
    uint64_t& quad_word = *reinterpret_cast<uint64_t*>(&v[i]);
    quad_word = ~quad_word;
}
```

##### 注意

???

???

### Per.5: 不要认为低层级代码必然比高层级代码更快

##### 理由

低层级代码有时会阻碍优化。优化器有时会在高层级代码做令人惊叹的事情。

##### 注意

???

???

### Per.6: 不要在没有经过测量的情况下作出性能断言

##### 理由

在性能领域充斥着神话和虚伪的传说。现代硬件和优化器无视那些天真的假设；即使是专家也常常感到惊讶。

##### 注意

获得好的性能测量结果很困难，并且需要特定的工具。

##### 注意

一些使用Unix`time`或标准库`<chrono>`的简单的小型测量程序有助于打破最明显的神话。如果你不能准确地测量完整的系统，至少要尝试测量几个关键的操作和算法。分析器有助于告诉你系统中哪些部分是性能悠关的。通常，你会感到惊讶。

???

### Per.7: 为启用优化而设计

##### 理由

因为我们经常需要优化最初的设计。因为忽略后续改进可能性的设计难以修改。

##### 示例

来自C（以及C++）标准：

```cpp
void qsort (void* base, size_t num, size_t size, int (*compar)(const void*, const void*));
```

你什么时候会想对内存排序？实际上，我们是对一系列元素排序，这些元素通常是存放在容器中。

对`qsort`的调用丢弃了很多有用的信息（例如元素类型），强迫用户重复已经知道的信息（例如元素的大小），而且强迫用户写额外的代码（例如比较`double`的函数）。这意味着给程序员带来更多工作，容易出错，并且剥夺了编译器需要用来优化的信息。

```cpp
double data[100];
// ... 填充data ...

// 100块大小为sizeof(double)的内存，以data作为起始地址，使用由compare_doubles定义的规则排序
// address data using the order defined by compare_doubles
qsort(data, 100, sizeof(double), compare_doubles);
```

从接口设计的角度来看，`qsort`丢掉了有用的信息。

我们可以做得更好（在C++98中）：

```cpp
template<typename Iter>
    void sort(Iter b, Iter e);  // 对[b:e)排序

sort(data, data + 100);
```

这里，我们使用了编译器已经了解信息，包括数组大小、元素类型、以及如何比较`double`。

使用C++11加上概念，我们还可以做得更好：

```cpp
// Sortable指定了c必须是一个可以随机访问的元素序列，元素可以用<比较
void sort(Sortable& c);

sort(c);
```

这里的关键是传递足够的信息来让好的实现来选择。在这个例子中，`sort`接口仍然有缺点：它们隐式地依赖定义了小于（`<`）的元素类型。为了完善这个接口，我们需要第二个版本来接受一个比较准则：

```cpp
// 使用p比较c的元素
void sort(Sortable& c, Predicate<Value_type<Sortable>> p);
```

`sort`的标准库规范提供了这两个版本，但是它们的语义通过英文来表达而不是通过使用了概念的代码。

##### 注意

过早的优化被称为万恶之源，但这不是轻视性能的理由。考虑如何让设计能够适应改进从来不会太早，而且提升性能是常见的需要进行的改进。目标是要建立一套习惯，在默认情况下可以产出高效、可维护以及可优化的代码。特别是，当你写的函数不是一次性的实现细节时，要考虑：

* 信息传递：优先使用清晰的接口，为后续实现的改进携带充足的信息。要注意，信息通过我们提供的接口在实现中流入或流出。
* 紧凑数据：默认情况下，使用紧凑的数据，例如`std::vector`，并且以系统的方式访问它。如果你认为你需要一个链式结构，尝试精心打造一个接口，使得这个结构不会被用户看到。
* 函数参数传递和返回：区分可变和不可变数据。不要给你的用户强加资源管理负担。不要给你的用户强加错误的运行时间接访问。使用符合惯例的方式在接口中传递信息；不符合惯例以及/或者“经过优化的”传递数据方式会使后续的重新实现严重地复杂化。
* 抽象：不要过于笼统；试图满足每一种可能的使用（和误用），并且推迟每一个设计决策（使用编译时或运行时间接性）的设计通常是一个复杂的、臃肿的、难以理解的混乱。要从具体的例子中进行泛化，并且在我们泛化的时候保持性能。不要仅凭对未来需求的猜测而进行泛化。理想的是零开销的泛化。
* 库：使用具有良好接口的库。如果没有可用的库，你自己创建一个，并且从好的库模仿接口风格。标准库是第一个好地方来寻找灵感。
* 隔离：通过提供你所选择的接口来隔离你的代码与混乱且/或旧风格的代码。有时这称为对有用/必要但混乱的代码“提供一个包装”。不要让糟糕的设计“渗透进”你的代码。

##### 示例

考虑以下代码：

```cpp
template <class ForwardIterator, class T>
bool binary_search(ForwardIterator first, ForwardIterator last, const T& val);
```

`binary_search(begin(c), end(c), 7)`会告诉你`7`是否在`c`中。但是，它不会告诉你`7`的位置，或者是否有多于一个的`7`。

有时，只传回最小量的信息（这里是`tru`或`false`）是足够的，但一个好的接口会传回需要的信息给调用者。因此，标准库同时提供了：

```cpp
template <class ForwardIterator, class T>
ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last, const T& val);
```

`lower_bound`返回指向第一个匹配元素的迭代器，如果有的话，否则会返回`last`。

但是，`lower_bound`仍然没有返回足够的信息给所有用户，所以标准库同时提供了：

```cpp
template <class ForwardIterator, class T>
pair<ForwardIterator, ForwardIterator>
equal_range(ForwardIterator first, ForwardIterator last, const T& val);
```

`equal_range`返回一个迭代器`pair`，指定第一个和最后一个匹配之后的元素。

```cpp
auto r = equal_range(begin(c), end(c), 7);
for (auto p = r.first(); p != r.second(), ++p)
    cout << *p << '\n';
```

显然，这三个接口由相同的基础代码来实现。它们只是向用户展示了基础二分查找算法的三种方式，从最简单的（“使简单的事情保持简单！”）到返回完整的，但并不总是需要的信息（“不要隐藏有用的信息”）。自然，打造这样的一系列接口需要经验和领域知识。

##### 注意

不要只是创建接口来符合首次实现以及你认为的首次使用场景。一旦你第一次的初始实现完成了，要评审它；一旦你部署了它，错误会很难纠正。

##### 注意

对效率的需求并不意味着对低层级代码的需求。高层级代码并不意味着慢或臃肿。

##### 注意

东西都是有开销的。不要偏执于开销（现代计算机真的非常快），但要对你使用的东西的开销等级顺序有粗略的了解。例如，要粗略了解这些开销：一次内存访问，一次函数调用，一次字符串比较，一次系统调用，一次硬盘访问，以及一次通过网络传输的消息。

##### 注意

如果你只能想到一个实现，你可能缺少一些用来设计出稳定接口的东西。也许它只是一个实现细节——不是每一个代码片段都需要稳定的接口——但不妨暂停一下并且认真想想。一个可能有用的问题是“如果这个操作应该用多线程来实现，它需要什么样的接口？进行向量化吗？”

##### 注意

这个准则并没有与不要过早地优化准则矛盾。它对其进行了补充，它鼓励开发者在后续——适当且没有过早的时机——启用优化，如果需要的话。

##### 实施

棘手的。可能查找`void*`函数参数会找到阻碍后续优化的接口例子。

### Per.10: 依赖静态类型系统

##### 理由

类型违规、弱类型（例如`void*`）以及低层级代码（例如以单独字节的方式操作一个序列）使优化器的工作更困难。简单的代码通常比手工打造的复杂代码优化得更好。

???

### Per.11: 把计算从运行时转移到编译时

##### 理由

减少代码大小和运行时间。通过使用常量避免数据竞争。在编译时捕捉错误（并且由此消除错误处理代码的需要）。

##### 示例

```cpp
double square(double d) { return d*d; }
static double s2 = square(2);    // 老式风格：动态初始化

constexpr double ntimes(double d, int n)   // 假设0 <= n
{
        double m = 1;
        while (n--) m *= d;
        return m;
}
constexpr double s3 {ntimes(2, 3)};  // 现代风格：编译时初始化
```

像`s2`那样的初始化代码并非罕见，尤其是那些比`square()`更复杂一点的初始化。但是，与`s3`的初始化相比，它存在两个问题：

* 我们受到运行时函数调用的开销的影响。
* `s2`可能会在初始化之前被其它线程访问。

注意：你不会在常量上遇到数据竞争。

##### 示例

考虑一个受欢迎的技术，它提供了一个句柄，小的对象存储在句柄自身中，大的对象存储在堆中。

```cpp
constexpr int on_stack_max = 20;

template<typename T>
struct Scoped {     // 在Scoped中存储T
        // ...
    T obj;
};

template<typename T>
struct On_heap {    // 在自由存储中存储T
        // ...
        T* objp;
};

template<typename T>
using Handle = typename std::conditional<(sizeof(T) <= on_stack_max),
                    Scoped<T>,      // 第一个可选方案
                    On_heap<T>      // 第二个可选方案
                >::type;

void f()
{
    Handle<double> v1;                   // double存储在栈上
    Handle<std::array<double, 200>> v2;  // 数组存储在自由存储上
    // ...
}
```

假设`Scoped`和`On_heap`提供了兼容的用户接口。这里我们在编译时计算出最佳的类型来使用。也有类似的技术来选择最佳的函数来调用。

##### 注意

这个意图并非是要在编译时执行任何东西。显然，大部分计算依赖输入，所以它们不能转移到编译时，但在逻辑约束之外，复杂的编译时计算会严重地增加编译时间以及使调试复杂化。编译时计算甚至有可能会降低代码运行速度。诚然，这种情况很罕见，但通过把一般的计算分解为单独的最佳子计算，有可能会降低指令缓存的效果。

##### 实施

* 查找简单的函数，这些函数可能为`constexpr`（但实际不是）。
* 查找所有参数都是常量表达式的函数调用。
* 查找可以为`constexpr`的宏。

### Per.12: 消除冗余的别名

???

### Per.13: 消除冗余的间接访问

???

### Per.14: 最小化分配和释放的数量

???

### Per.15: 不要在关键的分支上分配

???

### Per.16: 使用紧凑的数据结构

##### 理由

性能通常由内存访问次数支配。

???

### Per.17: 最先声明时间悠关结构中最常用的成员

???

### Per.18: 空间即时间

##### 理由

性能通常由内存访问次数支配。

##### Per.19: 可预测地访问内存

##### 理由

性能对缓存的性能非常敏感，缓存的算法有利于对相邻数据的简单（一般是线性）访问。

##### 示例

```cpp
int matrix[rows][cols];

// 不好的
for (int c = 0; c < cols; ++c)
    for (int r = 0; r < rows; ++r)
        sum += matrix[r][c];

// 好的
for (int r = 0; r < rows; ++r)
    for (int c = 0; c < cols; ++c)
        sum += matrix[r][c];
```

### Per.30: 避免在关键路径上发生上下文切换

???

# CP: 并发和并行

我们通常希望我们的计算机在同一时间做很多任务（或者至少让它们看起来在同一时间做这些任务）。这样做的原因各不相同（例如，想要只使用单个处理器等待很多事件、同时处理许多个数据流、或者利用许多个硬件设施），并且表达并行和并发的基础设施也各不相同。这里，我们明确了一些使用ISO标准C++设施来表达并发和并行的一般原则和准则。

支持并发和并行编程的核心机制是线程。线程允许你独立地运行多个你的程序的实例，这样可以共享内存。出于多个原因，并发编程是困难的，最重要的是，如果在多个线程之间没有适当的同步，一个线程在写入数据之后，另一个线程读取这个数据，这样的行为是未定义的。让已有的单线程代码并发地执行就像有策略性地添加`std::async`或`std::thread`那样简单，或者它可能需要完全重写，取决于原始的代码是否以线程友好的方式来编写。

在这个文档中的并发/并行准则以三个目标为设计考虑：

* 帮助你写出适合用在多线程环境下的代码
* 演示清晰、安全的方式来使用标准库提供的线程原语
* 当并发和并行不能满足你需要的性能收益时，提供如何做的指导

还需要注意的是，C++中的并发性是未完成的故事。C++11引入了很多核心的并发原语，C++14对它们进行了改善，看起来这似乎使得在C++中写并行程序变得有趣，甚至更简单了。我们希望在这里的一些跟库相关的指南随着时间变化有显著的改变。

这部分内容需要很多工作（显然）。请注意，我们的准则一开始是针对相对来说不是专家的人。真正的专家必须稍微等等；贡献是受欢迎的，但请考虑一下那些正在为他们的并行程序的正确性和高性能而挣扎的大多数程序员。

并发和并行准则概要：

* CP.1: 认定你的代码会作为多线程程序的一部分执行
* CP.2: 避免数据竞争
* CP.3: 尽量减少可写数据的显式共享
* CP.4: 从任务而不是线程的角度来思考
* CP.8: 不要试图使用`volatile`进行同步
* CP.9: 在任何可行的时候，使用工具来验证你的并行代码

另见：

* CP.con: 并发
* CP.par: 并行
* CP.mess: 消息传递
* CP.vec: 向量化
* CP.free: 无锁编程
* CP.etc: 其它并发准则

### CP.1: 认定你的代码会作为多线程程序的一部分执行

##### 理由

难以确定现在或者将来的某个时候不会使用并行。代码会被重用。使用了线程的库可能会在程序的其它部分使用。要注意库代码最迫切应用这个准则，而独立的应用程序最不迫切。然而，感谢剪切粘贴，代码片段会在意想不到的地方出现。

##### 示例

```cpp
double cached_computation(double x)
{
    static double cached_x = 0.0;
    static double cached_result = COMPUTATION_OF_ZERO;
    double result;

    if (cached_x == x)
        return cached_result;
    result = computation(x);
    cached_x = x;
    cached_result = result;
    return result;
}
```

虽然`cached_computation`可以在单线程环境下完美地执行，但在多线程环境下两个`static`变量会导致数据竞争，因此也会导致未定义行为。

有几种方式可以让这个例子在多线程环境下变得安全：

* 把并发的关注点向上委派给调用者。
* 把`static`变量标记成`thread_local`（这可能会降低缓存的效率）。
* 实现并发控制，例如，用一个`static`的锁保护两个`static`变量（这可能会降低性能）。
* 让调用者提供内存用作缓存，因此同时把内存分配和并发的关注点向上委派给调用者。
* 拒绝在多线程环境下构建和/或执行。
* 提供两个实现，一个用于单线程环境，另一个用于多线程环境。

##### 例外

永远不会在多线程环境下执行的代码。

小心：有许多例子表明，“已知”永远不会在多线程环境下执行的代码，最后都作为多线程程序的一部分执行。通常都是在多年以后才发生。通常，这样的程序需要费劲地去移除数据竞争。因此，永远不想在多线程环境下执行的代码应该明确地进行标注，而且最好结合编译或运行时的强制保证机制来尽早捕捉这种使用缺陷。

### CP.2: 避免数据竞争

##### 理由

除非你这样做，否则没有东西能够保证正常执行，而且会持续出现微妙的错误。

##### 注意

简而言之，如果两个线程可以同时访问同一个对象（没有进行同步），并且至少有一个线程是写者（执行非`const`操作），那么你就会遇到数据竞争。关于如何运用好同步来消除数据竞争的进一步信息，请查阅一本关于并发的好书籍。

##### 示例，不好的

有很多数据竞争的例子，有一些此时此刻正在生产环境的软件中运行。一个非常简单的例子：

```cpp
int get_id() {
    static int id = 1;
    return id++;
}
```

这里的递增是数据竞争的例子。在许多情况下这会出现错误，包括：

* 线程A读取了`id`的值，操作系统把A的上下文切换出去一段时间，在这期间其它线程创建了几百个ID。然后线程A可以再次执行，`id`被写回到原来的位置，它的值是A读取到的值加1。
* 线程A和线程B同时读取`id`，并且对其进行递增。它们都会得到相同的ID。

局部静态变量是数据竞争的常见来源。

##### 示例，不好的

```cpp
void f(fstream&  fs, regex pat)
{
    array<double, max> buf;
    int sz = read_vec(fs, buf, max);            // 从fs读取内容到buf
    gsl::span<double> s {buf};
    // ...
    auto h1 = async([&]{ sort(par, s); });     // 发起任务来排序
    // ...
    auto h2 = async([&]{ return find_all(buf, sz, pat); });   // 发起任务来查找匹配项
    // ...
}
```

这里，我们在`buf`的元素上遇到（恶心的）数据竞争（`sort`会同时读和写）。所有数据竞争都是恶心的。这里，我们故意让栈上的数据遇到数据竞争。并非所有数据竞争都像这样容易定位。

##### 示例，不好的

```cpp
// 没有被锁控制的代码

unsigned val;

if (val < 5) {
    // ... 其它线程会修改这里的val ...
    switch (val) {
    case 0: // ...
    case 1: // ...
    case 2: // ...
    case 3: // ...
    case 4: // ...
    }
}
```

现在，编译器不知道`val`会被修改，它很可能使用一个具有五项的跳转表来实现这个`switch`。然后，超出`[0..4]`范围的`val`会产生一个可能跳到程序任何地方的跳转，并且在那里执行。真的，如果你遇到了数据竞争，“所有赌注都会取消”（任何事情都有可能发生）。实际上，它有可能会更糟糕：通过查看生成的代码，你也许能够确定对于给定的值它会跳到什么地方；这是一个安全风险。

##### 实施

有些是可能做到的，至少要做一些事情。有一些商业的以及开源的工具来试图解决这个问题，但要注意这些解决方案有成本，也有盲点。静态工具通常有很多误报，而运行时工具通常有效率上的开销。我们希望有更好的工具。使用多个工具比单个工具可以捕捉更多问题。

有其它方式可以减少数据竞争的机会：

* 避免全局数据
* 避免`static`变量
* 在栈上更多地使用值类型（而且不要过多地传递指针）
* 更多地使用不可变数据（字面量、`constexpr`以及`const`）

### CP.3: 尽量减少可写数据的显式共享

##### 理由

如果你不共享可写数据，你就不会遇到数据竞争。你共享的东西越少，忘记进行同步访问（并且遇到数据竞争）的机会也会越少。你共享的东西越少，你要在锁上等待的机会越少（因而性能得到提升）。

##### 示例

```cpp
bool validate(const vector<Reading>&);
Graph<Temp_node> temperature_gradiants(const vector<Reading>&);
Image altitude_map(const vector<Reading>&);
// ...

void process_readings(const vector<Reading>& surface_readings)
{
    auto h1 = async([&] { if (!validate(surface_readings)) throw Invalid_data{}; });
    auto h2 = async([&] { return temperature_gradiants(surface_readings); });
    auto h3 = async([&] { return altitude_map(surface_readings); });
    // ...
    h1.get();
    auto v2 = h2.get();
    auto v3 = h3.get();
    // ...
}
```

如果没有那些`const`，我们不得不检查每个被异步调用的函数，来发现`surface_readings`上潜在的数据竞争。使`surface_readings`为`const`（就这个函数而言），可以看出它在这个函数体内的用法。

##### 注意

不可变数据可以安全且高效地共享。不需要锁：你不会在常量上遇到数据竞争。另见CP.mess: 消息传递和CP.31: 优先以值传递。

##### 实施

???

### CP.4: 从任务而不是线程的角度来思考

##### 理由

`thread`是一个实现概念，是一种思考机器的方式。任务是一个应用程序概念，一些你想要做的事情，最好是能够与其它任务同时执行。应用程序概念更容易理解。

##### 示例

```cpp
void some_fun() {
    std::string  msg, msg2;
    std::thread publisher([&] { msg = "Hello"; });       // 不好的：缺乏表达力
                                                            //      而且更容易出错
    auto pubtask = std::async([&] { msg2 = "Hello"; });  // 没问题
    // ...
    publisher.join();
}
```

##### 注意

除了`async()`之外，标准库的设施是低层级的，面向机器的，以及属于线程和锁级别的。这是一个必要的基础，不过我们必须尽量提高抽象的层级：为了生产力、为了可读性、以及为了性能。这是使用更高层级、更面向应用程序的库的有力论据（如果可能的话，基于标准库的设施来创建）。

##### 实施

???

### CP.8: 不要试图使用`volatile`进行同步

##### 理由

在C++中，不像其它语言，`volatile`不提供原子性，不会在线程间进行同步，也不会防止指令重排（包括编译器和硬件）。它对并发不起任何作用。

##### 示例，不好的

```cpp
int free_slots = max_slots; // 当前对象的内存来源

Pool* use()
{
    if (int n = free_slots--) return &pool[n];
}
```

这里我们遇到一个问题：在单线程程序中，这是完美的代码，可是一旦有两个线程执行这个代码，会在`free_slots`上出现数据竞争，因此这两个线程可能会得到相同的值和`free_slots`。这（显然）是糟糕数据竞争，所以经过其它语言训练的人可能会试图这样修复它：

```cpp
volatile int free_slots = max_slots; // 当前对象的内存来源

Pool* use()
{
    if (int n = free_slots--) return &pool[n];
}
```

这对同步没有影响：数据竞争仍然存在！

用于这种情况的C++机制是`atomic`类型：

```cpp
atomic<int> free_slots = max_slots; // 当前对象的内存来源

Pool* use()
{
    if (int n = free_slots--) return &pool[n];
}
```

现在`--`操作是原子的，而不是“读-递增-写”的序列，其它线程可能会介入这个序列——在每个单独的操作之间。

##### 替代方案

当你遇到在其它语言中使用`volatile`的场景时，使用`atomic`类型。对于更复杂的例子，使用`mutex`。

##### 另见

（少见的）正确地使用`volatile`。

### CP.9: 在任何可行的时候，使用工具来验证你的并行代码

经验表明，并发代码非常难以正确地执行，而且比起在顺序代码上发现错误，编译时检查、运行时检查以及测试在发现并发错误上都不怎么有效。不易察觉的并发错误会引发严重的后果，包括内存损坏和死锁。

##### 示例

```cpp
???
```

##### 注意

线程安全具有挑战性，通常有经验的程序员会有更大的好处：使用工具是减少这些风险的重要策略。有许多工具“在那里”，有商业的也有开源的工具，有用于研究的也有用于生产的工具。不幸的是，人们的需求和约束有很大的不同，所以我们不能提出具体的建议，但我们还是可以提一下：

* 静态实施工具：clang和一些旧版本的GCC，它们都支持线程安全属性的静态标注。持续使用这个技术可以把很多种类的线程安全错误转成编译时错误。这些标注一般是局部的（标记一个特定的成员变量，由特定的互斥量来保护），而且通常容易学习。但是，与其它很多静态工具一样，它经常会出现误报；以及有些应该捕捉到的情况却被允许。
* 动态实施工具：clang的Thread Sanitizer（也称为TSAN）是一个强大的动态工具的例子：它改变了你的程序的构建和执行，在内存访问上添加记录，完全识别出你的二进制文件上一段给定代码的数据竞争。这些的代价是内存（大部分情况下5到10倍）和降低CPU（2到20倍）。当应用于集成测试、canary pushes或者在多个线程上操作的单元测试时，这样的动态工具是最好的。工作量是重要的：当TSAN识别出一个问题，它事实上总是一个实际的数据竞争，但它只能识别出在给定的执行范围中看到的竞争。

##### 实施

这取决于应用程序的创建者选择哪些支持工具，这些工具对特定的应用程序是有价值的。

## CP.con: 并发

这部分聚焦于通过共享数据进行多线程通信的相对特别的用法。

* 对于并行算法，参阅并行。
* 对于不使用显式共享的任务内通信，参阅发消息。
* 对于向量并行代码，参阅向量化。
* 对于无锁编程，参阅无锁化。

并发准则概要：

* CP.20: 使用RAII，永远不要使用原始的`lock()`/`unlock()`
* CP.21: 使用`std::lock()`或`std::scoped_lock`来获取多个`mutex`
* CP.22: 永远不要在持有锁的时候调用未知代码（例如，一个回调）
* CP.23: 把`joining_thread`视为作用域内的容器
* CP.24: 把`thread`视为全局容器
* CP.25: 优先使用`gsl::joining_thread`而不是`std::thread`
* CP.26: 不要调用`detach()`分离线程
* CP.31: 在线程间以值传递少量数据，而不是以引用或指针
* CP.32: 使用`shared_ptr`在不相关的`thread`之间共享所有权
* CP.40: 尽量避免上下文切换
* CP.41: 尽量避免线程创建和销毁
* CP.42: 不要不带条件地调用`wait`
* CP.43: 尽量减少花费在关键段中的时间
* CP.44: 记得为你的`lock_guard`和`unique_lock`命名
* CP.50: 与受保护的数据一起定义`mutex`。可能的话使用`synchronized_value<T>`
* ??? 什么时候使用自旋锁
* ??? 什么时候使用`try_lock()`
* ??? 什么时候有限使用`lock_guard`而不是`unique_lock`
* ??? Time multiplexing
* ??? 什么时候/如何使用`new thread`

### CP.20: 使用RAII，永远不要使用原始的`lock()`/`unlock()`

##### 理由

避免未释放锁导致的严重错误。

##### 示例，不好的

```cpp
mutex mtx;

void do_stuff()
{
    mtx.lock();
    // ... 做事情 ...
    mtx.unlock();
}
```

迟早有人会忘记`mtx.unlock()`，在`... 做事情 ...`中插入`return`，抛出异常，或者其它事情。

```cpp
mutex mtx;

void do_stuff()
{
    unique_lock<mutex> lck {mtx};
    // ... 做事情 ...
}
```

##### 实施

标记出对成员函数`lock()`和`unlock()`的调用。???

### CP.21: 使用`std::lock()`或`std::scoped_lock`来获取多个`mutex`

##### 理由

避免在多个`mutex`上出现死锁。

##### 示例

这是在主动要求出现死锁：

```cpp
// 线程1
lock_guard<mutex> lck1(m1);
lock_guard<mutex> lck2(m2);

// 线程2
lock_guard<mutex> lck2(m2);
lock_guard<mutex> lck1(m1);
```

相反，使用`lock()`：

```cpp
// 线程1
lock(m1, m2);
lock_guard<mutex> lck1(m1, adopt_lock);
lock_guard<mutex> lck2(m2, adopt_lock);

// 线程2
lock(m2, m1);
lock_guard<mutex> lck2(m2, adopt_lock);
lock_guard<mutex> lck1(m1, adopt_lock);
```

或者（更好的方法，但仅限C++17）：

```cpp
// 线程1
scoped_lock<mutex, mutex> lck1(m1, m2);

// 线程2
scoped_lock<mutex, mutex> lck2(m2, m1);
```

这里，`thread1`和`thread2`的作者依然没有在`mutex`的顺序上达成一致，但顺序不再是问题。

##### 注意

在实际代码中，`mutex`很少被命名为可以方便地提醒程序员它们预期的关系以及预期的获取顺序。在实际代码中，`mutex`并非总是能够在连续的行中方便地获取。

在C++17中，可以简单地写：

```cpp
lock_guard lck1(m1, adopt_lock);
```

`mutex`的类型会被推导出来。

##### 实施

检测对多个`mutex`的获取。通常这是不可确定的，但捕捉常见的简单例子（像上面那个）是容易的。

### CP.22: 永远不要在持有锁的时候调用未知代码（例如，一个回调）

##### 理由

如果你不知道那段代码做了什么，你会有死锁的风险。

##### 示例

```cpp
void do_this(Foo* p)
{
    lock_guard<mutex> lck {my_mutex};
    // ... 做一些事情 ...
    p->act(my_data);
    // ...
}
```

如果你不知道`Foo:act`做了什么（也许它是一个虚函数，调用了一个还没写好的派生类成员），它有可能调用了`do_this`（递归地）然后在`my_mutex`上发生死锁。可能它会在另一个互斥量上加锁，然后没有在合理的时间内返回，导致任何调用了`do_this`的代码延迟。

##### 示例

一个常见的“调用未知代码”问题的例子是：调用一个试图对同一个对象加锁访问的函数。这种问题通常可以使用`recursive_mutex`来解决。例如：

```cpp
recursive_mutex my_mutex;

template<typename Action>
void do_something(Action f)
{
    unique_lock<recursive_mutex> lck {my_mutex};
    // ... 做一些事情 ...
    f(this);    // f会对*this做一些事情
    // ...
}
```

正如这里可能出现的那样，如果`f()`调用了`*this`上的操作，我们必须确保对象的不变式在调用之前保持不变。

##### 实施

* 标记出在持有非递归`mutex`时对虚函数的调用。
* 标记出在持有非递归`mutex`时对回调的调用。

### CP.23: 把`joining_thread`视为作用域内的容器

##### 理由

为了维护指针安全和避免泄露，我们需要考虑`thread`使用了哪些指针。如果一个`thread`联结了，我们可以安全地传递指针到`thread`所在作用域以及它外围作用域中的对象。

##### 示例

```cpp
void f(int* p)
{
    // ...
    *p = 99;
    // ...
}
int glob = 33;

void some_fct(int* p)
{
    int x = 77;
    joining_thread t0(f, &x);           // 没问题
    joining_thread t1(f, p);            // 没问题
    joining_thread t2(f, &glob);        // 没问题
    auto q = make_unique<int>(99);
    joining_thread t3(f, q.get());      // 没问题
    // ...
}
```

`gsl::joining_thread`是一个`std::thread`，它的析构函数会进行联结，所以不能用`detached()`分离线程。我们说“没问题”的意思是，对象在作用域内（“存活”）的时间与`thread`使用指向它的指针的时间一样长。事实上，`thread`并发地执行不会影响它在这里的生命周期或者所有权问题；这些`thread`可以看成只是一个被`some_fct`调用的函数对象。

##### 实施

确保`joining_thread`不会调用`detach()`。这样的话，正常的生命周期和所有权（对局部对象来说）能得到保证。

### CP.24: 把`thread`视为全局容器

##### 理由

为了维护指针安全和避免泄露，我们需要考虑`thread`使用了哪些指针。如果一个`thread`被分离了，我们（只）能安全地传递指针到静态和自由存储对象。

##### 示例

```cpp
void f(int* p)
{
    // ...
    *p = 99;
    // ...
}

int glob = 33;

void some_fct(int* p)
{
    int x = 77;
    std::thread t0(f, &x);           // 不好的
    std::thread t1(f, p);            // 不好的
    std::thread t2(f, &glob);        // 没问题
    auto q = make_unique<int>(99);
    std::thread t3(f, q.get());      // 不好的
    // ...
    t0.detach();
    t1.detach();
    t2.detach();
    t3.detach();
    // ...
}
```

我们说“没问题”的意思是，对象在作用域内（“存活”）的时间与`thread`使用指向它的指针的时间一样长。我们说“不好的”的意思是，`thread`可能在被指向的对象被销毁后使用了指针。事实上，`thread`并发地执行不会影响它在这里的生命周期或者所有权问题；这些`thread`可以看成只是一个被`some_fct`调用的函数对象。

##### 注意

如果在被分离的线程中使用，即使是静态存储中的对象也会成为问题：如果线程持续执行直到程序结束，它可能会与静态存储对象的析构并发执行，因而对这些对象的访问可能会出现竞争。

##### 注意

如果你不使用`detach()`并且使用`gsl::joining_thread`，那么这个准则是多余的。然而，把代码转换成遵守这些指南是困难的，甚至对第三方库来说是不可能的。在这些情况下，这个准则变得对生命周期安全和类型安全都是必要的。

一般来说，一个`thread`是否执行过`detach()`是不可确定的，但简单常见的情况可以容易地检测出来。如果我们不能保证`thread`没有调用`detach()`，那么我们必须认为它调用了，而且它的生命周期超出了构造它的作用域；这样的话，正常的生命周期和所有权（对局部对象来说）能得到保证。

##### 实施

标记出试图传递局部变量到可能已由`detach()`分离的线程。

### CP.25: 优先使用`gsl::joining_thread`而不是`std::thread`

##### 理由

`joining_thread`是会在其作用域结束的时候联结的线程。被分离的线程更加难监控。对于被分离的线程来说（以及可能会被分离的线程），更加难保证没有错误。

##### 示例，不好的

```cpp
void f() { std::cout << "Hello "; }

struct F {
    void operator()() { std::cout << "parallel world "; }
};

int main()
{
    std::thread t1{f};      // f()在另一个线程执行
    std::thread t2{F()};    // F()()在另一个线程执行
}  // 发现这里的缺陷
```

##### 示例

```cpp
void f() { std::cout << "Hello "; }

struct F {
    void operator()() { std::cout << "parallel world "; }
};

int main()
{
    std::thread t1{f};      // f()在另一个线程执行
    std::thread t2{F()};    // F()()在另一个线程执行

    t1.join();
    t2.join();
}  // 剩下一个不好的缺陷
```

##### 示例，不好的

决定调用`join()`还是`detach()`的代码可能是复杂的，甚至会在调用这些函数的线程中决定，又或者在创建新线程来调用这些函数的线程中决定：

```cpp
void tricky(thread* t, int n)
{
    // ...
    if (is_odd(n))
        t->detach();
    // ...
}

void use(int n)
{
    thread t { tricky, this, n };
    // ...
    // ... 我是否应该在这里联结？ ...
}
```

这使生命周期的分析变得很复杂，而且在并非罕见的下，会导致生命周期的分析变得不可能。这意味着我们不能安全地在线程中使用`use()`的局部对象，或者在`use()`中使用线程的局部对象。

##### 注意

让“永生的线程”全局化，把它们放到封闭的作用域中，或者把它们放到自由存储上，而不是调用`detach()`。不要分离线程。

##### 注意

由于旧代码和第三方库使用了`std::thread`，这个准则可能会难以引入。

##### 实施

标记出`std::thread`的使用：

* 建议使用`gsl::joining_thread`.
* 如果线程被分离，建议“导出所有权”到封闭的作用域中。
* 如果联结或分离不明确，发出严重的警告。

### CP.26: 不要调用`detach()`分离线程

##### 理由

通常，让生命周期超出其创建作用域的需求是线程任务所固有的，但通过`detach`实现这个想法使得更加难监控分离的线程，也更加难与分离的线程通信。尤其是，更加难确保这个线程按预期地完成，或者存活了预期的时间。

##### 示例

```cpp
void heartbeat();

void use()
{
    std::thread t(heartbeat);             // 不联结；heartbeat要一直执行
    t.detach();
    // ...
}
```

这是线程的合理使用，其中的`detach()`是常见的用法。不过还是有一些问题。我们如何监控被分离的线程来看它是否活着？心跳可能会出现一些问题，而丢失心跳对需要它的系统来说是很严重的。因此，我们需要与心跳线程通信（例如，通过消息流或者使用`condition_variable`的通知事件）。

另一种做法，通常更优的解决方案是通过把线程放到创建（或者激活）点的作用域外部来控制它的生命周期。例如：

```cpp
void heartbeat();

gsl::joining_thread t(heartbeat);             // heartbeat要“永远”执行
```

这个心跳的执行时间与程序的执行时间一样（除非出现错误，硬件问题等）。

有时候，我们需要把创建点从所有权点分离出来：

```cpp
void heartbeat();

unique_ptr<gsl::joining_thread> tick_tock {nullptr};

void use()
{
    // hearbeat的执行时间与tick_tock存活的时间一样长
    tick_tock = make_unique<gsl::joining_thread>(heartbeat);
    // ...
}
```

##### 实施

标记出`detach()`。

### CP.31: 在线程间以值传递少量数据，而不是以引用或指针

##### 理由

拷贝少量数据比起使用一些锁机制来共享它更加容易拷贝和访问。拷贝自然地提供了唯一所有权（简化代码）并且消除了数据竞争的可能。

##### 注意

精确地定义“少量”是不可能的。

##### 示例

```cpp
string modify1(string);
void modify2(shared_ptr<string>);

void fct(string& s)
{
    auto res = async(modify1, s);
    async(modify2, &s);
}
```

对`modify1`的调用拷贝了两次`string`值；对`modify2`的调用没有拷贝。另一方面，`modify1`的实现与我们为单线程代码所写的完全一样，而`modify2`的实现需要某种形式的锁来避免数据竞争。如果字符串是短的（例如10个字符），对`modify1`的调用会惊人地快；基本上所有开销都在`thread`的切换。如果字符串是长的（例如1,000,000个字符），拷贝它两次可能不是好主意。

注意，这里的讨论与`sync`本身没有关系。它同样适用于考虑使用消息传递还是共享内存。

##### 实施

???

### CP.32: 使用`shared_ptr`在不相关的`thread`之间共享所有权

##### 理由

如果线程是不相关的（也就是说，不知道对方在同一个作用域，或者一个线程的生命周期在另一个线程的生命周期之内），而且它们需要共享自由存储上的内存，这块内存需要删除，`shared_ptr`（或者同等的东西）是唯一安全的方式来确保能够正确地删除。

##### 示例

```cpp
???
```

##### 注意

* 静态对象（例如全局对象）可以被共享，因为它不属于由某个线程负责删除它的场景。
* 永远不需要删除的自由存储上的对象可以被共享。
* 一个线程拥有的对象可以安全地与另一个线程共享，只要第二个线程的生命周期不会比该对象的所有者长。

##### 实施

???

### CP.40: 尽量避免上下文切换

##### 理由

上下文切换是昂贵的。

##### 示例

```cpp
???
```

##### 实施

???

### CP.41: 尽量避免线程创建和销毁

##### 理由

线程的创建是昂贵的。

##### 示例

```cpp
void worker(Message m)
{
    // 处理
}

void master(istream& is)
{
    for (Message m; is >> m; )
        run_list.push_back(new thread(worker, m));
}
```

这里每个消息都会生成一个`thread`，`run_list`大概是用来在这些任务完成的时候销毁它们。

相反，我们可以有一些预创建的工作线程来处理这些消息：

```cpp
Sync_queue<Message> work;

void master(istream& is)
{
    for (Message m; is >> m; )
        work.put(m);
}

void worker()
{
    for (Message m; m = work.get(); ) {
        // 处理
    }
}

void workers()  // 设置工作线程（明确地指定4个工作线程）
{
    joining_thread w1 {worker};
    joining_thread w2 {worker};
    joining_thread w3 {worker};
    joining_thread w4 {worker};
}
```

##### 注意

如果你的系统有好的线程池，使用它。如果你的系统有好的消息队列，使用它。

##### 实施

???

### CP.42: 不要不带条件地调用`wait`

##### 理由

不带条件地调用`wait`可能会错过唤醒，或者唤醒后只是发现没有事情做。

##### 示例，不好的

```cpp
std::condition_variable cv;
std::mutex mx;

void thread1()
{
    while (true) {
        // 做一些事情 ...
        std::unique_lock<std::mutex> lock(mx);
        cv.notify_one();    // 唤醒另一个线程
    }
}

void thread2()
{
    while (true) {
        std::unique_lock<std::mutex> lock(mx);
        cv.wait(lock);    // 可能永远阻塞
        // 做事情 ...
    }
}
```

这里，如果其它一些`thread`消费了`thread1`的通知，`thread2`会永远等待。

##### 示例

```cpp
template<typename T>
class Sync_queue {
public:
    void put(const T& val);
    void put(T&& val);
    void get(T& val);
private:
    mutex mtx;
    condition_variable cond;    // 这个用来控制访问
    list<T> q;
};

template<typename T>
void Sync_queue<T>::put(const T& val)
{
    lock_guard<mutex> lck(mtx);
    q.push_back(val);
    cond.notify_one();
}

template<typename T>
void Sync_queue<T>::get(T& val)
{
    unique_lock<mutex> lck(mtx);
    cond.wait(lck, [this]{ return !q.empty(); });    // 避免不必要的唤醒
    val = q.front();
    q.pop_front();
}
```

现在，当执行`get()`的线程唤醒后，如果队列是空的（例如，由于其它线程在它之前已经调用了`get()`），它会立即回到睡眠，等待。

##### 实施

标记出所有不带条件的`wait`。

### CP.43: 尽量减少花费在关键段中的时间

##### 理由

花费在已获得的`mutex`上的时间越少，其它`thread`就越少遇到必须等待的机会，并且`thread`的挂起和恢复是昂贵的。

##### 示例

```cpp
void do_something() // 不好的
{
    unique_lock<mutex> lck(my_lock);
    do0();  // 准备：不需要锁
    do1();  // 事务：需要锁
    do2();  // 清理：不需要锁
}
```

这里，我们持有锁的时间比真正需要的长：我们不应该在需要之前获取锁，而且应该在开始清理之前再次释放它。我们可以重写成这样：

```cpp
void do_something() // 不好的
{
    do0();  // 准备：不需要锁
    my_lock.lock();
    do1();  // 事务：需要锁
    my_lock.unlock();
    do2();  // 清理：不需要锁
}
```

但是这样会危及安全性并且违反了使用RAII准则。替代方案是，为关键段添加代码块：

```cpp
void do_something() // 没问题
{
    do0();  // 准备：不需要锁
    {
        unique_lock<mutex> lck(my_lock);
        do1();  // 事务：需要锁
    }
    do2();  // 清理：不需要锁
}
```

##### 实施

一般来说不可能做到。标记出“裸露的”`lock()`和`unlock()`。

### CP.44: 记得为你的`lock_guard`和`unique_lock`命名

##### 理由

未命名的局部对象是临时的，会立即超出作用域。

##### 示例

```cpp
unique_lock<mutex>(m1);
lock_guard<mutex> {m2};
lock(m1, m2);
```

这看起来没有问题，但并不是。

##### 实施

标记出所有未命名的`lock_guard`和`unique_lock`。

### CP.50: 与受保护的数据一起定义`mutex`。可能的话使用`synchronized_value<T>`

##### 理由

对读者来说，数据受到保护以及如何保护应该能明显地看出来。这减少了错误的互斥量被加锁或者没有互斥量被加锁的机会。

使用`synchronized_value<T>`确保了数据带有互斥量，而且当数据被访问的时候正确的互斥量会被加锁。参阅WG21提案，该提案添加`synchronized_value`到C++标准未来的TS或者修订中。

##### 示例

```cpp
struct Record {
    std::mutex m;   // 在访问其它成员之前获取这个互斥量
    // ...
};

class MyClass {
    struct DataRecord {
        // ...
    };
    synchronized_value<DataRecord> data; // 用互斥量保护数据
};
```

##### 实施

??? 有可能吗？

## CP.par: 并行

“并行”的意思是在多个数据项上（或多或少地）同时（“一起并行”）执行一个任务。

并行准则概要：

* ???
* ???
* 在适当的时候，优先使用标准库的并行算法
* 使用专为并行设计的算法，不要使用不必要地依赖线性求值的算法

## CP.mess: 消息传递

标准库的设施是很低层级的，专注于使用`thread`、`mutex`、`atomic`等类型进行贴近硬件关键编程的需求。大部分人不应该在这个层级工作：它容易出错并且开发效率很低。如果可能的话，使用更高层级的设施：消息库、并行算法以及向量化。这部分聚焦于传递消息，这样的话程序员不需要做显式的同步。

消息传递准则概要：

* CP.60: 使用`future`从并发任务中返回值
* CP.61: 使用`async()`生成并发任务
* 消息队列
* 消息库

??? 是否应该有“使用X而不是`std::async`”的准则？其中X是某些使用了更好的特定线程池的东西。

??? 鉴于未来（甚至是已有库中）的并行设施，`std::async`是否值得使用？如果有人想要并行化，例如`std::accumulate`（具有可交换性的额外前提），或者合并排序，本指南应该如何建议？

### CP.60: 使用`future`从并发任务中返回值

##### 理由

`future`为异步任务保留了一般的函数调用返回语义。它没有显式的锁，并且正确（值）返回和错误（异常）返回都能简单地处理。

##### 示例

```cpp
???
```

##### 注意

???

##### 实施

???

### CP.61: 使用`async()`生成并发任务

##### 理由

`future`为异步任务保留了一般的函数调用返回语义。它没有显式的锁，并且正确（值）返回和错误（异常）返回都能简单地处理。

##### 示例

```cpp
???
```

##### 注意

不幸的是，`async()`并不完美。例如，它不能保证使用线程池来减少线程的创建。事实上，大部分目前的`async()`实现都没有这样做。然而，`async()`很简单，而且逻辑上是正确的，所以直到有更好的东西出现之前，除非你真的需要为很多异步任务做优化，否则坚持使用`async()`。

##### 实施

???

## CP.vec: 向量化

向量化是用来并发地执行多个任务而不需要引入显式同步的技术。操作可以简单地并行应用到数据结构（vector、数组等）的元素上。向量化有一个令人感兴趣的属性是，它通常不需要对程序进行非局部的修改。然而，向量化最适合用于简单的数据结构和专门为启用它而设计的算法。

向量化准则概要：

* ???
* ???

## CP.free: 无锁编程

使用`mutex`和`condition_variable`进行同步相对来说是昂贵的。而且，这会导致死锁。为了性能以及消除死锁的可能，我们有时不得不使用复杂的低层级的“无锁”设施，这些设施依赖于短暂获得的内存互斥（“原子性”）访问。无锁编程也用于实现高层级的并发机制，例如`thread`和`mutex`。

无锁编程准则概要：

* CP.100: 不要使用无锁编程，除非你绝对需要它
* CP.101: 不要相信你的硬件/编译器组合
* CP.102: 认真地学习资料
* 如何/何时使用原子
* 避免挨饿
* 使用无锁的数据结构，而不是手工编写特定的无锁访问
* CP.110: 不要为初始化编写你自己的双重检查锁
* CP.111: 如果你真的需要双重检查锁，使用传统的模式
* 如何/何时进行比较和交换

### CP.100: 不要使用无锁编程，除非你绝对需要它

##### 理由

这是容易出错的，而且需要对语言特性、机器架构和数据结构有专家级的知识。

##### 示例，不好的

```cpp
extern atomic<Link*> head;        // 链表的共享头部

Link* nh = new Link(data, nullptr);    // 创建一个准备用于插入的链表
Link* h = head.load();                 // 读取链表的共享头部

do {
    if (h->data <= data) break;        // 如果这样的话，插入到别的地方
    nh->next = h;                      // 下一个元素是上一个的头部 
} while (!head.compare_exchange_weak(h, nh));    // 把nh写入到头部或者写入到h
```

请找出缺陷。这会非常难以通过测试来发现。熟读一下ABA问题。

##### 例外

原子变量可以简单和安全地使用，只要你使用的是顺序一致的内存模型（`memory_order_seq_cst`），这是默认的。

##### 注意

高层级的并发机制，例如`thread`和`mutex`使用了无锁编程来实现。

**可选方案**：使用由其它库实现的无锁数据结构。

### CP.101: 不要相信你的硬件/编译器组合

##### 理由

由无锁编程使用的低层级硬件接口是最难实现得好的领域之一，也是出现最微妙的可移植性问题的领域之一。如果你为了性能使用无锁编程，你需要检查是否能回退。

##### 注意

引入重排序（静态的和动态的）使我们难以在这个层级上有效地思考（特别是如果你使用了宽松的内存模型）。经验表明，（半）正式的模型和模型检查是有用的。测试——通常去到极端的程度——是必不可少的。“不要飞得离太阳太近”。

##### 实施

要有强大的可重复测试规则，涵盖硬件、操作系统、编译器和库的任何更改。

### CP.102: 认真地学习资料

##### 理由

除了原子性和一些使用标准模式，无锁编程实际上是一个只针对专家的话题。在分发无锁代码给其它人使用之前，先成为这方面的专家。

##### 参考资料

* Anthony Williams: C++ concurrency in action. Manning Publications.
* Boehm, Adve, You Don't Know Jack About Shared Variables or Memory Models , Communications of the ACM, Feb 2012.
* Boehm, "Threads Basics", HPL TR 2009-259.
* Adve, Boehm, "Memory Models: A Case for Rethinking Parallel Languages and Hardware", Communications of the ACM, August 2010.
* Boehm, Adve, "Foundations of the C++ Concurrency Memory Model", PLDI 08.
* Mark Batty, Scott Owens, Susmit Sarkar, Peter Sewell, and Tjark Weber, "Mathematizing C++ Concurrency", POPL 2011.
* Damian Dechev, Peter Pirkelbauer, and Bjarne Stroustrup: Understanding and Effectively Preventing the ABA Problem in Descriptor-based Lock-free Designs. 13th IEEE Computer Society ISORC 2010 Symposium. May 2010.
* Damian Dechev and Bjarne Stroustrup: Scalable Non-blocking Concurrent Objects for Mission Critical Code. ACM OOPSLA'09. October 2009
* Damian Dechev, Peter Pirkelbauer, Nicolas Rouquette, and Bjarne Stroustrup: Semantically Enhanced Containers for Concurrent Real-Time Systems. Proc. 16th Annual IEEE International Conference and Workshop on the Engineering of Computer Based Systems (IEEE ECBS). April 2009.

### CP.110: 不要为初始化编写你自己的双重检查锁

##### 理由

自从C++11开始，静态局部变量现在会以线程安全的的方式来初始化。与RAII模式结合之后，静态局部变量可以代替你自己为初始化而写的双重检查锁的需要。`std::call_once`也可以达到相同的目的。应使用C++11的静态局部变量或者`std::call_once`，而不是为初始化而编写你自己的双重检查锁。

##### 示例

使用`std::call_once`的例子。

```cpp
void f()
{
    static std::once_flag my_once_flag;
    std::call_once(my_once_flag, []()
    {
        // 只做一次
    });
    // ...
}
```

使用C++11线程安全的静态局部变量的例子。

```cpp
 void f()
{
    // 假设编译器与C++11兼容
    static My_class my_object; // 构造函数只会调用一次
    // ...
}

class My_class
{
public:
    My_class()
    {
        // 只做一次
    }
};
```

##### 实施

??? 有可能检查出这种用法吗？

### CP.111: 如果你真的需要双重检查锁，使用传统的模式

##### 理由

双重检查锁容易变得混乱。如果你真的需要编写你自己的双重检查锁，而不理会“CP.110: 不要为初始化编写你自己的双重检查锁”和“CP.100: 不要使用无锁编程，除非你绝对需要它”，那么用传统的模式来编写它。

当一个非线程安全的行为既困难又罕见，并且有一个快速的线程安全测试方法可以用来确保这个行为是不需要的，但不能用来确保相反的情况，这时使用双重检查锁模式不会与“CP.110: 不要为初始化编写你自己的双重检查锁”冲突。

##### 示例，不好的

用`volatile`不会使第一次检查变得线程安全，参阅“CP.200: 只在与非C++内存交互时使用`volatile`”。

```cpp
mutex action_mutex;
volatile bool action_needed;

if (action_needed) {
    std::lock_guard<std::mutex> lock(action_mutex);
    if (action_needed) {
        take_action();
        action_needed = false;
    }
}
```

##### 示例，好的

```cpp
mutex action_mutex;
atomic<bool> action_needed;

if (action_needed) {
    std::lock_guard<std::mutex> lock(action_mutex);
    if (action_needed) {
        take_action();
        action_needed = false;
    }
}
```

当获取加载比顺序一致加载更高效的时候，微调内存顺序可能有好处。

```cpp
mutex action_mutex;
atomic<bool> action_needed;

if (action_needed.load(memory_order_acquire)) {
    lock_guard<std::mutex> lock(action_mutex);
    if (action_needed.load(memory_order_relaxed)) {
        take_action();
        action_needed.store(false, memory_order_release);
    }
}
```

##### 实施

??? 有可能检查出这种用法吗？

## CP.etc: 其它并发准则

这些准则不能简单地归类：

* CP.200: 只在与非C++内存交互时使用`volatile`
* CP.201: ??? 信号

### CP.200: 只在与非C++内存交互时使用`volatile`

##### 理由

`volatile`用来指代与“非C++”代码共享的对象，或者不遵循C++内存模型的硬件。

##### 示例

```cpp
const volatile long clock;
```

这里描述了一个通过时钟回路来更新的寄存器常量。`clock`为`volatile`，因为它的值会改变，无需使用它的C++程序执行任何操作。例如，读取`clock`两次通常会得到两个不同的值，所以优化器最好不要优化掉这个代码中的第二次读取：

```cpp
long t1 = clock;
// ... 这里没有使用时钟 ...
long t2 = clock;
```

`clock`为`const`，因为程序不应该试图写入`clock`。

##### 注意

除非你要编写最底层的代码来直接操作硬件，否则应把`volatile`看成是深奥的特性，最好避免使用。

##### 示例

通常C++代码会接收到由其它地方（硬件或其它语言）拥有的`volatile`内存：

```cpp
int volatile* vi = get_hardware_memory_location();
    // 注意：这里我们得到了指向其它地方的内存
    // volatile意味着“要额外小心地对待它”
```

有时候C++代码会分配`volatile`内存，并且有意地转成指针与“其它地方”（硬件或其它语言）共享：

```cpp
static volatile long vl;
please_use_this(&vl);   // 把引用转成指针，给“其它地方”（非C++）
```

##### 示例；不好的

`volatile`局部变量几乎总是错误的——如果它们是临时的，如何与其它语言或硬件共享？出于相同原因，这几乎同样适用于成员变量。

```cpp
void f() {
    volatile int i = 0; // 不好的，volatile局部变量
    // 其它
}

class My_type {
    volatile int i = 0; // 有问题的，volatile成员变量
    // 其它
};
```

##### 注意

在C++中，不像一些其它语言，`volatile`“对同步没有没有作用”。

##### 实施

* 标记出`volatile T`局部或成员变量；几乎可以确定你要用`atomic<T>`来代替。
* ???

### CP.201：??? 信号

??? UNIX信号处理 ???。也许值得提醒一下，异步信号安全性有多么少，以及如何与信号处理器通信（最好的做法可能是“根本不做”）。

# E: 错误处理

错误处理包括：

* 检测错误
* 把错误的相关信息传递给某些处理代码
* 使程序维持在有效的状态
* 避免资源泄露

从所有错误中恢复是不可能的。如果不可能从某个错误中恢复，以定义良好的方式快速“脱离”是很重要的。错误处理的策略必须简单，否则它会变成更严重的错误的来源。未经测试以及很少执行的错误处理代码本身也是许多缺陷的来源。

这些准则旨在帮助避免几种类型的错误：

* 类型违规（例如，误用`union`和转型）
* 资源泄露（包括内存泄露）
* 边界错误
* 生命周期错误（例如，在对象被删除之后还访问它）
* 复杂度错误（过于复杂地表达想法造成的逻辑错误）
* 接口错误（例如，意外的值传入接口）

错误处理准则概要：

* E.1: 尽早在设计中想好错误处理策略
* E.2: 抛出异常来表示函数不能完成交给它的任务
* E.3: 只为错误处理而使用异常
* E.4: 围绕不变式来设计你的错误处理策略
* E.5: 让构造函数建立不变式，如果不能建立则抛出异常
* E.6: 使用RAII来避免泄露
* E.7: 声明你的前置条件
* E.8: 声明你的后置条件
* E.12: 如果通过`throw`来退出函数是不可能的或者不可接受，使用`noexcept`
* E.13: 当作为对象的直接所有者时，永远不要抛异常
* E.14: 使用专门设计的用户定义类型作为异常（不是内置类型）
* E.15: 通过引用来捕捉层次结构中的异常
* E.16: 析构函数、释放和`swap`永远不能失败
* E.17: 不要试图在每个函数中捕捉每个异常
* E.18: 尽量减少使用显式的`try`/`catch`
* E.19: 如果没有合适的资源句柄可用，使用`final_action`对象来进行清理
* E.25: 如果你不能抛出异常，模仿RAII进行资源管理
* E.26: 如果你不能抛出异常，考虑快速地失败
* E.27: 如果你不能抛出异常，系统性地使用错误码
* E.28: 避免基于全局状态的错误处理（例如`errno`）
* E.30: 不要使用异常规约
* E.31: 正确地排列你的`catch`子句

### E.1: 尽早在设计中想好错误处理策略

##### 理由

处理错误和资源泄漏的一致且完整的策略难以加入到已有的系统中。

### E.2: 抛出异常来表示函数不能完成交给它的任务

##### 理由

使错误处理有条理、健壮以及不会重复。

##### 示例

```cpp
struct Foo {
    vector<Thing> v;
    File_handle f;
    string s;
};

void use()
{
    Foo bar {{Thing{1}, Thing{2}, Thing{monkey}}, {"my_file", "r"}, "Here we go!"};
    // ...
}
```

这里，`vector`和`string`的构造函数也许不能为它们的元素分配足够的内存，`vector`的构造函数也许不能在它的初始化器列表中拷贝`Thing`列表，`File_handle`也许不能打开需要的文件。在每种情况下，它们都会抛出异常让`user()`的调用者来处理。如果`use()`可以处理这些失败来构造`bar`，它可以使用`try`/`catch`来接管。在所有情况下，在把控制交给试图创建`Foo`的地方之前，`Foo`的构造函数都能正确地销毁已构造的成员。注意，不存在包含错误码的返回值。

`File_handle`的构造函数可能会定义成这样：

```cpp
File_handle::File_handle(const string& name, const string& mode)
    :f{fopen(name.c_str(), mode.c_str())}
{
    if (!f)
        throw runtime_error{"File_handle: could not open " + name + " as " + mode};
}
```

##### 注意

 人们常说，异常用来表示异常的事件和失败。然而，这有点循环论证，因为“什么东西是异常的？”。例子：

 * 不能满足的前置条件
 * 不能构造对象的构造函数（不能建立类的不变式）
 * 超出范围错误（例如`v[v.size()] = 7`）
 * 不能取得资源（例如，网络断开了）

相反，终止普通循环不是异常的。除非该循环是无限的，否则终止是正常的且符合预期。

##### 注意

不要使用`throw`作为从函数中返回值的替代方式。

##### 例外

有些系统，例如硬实时系统，需要保证一个行为要在一段已知的常量时间（通常很短）内执行。只有在有工具支持，能精确地预测从异常中恢复的最大时间的情况下，这些系统才能使用异常。

*另见*：RAII

*另见*：讨论

##### 注意

在你决定不能接受或不喜欢基于异常的错误处理之前，看一下其它替代方案；它们有自己的复杂性和问题。而且，可能的话，在作出关于效率的声明之前先进行测量。

### E.3: 只为错误处理而使用异常

##### 理由

为了使“普通代码”与错误处理分离。C++的实现往往是基于异常很少发生的假设进行优化的。

##### 示例，不要这样做

```cpp
// 不要这样做：异常不用于错误处理
int find_index(vector<string>& vec, const string& x)
{
    try {
        for (gsl::index i = 0; i < vec.size(); ++i)
            if (vec[i] == x) throw i;  // 找到x
    } catch (int i) {
        return i;
    }
    return -1;   // 没找到
}
```

这样做会更复杂，而且更可能比其它明显的方法运行地更慢。在`vector`中找到一个值没有任何异常。

##### 实施

需要使用启发式的。查找“泄露”出`catch`子句的异常值。

### E.4: 围绕不变式来设计你的错误处理策略

##### 理由

要使用一个对象，它必须处于有效的状态（由不变式正式或非正式地定义），而且，为了从错误中恢复，每个未销毁的对象都必须处于有效的状态。

##### 注意

不变式是一个作用于对象成员的逻辑条件，必须由构造函数来建立，并在公有成员函数中假定该不变式成立。

##### 实施

???

### E.5: 让构造函数建立不变式，如果不能建立则抛出异常

##### 理由

留下一个没有建立好不变式的对象是自找麻烦。不是所有成员函数都可以调用。

##### 示例

```cpp
class Vector {  // 非常简化的保存double的vector
    // 如果 elem != nullptr 那么elem指向以0结尾的double数组
public:
    Vector() : elem{nullptr}, sz{0}{}
    Vector(int s) : elem{new double[s]}, sz{s} { /* 初始化元素 */ }
    ~Vector() { delete [] elem; }
    double& operator[](int s) { return elem[s]; }
    // ...
private:
    owner<double*> elem;
    int sz;
};
```

这个类的不变式——在注释中声明——由构造函数来建立。如果不能分配所需的内存，`new`会抛出异常。它的操作符，尤其是下标操作符，依赖于这个不变式。

**另见**：如果构造函数不能构造有效的对象，那么抛出异常。

##### 实施

标记出具有`private`状态而没有构造函数（公有的，受保护的或者私有的）的类。

### E.6:　使用RAII来避免泄露

##### 理由

泄露通常是不可接受的。手动的资源释放是容易出错的。RAII（“资源获取即初始化”）是避免泄露最简单、最系统性的方式。

##### 示例

```cpp
void f1(int i)   // 不好的：有可能泄露
{
    int* p = new int[12];
    // ...
    if (i < 17) throw Bad{"in f()", i};
    // ...
}
```

我们可能会在抛出异常之前小心地释放资源：

```cpp
void f2(int i)   // 愚蠢且容易出错：显式地释放
{
    int* p = new int[12];
    // ...
    if (i < 17) {
        delete[] p;
        throw Bad{"in f()", i};
    }
    // ...
}
```

这是啰嗦的。在多个地方都可能抛出异常的更大型的代码中，显式释放变得重复和容易出错。

```cpp
void f3(int i)   // 没问题：资源管理由句柄来完成（不过看一下下面的说明）
{
    auto p = make_unique<int[]>(12);
    // ...
    if (i < 17) throw Bad{"in f()", i};
    // ...
}
```

要注意，即使抛出异常隐式地发生在被调用函数中，这种做法也能起作用：

```cpp
void f4(int i)   // 没问题：资源管理由句柄来完成（不过看一下下面的说明）
{
    auto p = make_unique<int[]>(12);
    // ...
    helper(i);   // 可能抛出异常
    // ...
}
```

除非你真的需要指针语义，否则使用局部资源对象：

```cpp
void f5(int i)   // 没问题：资源管理由局部对象来完成
{
    vector<int> v(12);
    // ...
    helper(i);   // 可能抛出异常
    // ...
}
```

这甚至会更简单和更安全，而且通常会更高效。

##### 注意

如果没有明显的资源句柄，而且由于某些原因定义一个合适的RAII对象/句柄不可行，作为最后的手段，清理行为可以用`final_action`对象来表示。

##### 注意

但是如果我们正在写一个不能使用异常的程序，该怎么办呢？首先要挑战这个假定；存在很多反异常的神话。我们只知道几个好的理由：

* 我们在一个很小的系统上工作，对异常的支持会吃掉我们2K内存的大部分。
* 我们在一个硬实时系统上工作，我们没有工具来保证可以在规定的时间内处理完异常。
* 我们在一个存在大量遗留代码的系统上工作，这些代码以难以理解的方式使用了很多指针（尤其是没有一个可识别的所有权策略），因此异常会导致泄露。
* 我们的C++异常机制的实现不合理地差劲（慢，耗费内存，不能正确地与动态链接库使用等等）。向你的实现提供商投诉；如果没有用户投诉，就不会有改善。
* 如果我们挑战经理的远古智慧，我们会被解雇。

在这些理由中只有第一个是根本的，所以只要有可能，就使用异常来实现RAII，或者将你的RAII对象对象设计为永远不会失败。当异常不能使用的时候，模仿RAII。也就是说，系统地检查对象在构造之后是有效的，并且仍然在析构函数中释放所有资源。一个策略是添加`valid()`操作到每个资源句柄中：

```cpp
void f()
{
    vector<string> vs(100);   // 并非std::vector：添加了valid()
    if (!vs.valid()) {
        // 处理错误或退出
    }

    ifstream fs("foo");   // 并非std::ifstream：添加了valid()
    if (!fs.valid()) {
        // 处理错误或退出
    }

    // ...
} // 析构函数像往常一样清理
```

显然，这增加了代码的大小，不允许隐式的“异常”（`valid()`的检查）传播，而且`valid()`检查可能会被忘记。应优先使用异常。

**另见**：使用`noexcept`。

##### 实施

???

### E.7: 声明你的前置条件

##### 理由

避免接口错误。

**另见**：前置条件准则

### E.8: 声明你的后置条件

##### 理由

避免接口错误。

**另见**：后置条件准则

### E.12: 如果通过`throw`来退出函数是不可能的或者不可接受，使用`noexcept`

##### 理由

使错误处理有系统性，健壮，以及高效。

##### 示例

```cpp
double compute(double d) noexcept
{
    return log(sqrt(d <= 0 ? 1 : d));
}
```

这里，我们知道`compute`不会抛出异常，因为它由不会抛出异常的操作组成。通过声明`compute`为`noexcept`，我们为编译器和人类读者提供了信息，可以让他们更容易理解和操作`compute`。

##### 注意

很多标准库函数是`noexcept`，包括所有从C标准库“继承”的标准库函数。

##### 示例

```cpp
vector<double> munge(const vector<double>& v) noexcept
{
    vector<double> v2(v.size());
    // ... 做些事情 ...
}
```

这里的`noexcept`说明我不希望或不能够处理我构造不了局部`vector`的情况。也就是说，我认为内存耗尽是一个严重的设计错误（与硬件错误相当），因此我希望当它发生的时候要让程序崩溃。

##### 注意

不要使用传统的“异常规约”。

##### 另见

讨论。

### E.13: 当作为对象的直接所有者时，永远不要抛异常

##### 理由

这会导致泄露。

##### 示例

```cpp
void leak(int x)   // 不要这样做：会泄露
{
    auto p = new int{7};
    if (x < 0) throw Get_me_out_of_here{};  // 会泄露*p
    // ...
    delete p;   // 我们可能永远不会执行到这里
}
```

避免这类问题的一种方式是始终如一地使用资源句柄：

```cpp
void no_leak(int x)
{
    auto p = make_unique<int>(7);
    if (x < 0) throw Get_me_out_of_here{};  // 如果必要的话会删除*p
    // ...
    // 不需要删除p
}
```

其它方案（通常更好）是使用局部变量来消除显式地使用指针：

```cpp
void no_leak_simplified(int x)
{
    vector<int> v(7);
    // ...
}
```

##### 注意

如果你有局部的“东西”需要清理，但它不是通过具有析构函数的对象来表示，那么这种清理在`throw`之前也必须执行。有时候，`finally()`会让这类不系统的清理更加可管理一些。

### E.14: 使用专门设计的用户定义类型作为异常（不是内置类型）

##### 理由

用户定义类型不太可能与其它人的异常冲突。

##### 示例

```cpp
void my_code()
{
    // ...
    throw Moonphase_error{};
    // ...
}

void your_code()
{
    try {
        // ...
        my_code();
        // ...
    }
    catch(const Bufferpool_exhausted&) {
        // ...
    }
}
```

##### 示例，不要这样做

```cpp
void my_code()     // 不要这样做
{
    // ...
    throw 7;       // 7意味着“第四季度的月亮”
    // ...
}

void your_code()   // 不要这样做
{
    try {
        // ...
        my_code();
        // ...
    }
    catch(int i) {  // i == 7 意味着“输入缓冲区太小”
        // ...
    }
}
```

##### 注意

从`exception`派生的标准库类应该只用作基类，或者只用于只需要“泛型”处理的异常。像内置类型一样，使用它们会与其它也使用了它们的人冲突。

##### 示例，不要这样做

```cpp
void my_code()   // 不要这样做
{
    // ...
    throw runtime_error{"moon in the 4th quarter"};
    // ...
}

void your_code()   // 不要这样做
{
    try {
        // ...
        my_code();
        // ...
    }
    catch(const runtime_error&) {   // runtime_error意味着“输入缓冲区太小”
        // ...
    }
}
```

**另见**：讨论

##### 实施

捕捉对内置类型的`throw`和`catch`。也许对使用了标准库`exception`类型的`throw`和`catch`也进行警告。显然，从`std::exception`层次结构派生的异常是没问题的。

### E.15: 通过引用来捕捉层次结构中的异常

##### 理由

避免对象切割。

##### 示例

```cpp
void f()
{
    try {
        // ...
    }
    catch (exception e) {   // 不要这样做：可能会被切割
        // ...
    }
}
```

相反，应使用引用：

```cpp
catch (exception& e) { /* ... */ }
```

或者——通常是更好的做法——使用`const`引用：

```cpp
catch (const exception& e) { /* ... */ }
```

大部分异常处理不会修改它们的异常，因此一般我们建议使用`const`。

##### 注意

使用`throw;`来重新抛出已被捕获的异常，而不是`throw e;`。使用`throw e;`会抛出`e`的拷贝（被切割成静态的`std::exception`类型），而不是重新抛出原始的类型为`std::runtime_error`的异常。（但是要记住“不要试图捕捉每个函数中的每个异常”，以及“尽量减少显式地使用`try`/`catch`”）

##### 实施

如果异常的类型是层次结构的一部分，标记出按值传递它们的地方（可能需要全程序分析来做到完美）。

### E.16: 析构函数、释放和`swap`永远不能失败

##### 理由

如果析构函数、交换或者内存释放会失败，也就是说，这些操作通过异常来退出，或者不能执行必要的行为，那么我们不知道如何写出可靠的程序。

##### 示例，不要这样做

```cpp
class Connection {
    // ...
public:
    ~Connection()   // 不要这样做：非常糟糕的析构函数
    {
        if (cannot_disconnect()) throw I_give_up{information};
        // ...
    }
};
```

##### 注意

很多人试图写出违反这个准则例子的可靠代码，例如“拒绝关闭”的网络连接。就我们所知，没有人找到这样做的通用方法。有时候，对于非常特定的例子，你可以设置一些状态以在将来进行清理，用这种方式来解决。例如，我们可以把不能关掉的套接字放到一个“坏掉的套接字”列表中，由系统状态的常规清扫程序来检查这些套接字。我们见过的每种例子都是容易出错的，专用的，而且通常有许多缺陷。

##### 注意

标准库假定了析构函数、释放内存函数（例如`operator delete`）和`swap`不会抛出异常。如果它们这样做，基础的标准库不变式会遭到破坏。

##### 注意

释放内存函数，包括`operator delete`，必须为`noexcept`。`swap`函数必须为`noexcept`。大多数析构函数默认隐式为`noexcept`。另外，使移动操作为`noexcept`。

##### 实施

捕捉会抛出异常的析构函数、释放内存操作和`swap`。捕捉这些函数中没有声明为`noexcept`的。

**另见**：讨论

### E.17: 不要试图在每个函数中捕捉每个异常

##### 理由

在不能执行有意义的恢复行为的函数中捕捉异常会导致复杂性和浪费。让异常扩散，直到到达能够处理它的函数。让堆栈展开路径上的清理行为由RAII来处理。

##### 示例，不要这样做

```cpp
void f()   // 不好的
{
    try {
        // ...
    }
    catch (...) {
        // 没有行为
        throw;   // 扩散异常
    }
}
```

##### 实施

* 标记出嵌套的`try`语句块。
* 标记出在函数中具有过高`try`语句块比率的源代码文件。（??? 问题：定义“过高”）

### E.18: 尽量减少使用显式的`try`/`catch`

##### 理由

`try`/`catch`是啰嗦的，并且过量的使用容易出错。`try`/`catch`是代码没有条理，以及/或者是低层级资源管理或错误处理的信号。

##### 理由，不好的

```cpp
void f(zstring s)
{
    Gadget* p;
    try {
        p = new Gadget(s);
        // ...
        delete p;
    }
    catch (Gadget_construction_failure) {
        delete p;
        throw;
    }
}
```

这个代码是混乱的。在`try`语句块中，裸露的指针可能会泄露。不是所有异常都被处理。用`delete`删除一个构造失败的对象几乎可以确定是错误。更好的做法：

```cpp
void f2(zstring s)
{
    Gadget g {s};
}
```

##### 替代方案

* 合适的资源句柄以及RAII
* `finally`

##### 实施

??? 困难，需要启发式方法

### E.19: 如果没有合适的资源句柄可用，使用`final_action`对象来进行清理

##### 理由

比起`try`/`catch`，`finally`没那么啰嗦，更难出错。

##### 示例

```cpp
void f(int n)
{
    void* p = malloc(1, n);
    auto _ = finally([p] { free(p); });
    // ...
}
```

##### 注意

`finally`没有`try`/`catch`那么混乱，但它仍然是临时的解决方案。优先使用“合适的资源管理对象”。把`finally`看成是最后的手段。

##### 注意

比起老的“`goto exit;`技术”，使用`finally`是有条理且合理的清理替代方法，用于在资源管理缺乏系统性的情况下处理清理工作。

##### 实施

启发式：检测`goto exit;`

### E.25: 如果你不能抛出异常，模仿RAII进行资源管理

##### 理由

即使没有异常，RAII也通常是最好且最系统的方式来处理资源。

##### 注意

使用异常的错误处理是处理C++中非局部错误的唯一完整且系统的方式。尤其是，非侵入性地表示构造对象失败需要异常。以不能忽略的方式表示错误需要异常。如果你不能使用异常，尽你所能模仿它们的使用。

很多对异常的畏惧是被误导的。如果代码中没有到处都是指针和复杂的控制结构，当用于异常情况时，异常处理几乎总是值得的（在时间和空间上），而且几乎总是会产出更好的代码。当然，这要基于异常处理机制有良好实现的基础上，而这并非在所有系统上都有。还有一些情况是上面的问题不存在，但由于其它原因而不能使用异常。一些硬实时系统是一个例子：一个操作必须在固定的时间内以一个错误或正确的答案完成。在缺少适当的时间评估工具时，对于异常这是难以保证的。这类系统（例如飞行控制软件）通常也会禁止使用动态（堆）内存。

因此，错误处理的主要方针是“使用异常和RAII”。这部分内容是针对缺乏一个高效的异常实现，或者具有像兔子洞一样的旧代码（例如，很多指针，定义不良的所有权，以及很多基于错误码检查的不成体系的错误处理）的情况，在这些情况下引入简单且有体系的异常处理是不可行的。

在谴责异常或者对它们的开销抱怨太多之前，考虑使用错误码的例子。考虑使用错误码的开销和复杂性。如果性能是你担心的事情，要进行测量。

##### 示例

假设你想要写：

```cpp
void func(zstring arg)
{
    Gadget g {arg};
    // ...
}
```

如果`gadget`没有正确地构造，`func`会以异常来退出。如果我们不能抛出异常，我们可以通过在`Gadget`中添加一个`valid()`成员函数来模拟这种RAII风格的资源管理：

```cpp
error_indicator func(zstring arg)
{
    Gadget g {arg};
    if (!g.valid()) return gadget_construction_error;
    // ...
    return 0;   // 0表示“没问题”
}
```

当然，这里的问题是调用者现在必须记得检查返回值。

**另见**：讨论

##### 实施

可能（只）是这个想法的特定版本：例如，检查在构造资源句柄后是否有系统地检查`valid()`。

### E.26: 如果你不能抛出异常，考虑快速地失败

##### 理由

如果你不能做好恢复工作，至少你可以在造成更多后续的损害之前逃离。

**另见**：模拟RAII

##### 注意

如果你不能有条理地进行错误处理，考虑以“崩溃”作为对任何不能局部处理的错误的回应。也就是说，如果你不能从检测到错误的函数中恢复，调用`abort()`、`quick_exit()`或者类似的会触发某种系统重启的函数。

在你具有很多进程以及/或者很多电脑的系统中，不管怎样你都要预期和处理致命的崩溃，例如硬件故障。在这种情况下，“崩溃”简单地把错误处理交给系统的下一层级。

##### 示例

```cpp
void f(int n)
{
    // ...
    p = static_cast<X*>(malloc(n, X));
    if (!p) abort();     // 如果内存耗尽，终止
    // ...
}
```

大部分程序不管怎样都不能优雅地处理内存耗尽。这大概相当于：

```cpp
void f(int n)
{
    // ...
    p = new X[n];    // 如果内存耗尽，抛出异常（默认是终止程序）
    // ...
}
```

通常，在退出之前记录下“崩溃”的原因是一个好想法。

##### 实施

棘手的。

### E.27: 如果你不能抛出异常，系统性地使用错误码

##### 理由

有体系地使用任何错误处理策略能尽量减少忘记处理错误的机会。

**另见**：模拟RAII

##### 注意

有几个问题要处理：

* 你如何从函数中传出错误指示？
* 你如何在错误退出之前释放函数中所有的资源？
* 你使用什么东西作为错误指示？

通常，返回错误指示意味着返回两个值：结果和错误指示。错误指示可以是对象的一部分，例如，可以返回一个有`valid()`指示函数的对象，或者返回一对值。

##### 示例

```cpp
Gadget make_gadget(int n)
{
    // ...
}

void user()
{
    Gadget g = make_gadget(17);
    if (!g.valid()) {
            // 错误处理
    }
    // ...
}
```

这个方法适合“模拟RAII资源管理”。`valid()`函数会返回一个`error_indicator`（例如，`error_indicator`枚举的一个成员）。

##### 示例

如果我们不能或者不想修改`Gadget`类型怎么办？这时，我们必须返回一对值。例如：

```cpp
std::pair<Gadget, error_indicator> make_gadget(int n)
{
    // ...
}

void user()
{
    auto r = make_gadget(17);
    if (!r.second) {
            // 错误处理
    }
    Gadget& g = r.first;
    // ...
}
```

如上所示，`std::pair`是可能的返回类型。有些人更喜欢具体的类型。例如：

```cpp
Gval make_gadget(int n)
{
    // ...
}

void user()
{
    auto r = make_gadget(17);
    if (!r.err) {
            // 错误处理
    }
    Gadget& g = r.val;
    // ...
}
```

更喜欢具体返回类型的一个原因是它的成员有名称，而不是有些晦涩的`first`和`second`，以及避免与其它`std::pair`的使用混淆。

##### 示例

通常，你必须在错误退出之前进行清理。这可能会造成混乱：

```cpp
std::pair<int, error_indicator> user()
{
    Gadget g1 = make_gadget(17);
    if (!g1.valid()) {
            return {0, g1_error};
    }

    Gadget g2 = make_gadget(17);
    if (!g2.valid()) {
            cleanup(g1);
            return {0, g2_error};
    }

    // ...

    if (all_foobar(g1, g2)) {
        cleanup(g1);
        cleanup(g2);
        return {0, foobar_error};
    // ...

    cleanup(g1);
    cleanup(g2);
    return {res, 0};
}
```

模拟RAII是重要的，特别是在有多个资源和多个可能错误的函数中。一个常见的技术是在函数的末尾聚集清理来避免重复：

```cpp
std::pair<int, error_indicator> user()
{
    error_indicator err = 0;

    Gadget g1 = make_gadget(17);
    if (!g1.valid()) {
            err = g1_error;
            goto exit;
    }

    Gadget g2 = make_gadget(17);
    if (!g2.valid()) {
            err = g2_error;
            goto exit;
    }

    if (all_foobar(g1, g2)) {
        err = foobar_error;
        goto exit;
    }
    // ...

exit:
    if (g1.valid()) cleanup(g1);
    if (g2.valid()) cleanup(g2);
    return {res, err};
}
```

函数越长，这个技术会越有吸引力。`finally`可以“消除一些痛苦”。而且，程序变得越大，越难有体系地应用基于错误指示的错误处理策略。

我们“优先使用基于异常的错误处理”，并且建议“保持函数短小”。

**另见**：讨论

**另见**：返回多个值

##### 实施

棘手的。

### E.28: 避免基于全局状态的错误处理（例如`errno`）

##### 理由

全局状态难以管理，而且容易忘记去检查。你最近一次检查`printf()`的返回值是什么时候？

**另见**：模拟RAII。

##### 示例，不好的

```cpp
???
```

##### 注意

C风格的错误处理基于全局变量`errno`，因此基本上不可能完全避免这种风格。

##### 实施

棘手的。

### E.30: 不要使用异常规约

##### 理由

异常规约使错误处理变得脆弱，强加了运行时开销，而且已经从C++标准移除了。

##### 示例

```cpp
int use(int arg)
    throw(X, Y)
{
    // ...
    auto x = f(arg);
    // ...
}
```

如果`f()`抛出了不同于`X`和`Y`的异常，意外处理程序会被调用，该程序默认会终止程序。这没问题，但假如我们已经检查过这不可能发生，然后`f`被修改成抛出了新的异常`Z`，那么我们现在会遇到崩溃，除非我们修改`use()`（并且重新测试所有东西）。这里的问题是`f()`可能在一个我们无法控制的库中，而且新的异常并非`use()`可以处理或者感兴趣的东西。我们可以修改`use()`来传递`Z`，但现在`use()`的调用者很可能也需要修改。这很快会变得无法管理。另一种方法是，我们可以在`use()`中添加`try`-`catch`，把`Z`映射到一个可接受的异常。这同样也会很快变得无法管理。要注意修改异常集通常发生在系统的最底层（例如由于修改了网络库或者其它中间件），所以这个修改会像“气泡上升”那样穿过长长的调用链。在一个大型的代码库中，这意味着没有人可以更新到库的新版本，直到最后一个用户修改了。如果`use()`是库的一部分，不可能更新它，因为修改会影响未知的客户。

让异常扩散，直到遇到一个能够处理的它的函数，这个策略经过这么多年已经证明了它自己。

##### 注意

不。假如异常规范静态地实施，也不会好到哪里去。参阅“Stroustrup94”的例子。

##### 注意

如果没有异常抛出，使用`noexcept`或者与它相同的`throw()`。

##### 实施

标记出每一个异常规约。

### E.31: 正确地排列你的`catch`子句

##### 理由

`catch`子句按照它们出现的顺序来求值，一个子句可以屏蔽其它子句。

##### 示例

```cpp
void f()
{
    // ...
    try {
            // ...
    }
    catch (Base& b) { /* ... */ }
    catch (Derived& d) { /* ... */ }
    catch (...) { /* ... */ }
    catch (std::exception& e){ /* ... */ }
}
```

如果`Derived`派生自`Base`，`Derived`的处理程序将永远不会调用。“捕捉所有东西”的处理程序确保了`std::exception`的处理程序将永远不会调用。

##### 实施

标记出所有“屏蔽处理程序”的情况。

## Con: 常量和不变性

在常量上你不会遇到竞争条件。当很多对象都不能改变它们的值时，更容易理解程序。承诺对传入的参数对象“无修改”的接口很好地增加了可读性。

常量准则概要：

* Con.1: 默认情况下，使对象不可变
* Con.2: 默认情况下，使成员函数为`const`
* Con.3: 默认情况下，传递指针和引用给`const`
* Con.4: 使用`const`来定义在构造之后不会改变值的对象
* Con.5: 对可以在编译时计算的值使用`constexpr`

### Con.1: 默认情况下，使对象不可变

##### 理由

不可变对象更容易理解，因此只有在需要改变对象的值时才让对象为非`const`。避免意外或者难以注意到的修改。

##### 示例

```cpp
for (const int i : c) cout << i << '\n';    // 只是读取：const

for (int i : c) cout << i << '\n';          // 不好的：只是读取
```

##### 例外

函数参数很少改变，但也很少声明为`const`。为了避免混淆和大量误报，不要对函数参数实施这个准则。

```cpp
void f(const char* const p); // 书呆子气
void g(const int i);        // 书呆子气
```

注意函数参数是局部变量，所以对它的修改是局部的。

##### 实施

* 标记出不会修改的非`const`变量（除了参数，来避免大量误报）。

### Con.2: 默认情况下，使成员函数为`const`

##### 理由

成员函数应该标记为`const`，除非它修改了对象的可观察的状态。这为设计意图提供了更精确的说明，更好的可读性，更多由编译器捕捉的错误，以及有时候更多的优化机会。

##### 示例；不好的

```cpp
class Point {
    int x, y;
public:
    int getx() { return x; }    // 不好的，应该为const，因为它不修改对象的状态
    // ...
};

void f(const Point& pt) {
    int x = pt.getx();          // 错误的，不会通过编译，因为getx没有标记为const
}
```

##### 注意

传递指针或引用到非`const`没有内在的坏处，但这只应该在被调用函数要修改对象的时候才这么做。代码的读者必然认为接收一个“纯”`T*`或`T&`的函数会修改被指向的对象。如果它现在没有这么做，它可能会在将来这么做，而不需要强迫重新编译。

##### 注意

有些代码/库提供声明了`T*`的函数，即使这些函数不会修改`T`。对于对代码进行现代化的人来说这是一个问题。你可以

* 更新到具有正确`const`的库；优先选择长期的解决方案
* “转型去掉`const`”；最好避免这样做
* 提供一个包装函数

例如：

```cpp
void f(int* p);   // 旧代码：f()不会修改`*p`
void f(const int* p) { f(const_cast<int*>(p)); } // 包装
```

注意这个包装解决方案是一个补丁，只应在不能修改`f()`的声明时使用，例如，由于它位于一个你不能修改的库中。

##### 注意

`const`成员函数可以修改声明为`mutable`或者通过指针成员访问的对象的值。一种常见的用法是维护缓存而不是重复做复杂的计算。例如，这里有一个`Date`缓存（存储）了它的字符串表示来简化重复的使用：

```cpp
class Date {
public:
    // ...
    const string& string_ref() const
    {
        if (string_val == "") compute_string_rep();
        return string_val;
    }
    // ...
private:
    void compute_string_rep() const;    // 计算字符串表示，然后放进string_val
    mutable string string_val;
    // ...
};
```

对这种做法的另一种说法是，`const`性是不可传递的。`const`成员函数可能修改`mutable`成员的值，以及通过非`const`指针访问的对象的值。这是类的责任来确保这种改变只会在根据提供给用户的语义（不变式）来说是合理的时候发生。

**另见**：Pimpl

##### 实施

* 标记出没有标记为`const`的成员函数，但该函数没有在任何成员变量上执行非`const`操作。

### Con.3: 默认情况下，传递指针和引用给`const`

##### 理由

避免被调用函数意外地修改了值。当调用不会修改状态的函数时，更容易理解程序。

##### 示例

```cpp
void f(char* p);        // f会修改*p吗？（认为会修改）
void g(const char* p);  // g不会修改*p
```

##### 注意

传递指针或引用到非`const`没有内在的坏处，但这只应该在被调用函数要修改对象的时候才这么做。

##### 注意

“不要转型去掉`const`”。

#### 实施

* 标记出不会修改以非`const`指针或引用传递的对象的函数。
* 标记出会（使用转型）修改以`const`指针或引用传递的对象的函数。

### Con.4: 使用`const`来定义在构造之后不会改变值的对象

##### 理由

防止无意修改了对象值带来的意外。

##### 示例

```cpp
void f()
{
    int x = 7;
    const int y = 9;

    for (;;) {
        // ...
    }
    // ...
}
```

由于`x`不是`const`，我们必须认为它会在循环的某处被修改。

##### 实施

* 标记出未被修改的非`const`变量。

### Con.5: 对可以在编译时计算的值使用`constexpr`

##### 理由

更好的性能，更好的编译时检查，得到保障的编译时求值，不可能发生竞争条件。

##### 示例

```cpp
double x = f(2);            // 可能在运行时求值
const double y = f(2);      // 可能在运行时求值
constexpr double z = f(2);  // 除非f(2)可以在编译时求值，否则会出错
```

##### 注意

参阅F.4。

##### 实施

* 标记出具有常量表达式初始化的`const`定义。

# T: 模板和泛型编程

泛型编程是使用类型和算法的编程，这些类型和算法按照类型、值和算法进行参数化。在C++中，泛型编程由`template`语言机制支持。

泛型函数的参数以参数类型和传入值的一系列要求为特性。在C++中，这些要求由称为概念的编译时判断式来表示。

模板也可以用于元编程；即在编译时生成代码的程序。

泛型编程的核心理念是“概念”；也就是说，在模板参数上的要求表示为编译时判断式。“概念”定义于ISO技术规范：[concepts](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4553.pdf)。一组标准库概念的草案可以在其它ISO TS中找到：[ranges](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf)。概念在GCC 6.1及之后的版本中支持。所以，我们在示例中用注释来使用概念；即我们只以形式化的注释来使用它们。如果你使用GCC 6.1或之后的版本，你可以去掉对它们的注释。

模板使用准则概要：

* T.1: 使用模板来提升代码的抽象层级
* T.2: 使用模板来表达适用于很多参数类型的算法
* T.3: 使用模板来表达容器和范围
* T.4: 使用模板来表达语法树操作
* T.5: 结合泛型和OO技术来放大它们的优势，而不是它们的代价

概念使用准则概要：

* T.10: 为所有模板参数指定概念
* T.11: 尽可能使用标准概念
* T.12: 优先为局部变量使用概念名称而不是`auto`
* T.13: 优先为简单的、单类型参数的概念使用简化符号
???

概念定义准则概要：

* T.20: 避免无有意义语义的“概念”
* T.21: 为概念提供一组完整的操作
* T.22: 为概念指定公理
* T.23: 通过添加新的使用模式，将提炼后的概念与更一般的情况区分开来
* T.24: 使用标签类或者特性来区分只是语义上不同的概念
* T.25: 避免互补的约束
* T.26: 优先在使用模式方面定义概念，而不是在简单语法方面
* T.30: 有节制地使用概念取反（`!C<T>`）来表达微小的差异
* T.31: 有节制地使用概念分离（`C1<T> || C2<T>`）来表达选择
* ???

模板接口准则概要：

* T.40: 使用函数对象来传递算法操作
* T.41: 在模板的概念中只要求基本的属性
* T.42: 使用模板别名来简化符号以及隐藏实现细节
* T.43: 优先使用`using`而不是`typedef`来定义别名
* T.44: 使用函数模板来推导类模板的参数类型（可行的情况下）
* T.46: 要求模板参数至少为`Regular`或`SemiRegular`
* T.47: 避免具有通用名称的高度可见未受约束的模板
* T.48: 如果你的编译器不支持概念，用`enable_if`来伪造
* T.49: 尽可能避免类型擦除

模板定义准则概要：

* T.60: 尽量减少模板的上下文依赖
* T.61: 不要过度参数化成员（SCARY）
* T.62: 把无依赖的类模板成员放在非模板的基类中
* T.64: 使用特化来提供类模板的其它实现
* T.65: 使用标签派发来提供函数的其它实现
* T.67: 使用特化来为非常规类型提供其它实现
* T.68: 在模板中使用`{}`而不是`()`来避免歧义
* T.69: 在模板中，不要进行无限定的非成员函数调用，除非你的意图是让它成为一个定制化点

模板和层次结构准则概要：

* T.80: 不要天真地模板化类层次结构
* T.81: 不要混合层次结构和数组 // ??? 在“层次结构”的某个地方
* T.82: 当不需要虚函数时，使层次结构线性化
* T.83: 不要把成员函数模板声明为虚拟的
* T.84: 使用非模板的核心实现来提供一个ABI稳定的接口
* T.??: ???

可变模板准则概要：

* T.100: 当你需要一个函数，该函数可以接收各种类型、数量可变的参数时，使用可变模板
* T.101: ??? 如何传递参数给可变模板 ???
* T.102: ??? 如何处理传给可变模板的参数 ???
* T.103: 不要对相同类型的参数列表使用可变模板
* T.??: ???

元编程准则概要：

* T.120: 只在你真正需要的时候使用模板元编程
* T.121: 主要使用模板元编程来模拟概念
* T.122: 使用模板（通常是模板别名）在编译时计算类型
* T.123: 使用`constexpr`函数在编译时计算值
* T.124: 优先使用标准库的TMP设施
* T.125: 如果你需要超越标准库的TMP设施，使用现成的库
* T.??: ???

其它模板准则概要：

* T.140: 为所有可能重用的操作命名
* T.141: 如果你只在一个地方需要简单的函数对象，使用未命名的lambda
* T.142: 使用模板变量来简化符号
* T.143: 不要无意中写出不通用的代码
* T.144: 不要特化函数模板
* T.150: 使用`static_assert`来检查一个类是否符合概念
* T.??: ???

## T.gp: 泛型编程

泛型编程是使用类型和算法的编程，这些类型和算法按照类型、值和算法进行参数化。

### T.1: 使用模板来提升代码的抽象层级

##### 理由

通用性。重用。效率。鼓励用户类型的一致性定义。

##### 示例，不好的

从概念上来说，以下的要求是错误的，因为我们想要的`T`不仅仅是很低层级的“可以递增”或“可以增加”概念：

```cpp
template<typename T>
    // requires Incrementable<T>
T sum1(vector<T>& v, T s)
{
    for (auto x : v) s += x;
    return s;
}

template<typename T>
    // requires Simple_number<T>
T sum2(vector<T>& v, T s)
{
    for (auto x : v) s = s + x;
    return s;
}
```

假如`Incrementable`不支持`+`，且`Simple_number`不支持`+=`，我们就会过度约束了`sum1`和`sum2`的实现。而且，在这种情况下，失去了泛化的机会。

##### 示例

```cpp
template<typename T>
    // requires Arithmetic<T>
T sum(vector<T>& v, T s)
{
    for (auto x : v) s += x;
    return s;
}
```

假如`Arithmetic`同时要求`+`和`+=`，我们就会约束`sum`的用户提供完整的算术类型。这不是最小的要求，但它给算法的实现者提供了更多必要的自由，以及确保任何`Arithmetic`类型都可以用于各种各样的算法。

对于进一步的通用性和复用性，我们也可以使用更通用的`Container`或`Range`概念，而不是只能使用一种容器`vector`。

##### 注意

如果我们定义了一个模板，要求提供单个算法的单个实现所需的确切操作（例如，只要求`+=`而不是也要求`=`和`+`），只有这样，我们才会过度约束了维护者。我们的目标是最大限度地减少对模板参数的要求，但绝对最低要求的实现很少情况下是一个有意义的概念。

##### 注意

模板基本上可以用来表达任何东西（它们是图灵完整的），但是泛型编程的目标（正如使用模板来表达的）是有效地在一组具有相似语义属性的类型上泛化操作/算法。

##### 注意

在注释中的`requires`是概念的用法。“概念”定义在ISO技术规范中：“concepts”。概念在GCC 6.1及之后的版本中支持。所以，我们在示例中用注释来使用概念；即我们只以形式化的注释来使用它们。如果你使用GCC 6.1或之后的版本，你可以去掉对它们的注释。

##### 实施

* 标记出带有“过于简单”要求的算法，例如在没有概念的情况下直接使用特定的操作。
* 不要标记“过于简单”的概念定义；它们可能只是用来创建更有用的概念的砖块。

### T.2: 使用模板来表达适用于很多参数类型的算法

##### 理由

通用性。最大限度减少源代码的数量。互操作性。复用。

##### 示例

这是STL的基础。单个`find`算法可以容易地用于任何种类的输入范围：

```cpp
template<typename Iter, typename Val>
    // requires Input_iterator<Iter>
    //       && Equality_comparable<Value_type<Iter>, Val>
Iter find(Iter b, Iter e, Val v)
{
    // ...
}
```

##### 注意

不要使用模板，除非你对多于一个模板参数类型有实际的需要。不要过度抽象。

##### 实施

??? 困难的，可能需要人来介入。

### T.3: 使用模板来表达容器和范围

##### 理由

容器需要元素类型，把它表示成模板参数是普遍的，可复用的，而且是类型安全的。它也避免了脆弱的或低效的变通方法。公约：这是STL的做法。

##### 示例

```cpp
template<typename T>
    // requires Regular<T>
class Vector {
    // ...
    T* elem;   // 指向以零结尾的T数组
    int sz;
};

Vector<double> v(10);
v[7] = 9.9;
```

##### 示例，不好的

```cpp
class Container {
    // ...
    void* elem;   // 指向某种类型的特定大小的元素
    int sz;
};

Container c(10, sizeof(double));
((double*) c.elem)[] = 9.9;
```

这没有直接表达程序员的意图，而且对类型系统和优化器隐藏了程序的结构。

把`void*`隐藏在宏中只是掩盖了问题，而且会引入新的困惑的机会。

**例外**：如果你需要ABI稳定的接口，你可能必须提供基础的实现，并且在这方面表达（类型安全的）模板。参阅“稳定的基础”

##### 实施

* 标记出`void*`的使用以及在低层级实现代码外的转型。

### T.4: 使用模板来表达语法树操作

##### 理由

???

##### 示例

```cpp
???
```

**例外**：???

### T.5: 结合泛型和OO技术来放大它们的优势，而不是它们的代价

##### 理由

泛型和OO技术是互补的。

##### 示例

静态帮助动态：使用静态多态性来实现动态多态的接口。

```cpp
class Command {
    // 纯虚函数
};

// 实现
template</*...*/>
class ConcreteCommand : public Command {
    // 实现虚函数
};
```

##### 示例

动态帮助静态：提供一个泛型的、舒适的、静态绑定的接口，但内在地进行动态派发，因此你提供了一个统一的对象布局。这方面的的例子包括类型擦除，例如`std::shared_ptr`的删除器（但“不要过度使用类型擦除”）。

##### 注意

在类模板中，非虚拟函数只会在它们被使用的时候实例化——但虚拟函数每次都会实例化。这会导致代码大小膨胀，可能会因为实例化了从来不需要的功能而过度限制了泛型类型。要避免这种情况，即使标准库的facet有这个错误。

##### 另见

* 引用 ???
* 引用 ???
* 引用 ???

##### 

参考引用来获取更具体的规则。

## T.concepts: 概念准则

概念是为模板参数指定要求的设施。这是一个“ISO技术规范”，但目前只有GCC支持。然而，概念对于泛型编程的思考以及未来C++库大量工作的基础至关重要（标准和其它）。

这部分假设概念已被支持。

概念使用准则概要：

* T.10: 为所有模板参数指定概念
* T.11: 尽可能使用标准概念
* T.12: 优先使用概念名称而不是`auto`
* T.13: 优先为简单、单类型参数的概念使用简化符号
* ???

概念定义准则概要：

* T.20: 避免无有意义语义的“概念”
* T.21: 为概念提供一组完整的操作
* T.22: 为概念指定公理
* T.23: 通过添加新的使用模式，将提炼后的概念与更一般的情况区分开来
* T.24: 使用标签类或者特性来区分只是语义上不同的概念
* T.25: 避免互补的约束
* T.26: 优先在使用模式方面定义概念，而不是简单的语法
* ???

## T.con-use: 概念使用

### T.10: 为所有模板参数指定概念

##### 理由

正确性和可读性。模板参数的假定含义（语法和语义）是模板接口的基础。概念显著地提升了模板的文档化以及错误处理。为模板参数指定概念是强大的设计工具。

##### 示例

```cpp
template<typename Iter, typename Val>
//    requires Input_iterator<Iter>
//             && Equality_comparable<Value_type<Iter>, Val>
Iter find(Iter b, Iter e, Val v)
{
    // ...
}
```

或者同等的且更简洁的：

```cpp
template<Input_iterator Iter, typename Val>
//    requires Equality_comparable<Value_type<Iter>, Val>
Iter find(Iter b, Iter e, Val v)
{
    // ...
}
```

##### 注意

“概念”定义于ISO技术规范：[concepts](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4553.pdf)。一组标准库概念的草案可以在其它ISO TS中找到：[ranges](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf)。概念在GCC 6.1及之后的版本中支持。所以，我们在示例中用注释来使用概念；即我们只以形式化的注释来使用它们。如果你使用GCC 6.1及以后的版本，你可以去掉对它们的注释：

```cpp
template<typename Iter, typename Val>
    requires Input_iterator<Iter>
            && Equality_comparable<Value_type<Iter>, Val>
Iter find(Iter b, Iter e, Val v)
{
    // ...
}
```

##### 注意

纯`typename`（或者`auto`）是最不具约束的概念。只有在没有比“它是一个类型”更多假设的罕见情况下才应该使用。这通常只在 (作为模板元编程代码的一部分) 我们操作纯表达式树，推迟类型检查时才需要。

**参考资料**：TC++PL4, Palo Alto TR, Sutton

##### 实施

标记出不带概念的模板类型参数。

### T.11: 尽可能使用标准概念

##### 理由

“标准”概念（像GSL和[Ranges TS](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf)提供的，以及ISO标准自身有望可以很快提供的），节省了我们发明我们自己的概念的工作，比起我们在匆忙中思考的更加深思熟虑，并且提高了互操作性。

##### 注意

除非你正在创建一个新的泛型库，大部分你需要的概念已经由标准库定义好了。

##### 示例（使用TS概念）

```cpp
template<typename T>
    // 不要定义这个：Sortable在GSL中
concept Ordered_container = Sequence<T> && Random_access<Iterator<T>> && Ordered<Value_type<T>>;

void sort(Ordered_container& s);
```

`Ordered_container`似乎完全合理，但它与GSL（以及Range TS）中的`Sortable`概念非常相似。它是更好的吗？它是正确的吗？它准确地反映了标准对`sort`的要求吗？更好且更简单的是使用`Sortable`：

```cpp
void sort(Sortable& s);   // 好多了
```

##### 注意

随着包含概念的ISO标准临近，“标准”概念的集合在不断发展。

##### 注意

设计有用的概念是一个挑战。

#### 实施

困难的。

* 查找未被约束的参数，使用了“非寻常”/非标准概念的模板，使用了没有规律的“自制”概念的模板。
* 开发一个发现概念的工具（例如，参考[一个早期的实验](http://www.stroustrup.com/sle2010_webversion.pdf)）。

### T.12: 优先为局部变量使用概念名称而不是`auto`

##### 理由

`auto`是最弱的概念。概念名称比`auto`涵盖了更多的含义。

##### 示例（使用TS概念）

```cpp
vector<string> v;
auto& x = v.front();     // 不好的
String& s = v.begin();   // 好的（String是一个GSL概念）
```

##### 实施

* ???

### T.13: 优先为简单的、单类型参数的概念使用简化符号

##### 理由

可读性。直接表达想法。

##### 示例（使用TS概念）

表示“`T`是`Sortable`”：

```cpp
template<typename T>         // 正确的，但啰嗦：“参数的类型为T，T是可排序类型的名称”
//    requires Sortable<T>   
void sort(T&);               

template<Sortable T>         // 好多了（假设支持概念）：“参数的类型为T，T是可排序的”
void sort(T&);               

void sort(Sortable&);        // 最好的（假设支持概念）：“参数是可排序的”
```

越短的版本能更好地符合我们说话的方式。注意很多模板不需要使用`template`关键词。

##### 注意

“概念”定义于ISO技术规范：[concepts](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4553.pdf)。一组标准库概念的草案可以在其它ISO TS中找到：[ranges](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf)。概念在GCC 6.1及之后的版本中支持。所以，我们在示例中用注释来使用概念；即我们只以形式化的注释来使用它们。如果你使用了支持概念的编译器（例如GCC 6.1或之后的版本），你可以去掉`//`。

##### 实施

* 在人们从`<typename T>`和`<class T>`表示法转换期间，短期内是不可行的。
* 在这之后，标记出第一个引入`typename`的声明，然后用简单的、单类型参数的概念约束它。

## T.concepts.def: 概念定义准则

定义好的准则是重要的。概念用来表示应用程序领域中基础的概念（由此得名“概念”）。同样，把一组语法约束凑到一起，用在单个类或算法的参数上，这不是概念设计的目的，也不会得到该机制带来的全部好处。

显然，对于可以使用实现（例如GCC 6.1或之后的版本）的代码来说，定义概念会最有用，但定义概念本身就是一个有用的设计技术，有助于捕获概念错误和理清实现的概念。

### T.20: 避免无有意义语义的“概念”

##### 理由

概念用来表达语义概念，例如“一个数字”，元素的“一个范围”，以及“完全有序”。简单的约束，例如“有一个`+`操作符”和“有一个`>`操作符”不能在孤立的情况下有意义地指定，而只应该作为有意义的概念的建筑砖块来使用，而不是用在用户代码中。

##### 示例，不好的（使用TS概念）

```cpp
template<typename T>
concept Addable = has_plus<T>;    // 不好的：不充分

template<Addable N> auto algo(const N& a, const N& b) // 使用两个数字
{
    // ...
    return a + b;
}

int x = 7;
int y = 9;
auto z = algo(x, y);   // z = 16

string xx = "7";
string yy = "9";
auto zz = algo(xx, yy);   // zz = "79"
```

也许字符串的连接是预期的。不过更可能的是，这是一个意外。同样的，定义减法会有有明显不同的可接受类型集合。这个`Addable`违反了加法是可交换的数学规则：`a+b == b+a`。

##### 注意

指定有意义语义的能力是真正概念的定义特征，而不是语法约束。

##### 示例（使用TS概念）

```cpp
template<typename T>
// Number的+、-、*和/操作符认为是遵循通常的数学规则
concept Number = has_plus<T>
                    && has_minus<T>
                    && has_multiply<T>
                    && has_divide<T>;

template<Number N> auto algo(const N& a, const N& b)
{
    // ...
    return a + b;
}

int x = 7;
int y = 9;
auto z = algo(x, y);   // z = 16

string xx = "7";
string yy = "9";
auto zz = algo(xx, yy);   // 错误：字符串不是数字
```

##### 注意

比起只有单个操作的概念，具有多个操作的概念有更低的机会意外地匹配错类型。

##### 实施

* 标记出用在定义其它`concepts`之外的单个操作的`concepts`。
* 标记出用来模拟单操作`concepts`的`enable_if`。

### T.21: 为概念提供一组完整的操作

##### 理由

容易理解。提高互操作性。有助于实现者和维护者。

##### 注意

这是“概念必须有语义意义”这个一般准则的特定变体。

##### 示例，不好的（使用TS概念）

```cpp
template<typename T> concept Subtractable = requires(T a, T, b) { a-b; };
```

这没有语义意义。你至少需要`+`来让`-`有意义和有用。

完整集合的示例是：

* `Arithmetic`：`+`，`-`，`*`，`/`，`+=`，`-=`，`*=`，`/=`
* `Comparable`：`<`，`>`，`<=`，`>=`，`==`，`!=`

##### 注意

无论我们是否使用概念的直接语言支持，这个准则都适用。这是一个通用的设计准则，甚至适用于非模板：

```cpp
class Minimal {
    // ...
};

bool operator==(const Minimal&, const Minimal&);
bool operator<(const Minimal&, const Minimal&);

Minimal operator+(const Minimal&, const Minimal&);
// 没有其它操作符

void f(const Minimal& x, const Minimal& y)
{
    if (!(x == y)) { /* ... */ }    // 没问题
    if (x != y) { /* ... */ }       // 惊讶！出错

    while (!(x < y)) { /* ... */ }  // 没问题
    while (x >= y) { /* ... */ }    // 惊讶！出错

    x = x + y;          // 没问题
    x += y;             // 惊讶！出错
}
```

这是极小值，但对用户来说是意料之外且有约束的。它甚至可能很低效。

该准则支持了这个观点：概念应该反映一组（数学上）符合逻辑的操作。

##### 示例

```cpp
class Convenient {
    // ...
};

bool operator==(const Convenient&, const Convenient&);
bool operator<(const Convenient&, const Convenient&);
// ... 其它比较操作 ...

Minimal operator+(const Convenient&, const Convenient&);
// ... 其它算术操作 ...

void f(const Convenient& x, const Convenient& y)
{
    if (!(x == y)) { /* ... */ }    // 没问题
    if (x != y) { /* ... */ }       // 没问题

    while (!(x < y)) { /* ... */ }  // 没问题
    while (x >= y) { /* ... */ }    // 没问题

    x = x + y;     // 没问题
    x += y;        // 没问题
}
```

定义所有操作符可能令人讨厌，但是并不困难。理想情况下，该准则应该由语言来支持，通过提供默认的比较操作符。

##### 实施

* 标记出支持操作符集合的“怪异”子集的类型，例如，支持`==`但不支持`!=`，或者支持`+`但不支持`-`。是的，`std::string`是“怪异的”，但是要改变它已经太迟了。

### T.22: 为概念指定公理

##### 理由

一个有意义/有用的概念具有语义含义。以非正式、半正式或正式的方式来表达这些语义，使概念对读者是可理解的，而且为了表达它所做的努力可以捕捉概念错误。指定语义是强大的设计工具。

##### 示例（使用TS概念）

```cpp
template<typename T>
    // Number的+、-、*和/操作符认为是遵循通常的数学规则
    // axiom(T a, T b) { a + b == b + a; a - a == 0; a * (b + c) == a * b + a * c; /*...*/ }
    concept Number = requires(T a, T b) {
        {a + b} -> T;   // a + b的结果可转换成T
        {a - b} -> T;
        {a * b} -> T;
        {a / b} -> T;
    }
```

##### 注意

这是一个在数学意义下的公理：在没有证明的情况下可以假定的东西。通常，公理是不可证明的，当它们是证明时，往往超出了编译器的能力。公理可能不是通用的，但模板的作者可以假定它适用于所有实际使用的输入（类似于前置条件）。

##### 注意

在这个上下文中，公理是一个布尔表达式。参阅“Palo Alto TR”的示例。目前，C++不支持公理（甚至是ISO的概念TS），所以我们不得不在相当长的时间内使用注释来达到这个目的。一旦语言支持可用，在公理前面的`//`就可以被移除。

##### 注意

GSL概念有定义良好的语义；参阅“Palo Alto TR”和“Ranges TS”。

##### 例外（使用TS概念）

仍在开发中的新“概念”的早期版本一般只定义了简单的约束集合，而没有良好指定的语义。找到好的语义需要付出努力和时间。一个不完整的约束集合仍然是很有用的：

```cpp
// 一般二叉树的平衡器
template<typename Node> concept bool Balancer = requires(Node* p) {
    add_fixup(p);
    touch(p);
    detach(p);
}
```

所以`Balancer`必须在一个树的`Node`上提供至少三个操作，但我们还没有准备好指定细致的语义，因为新类型的平衡树可能需要更多操作，而且对所有节点都准确通用的语义在设计的早期阶段难以确定。

一个不完整或者没有良好指定语义的“概念”仍然是有用的。例如，它允许在早期的实验中进行一些检查。但是，它不应该认为是稳定。每一个新的用例可能都需要改善这些不完整的概念。

##### 实施

* 在概念定义的注释中查找单词“axiom”。

### T.23: 通过添加新的使用模式，将提炼后的概念与更一般的情况区分开来

##### 理由

否则它们不能被编译器自动地区分开来。

##### 示例（使用TS概念）

```cpp
template<typename I>
concept bool Input_iter = requires(I iter) { ++iter; };

template<typename I>
concept bool Fwd_iter = Input_iter<I> && requires(I iter) { iter++; }
```

编译器可以基于要求的操作（在这里是后缀`++`）来确定提炼。这减少了这些类型的实现负担，因为它们不需要任何特别的声明来“挂钩进概念里”。如果两个概念有完全一样的要求，它们在逻辑上是等同的（不存在提炼）。

##### 示例

* 标记出与其它已经见过的概念具有完全相同要求的概念（两个都不是提炼）。为了消除它们之间的歧义，参阅T.24。

### T.24: 使用标签类或者特性来区分只是语义上不同的概念

##### 理由

要求相同语法但不同语义的两个概念会导致歧义，除非程序员区分了它们。

##### 示例（使用TS概念）

```cpp
template<typename I>    // 提供随机访问的迭代器
concept bool RA_iter = ...;

template<typename I>    // 提供对连续数据随机访问的迭代器
concept bool Contiguous_iter =
    RA_iter<I> && is_contiguous<I>::value;  // 使用is_contiguous特性
```

（在库中的）程序员必须恰当地定义`is_contiguous`（一个特性）。

把标签类包装进概念中可以更简单地表达这个想法：

```cpp
template<typename I> concept Contiguous = is_contiguous<I>::value;

template<typename I>
concept bool Contiguous_iter = RA_iter<I> && Contiguous<I>;
```

（在库中的）程序员必须恰当地定义`is_contiguous`（一个特性）。

##### 注意

特性可以是特性类或者类型特性。这些可以是用户定义的或者是标准库中的。优先使用标准库中的。

##### 实施

* 编译器会标记出使用了相同概念的歧义。
* 标记出相同概念的定义。

### T.25: 避免互补的约束

##### 理由

清晰性。可维护性。用否定来表示的具有互补要求的函数是脆弱的。

##### 示例（使用TS概念）

最初，人们会试图定义具有互补要求的函数：

```cpp
template<typename T>
    requires !C<T>    // 不好的
void f();

template<typename T>
    requires C<T>
void f();
```

这样的话好多了：

```cpp
template<typename T>   // 通用模板
    void f();

template<typename T>   // 通过概念进行特化
    requires C<T>
void f();
```

只有当`C<T>`不满足的时候，编译器才会选择无约束的模板。如果你不想要（或者不能）定义`f()`的无约束版本，那么删除它。

```cpp
template<typename T>
void f() = delete;
```

编译器会选择这个重载，并发出适当的错误。

##### 注意

互补约束不幸地在`enable_if`代码中很常见：

```cpp
template<typename T>
enable_if<!C<T>, void>   // 不好的
f();

template<typename T>
enable_if<C<T>, void>
f();
```

##### 注意

在一个要求上的互补要求有时候（错误地）认为是可管理的。然而，对于两个或者更多要求，需要定义的数量会成指数地增长（2，4，9，16）：

```cpp
C1<T> && C2<T>
!C1<T> && C2<T>
C1<T> && !C2<T>
!C1<T> && !C2<T>
```

现在出错的几率也成倍地增加了。

##### 实施

* 标记出带有`C<T>`和`!C<T>`约束的函数。

### T.26: 优先在使用模式方面定义概念，而不是在简单语法方面

##### 理由

这样的定义更可读，而且直接对应了用户必须写的事物。转换被纳入考虑。你不需要记住所有类型特性的名称。

##### 示例（使用TS概念）

你可能会试图定义一个像这样的`Equality`概念：

```cpp
template<typename T> concept Equality = has_equal<T> && has_not_equal<T>;
```

显然，使用标准的`EqualityComparable`会更好更简单，但是——只是作为例子——要是你不得不定义这样的概念，应该这样：

```cpp
template<typename T> concept Equality = requires(T a, T b) {
    bool == { a == b }
    bool == { a != b }
    // axiom { !(a == b) == (a != b) }
    // axiom { a = b; => a == b }  // =>的意思是“隐含”
}
```

而不是定义两个无意义的概念`has_equal`和`has_not_equal`，仅仅作为`Equality`定义中的两个辅助概念。所谓“无意义”，我们的意思是我们不能单独地指定`has_equal`的语义。

##### 实施

???

## 模板接口

多年以来，使用模板编程一直存在模板接口与其实现区分度不够的问题。在概念之前，这种区分没有直接的语言支持。但是，模板的接口是一个重要的概念——在用户和实现者之间的契约——应该要小心地设计。

### T.40: 使用函数对象来传递算法操作

##### 理由

函数对象比“纯”函数指针可以携带更多信息进到接口中。通常，传递函数对象比传递函数指针有更好的性能。

##### 示例（使用TS概念）

```cpp
bool greater(double x, double y) { return x > y; }
sort(v, greater);                                    // 函数指针：可能会慢
sort(v, [](double x, double y) { return x > y; });   // 函数对象
sort(v, std::greater<>);                             // 函数对象

bool greater_than_7(double x) { return x > 7; }
auto x = find_if(v, greater_than_7);                 // 函数指针：不灵活
auto y = find_if(v, [](double x) { return x > 7; }); // 函数对象：携带了所需的数据
auto z = find_if(v, Greater_than<double>(7));        // 函数对象：携带了所需的数据
```

当然，你可以使用`auto`或者（当它可用的时候）概念来泛化这些函数。例如：

```cpp
auto y1 = find_if(v, [](Ordered x) { return x > 7; }); // 需要有序的类型
auto z1 = find_if(v, [](auto x) { return x > 7; });    // 期望该类型有>
```

##### 注意

lambda生成函数对象。

##### 注意

对性能的争论基于编译器和优化器技术。

##### 实施

* 标记出函数指针模板参数。
* 标记出作为参数传递给模板的函数指针（有误报的风险）。

### T.41: 在模板的概念中只要求基本的属性

##### 理由

保持接口简单和稳定。

##### 示例（使用TS概念）

考虑这个例子，一个用（过于简化的）简单调试支持调校过的`sort`：

```cpp
void sort(Sortable& s)  // 对序列s排序
{
    if (debug) cerr << "enter sort( " << s <<  ")\n";
    // ...
    if (debug) cerr << "exit sort( " << s <<  ")\n";
}
```

如果将它写成：

```cpp
template<Sortable S>
    requires Streamable<S>
void sort(S& s)  // 对序列s排序
{
    if (debug) cerr << "enter sort( " << s <<  ")\n";
    // ...
    if (debug) cerr << "exit sort( " << s <<  ")\n";
}
```

毕竟，在`Sortable`中并不要求支持`iostream`。另一方面，基本的排序思想中没有任何关于调试的内容。

##### 注意

如果我们要求每个用到的操作都在要求中列出来，那么接口会变得不稳定：每次我们修改了调试设施，例如使用数据的收集，测试支持，错误报告等等，模板的定义也需要修改，每个使用了模板的地方都要重新编译。这是累赘的，而且在某些环境下不可行。

相反，如果我们在实现中使用了一个没有经过概念检查保证的操作，我们会遇到迟来的编译时错误。

对于不是必需的模板参数属性，通过不使用概念检查，我们把检查延迟到实例化的时候。我们认为这是值得的交易。

注意，使用非局部，无依赖的名称（例如`debug`和`cerr`）也引入了上下文依赖，这会导致“神秘的”错误。

##### 注意

类型的属性哪些是必需的，哪些不是，这是难以决定的。

##### 实施

???

### T.42: 使用模板别名来简化符号以及隐藏实现细节

##### 理由

提高可读性。隐藏实现。注意模板别名代替了很多特性的使用来计算类型。它们也可以用来包装特性。

##### 示例

```cpp
template<typename T, size_t N>
class Matrix {
    // ...
    using Iterator = typename std::vector<T>::iterator;
    // ...
};
```

这样做让`Matrix`的用户不必知道它的元素是保存在`vector`中的，同时也让用户不必重复地输入`typename std::vector<T>::`。

##### 示例

```cpp
template<typename T>
void user(T& c)
{
    // ...
    typename container_traits<T>::value_type x; // 不好的，啰嗦
    // ...
}

template<typename T>
using Value_type = typename container_traits<T>::value_type;
```

这样做让`Value_type`的用户的不必知道用来实现`value_type`的技术。

```cpp
template<typename T>
void user2(T& c)
{
    // ...
    Value_type<T> x;
    // ...
}
```

##### 注意

一个简单、常见的用法可以表达成：“包装特性！”

##### 实施

* 标记出用于`using`声明之外，用作消除歧义目的的`typename`。
* ???

### T.43: 优先使用`using`而不是`typedef`来定义别名

##### 理由

提高可读性：使用`using`，新名称会在第一个位置出现，而不是嵌进声明中的某个地方。通用性：`using`可以用于模板别名，而`typedef`不能简单地模板化。一致性：`using`在语法上与`auto`相似。

##### 示例

```cpp
typedef int (*PFI)(int);   // 没问题，但是费解

using PFI2 = int (*)(int);   // 没问题，更好的

template<typename T>
typedef int (*PFT)(T);      // 错误

template<typename T>
using PFT2 = int (*)(T);   // 没问题
```

##### 实施

* 标记出`typedef`的使用。这会给出很多“提示” :-(

### T.44: 使用函数模板来推导类模板的参数类型（可行的情况下）

##### 理由

显式地写出模板参数类型是令人厌烦的，且不必要地啰嗦。

##### 示例

```cpp
tuple<int, string, double> t1 = {1, "Hamlet", 3.14};   // 显式类型
auto t2 = make_tuple(1, "Ophelia"s, 3.14);         // 好多了；推导出类型
```

注意，使用`s`后缀确保这个字符串是`std::string`，而不是C风格字符串。

##### 注意

既然你可以容易地写出`make_T`函数，那么编译器也可以。因此，`make_T`函数在将来可能会变成多余的。

##### 例外

有时候，没有好的方式可以推导出模板参数，而且有时候你想要显式地指定参数：

```cpp
vector<double> v = { 1, 2, 3, 7.9, 15.99 };
list<Record*> lst;
```

##### 注意

注意，通过允许模板参数在构造函数的参数中直接推导出来，C++17会让这个准则变得多余：[构造函数的模板参数推导（修订版本3）](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0091r1.html)。例如：

```cpp
tuple t1 = {1, "Hamlet"s, 3.14}; // 推导出：tuple<int, string, double>
```

##### 实施

当显式指定的类型准确地匹配参数的类型时，标记出来。

### T.46: 要求模板参数至少为`Regular`或`SemiRegular`

##### 理由

可读性。避免意外和错误。大多数用法都支持。

##### 示例

```cpp
class X {
        // ...
public:
    explicit X(int);
    X(const X&);            // 拷贝
    X operator=(const X&);
    X(X&&) noexcept;                 // 移动
    X& operator=(X&&) noexcept;
    ~X();
    // ... 没有更多构造函数 ...
};

X x {1};    // 没问题
X y = x;      // 没问题
std::vector<X> v(10); // 错误：没有默认构造函数
```

##### 注意

半常规要求可以默认构造。

##### 实施

* 标记出最低要求都不符合`SemiRegular`的类型。

### T.47: 避免具有通用名称的高度可见未受约束的模板

##### 理由

未受约束的模板参数可以完美地匹配任何东西，因此对于需要一些转换的更具体的类型，这样的模板更优先。当使用了ADL时，这是特别令人烦恼/危险的。通用的名称使这个问题更加可能出现。

##### 示例

```cpp
namespace Bad {
    struct S { int m; };
    template<typename T1, typename T2>
    bool operator==(T1, T2) { cout << "Bad\n"; return true; }
}

namespace T0 {
    bool operator==(int, Bad::S) { cout << "T0\n"; return true; }  // 与int比较

    void test()
    {
        Bad::S bad{ 1 };
        vector<int> v(10);
        bool b = 1 == bad;
        bool b2 = v.size() == bad;
    }
}
```

这会输出`T0`和`Bad`。

现在，在`Bad`中的`==`是用来制造麻烦的，但是你会在真实的代码中定位到这种问题吗？这里的问题是`v.size()`返回一个`unsigned`整数，因而调用局部的`==`需要转换；在`Bad`中的`==`不许要转换。现实的类型，例如标准库的迭代器，可以表现出类似的反社会倾向。

##### 注意

如果未受约束的模板与类型定义在同一个名称空间，这个未受约束的模板可以被ADL找到（就像示例中发生的那样）。也就是说，它是高度可见的。

##### 注意

这个准则不应该是必须的，但是委员会不同意从ADL中排除未受约束的模板。

不幸的是这会产生很多误报；标准库大量地违反这个准则，把很多未受约束的模板和类型放在了单一的名称空间`std`中。

##### 实施

标记出定义在名称空间中的模板，在这个名称空间中也定义了具体的类型（可能不可行，直到我们有了概念）。

### T.48: 如果你的编译器不支持概念，用`enable_if`来伪造

##### 理由

因为这是在没有直接的概念支持下，我们所能做的最好的事情。`enable_if`可以用来有条件性地定义函数，以及在一组函数中选择。

##### 示例

```cpp
enable_if<???>
```

##### 注意

要注意“互补约束”（T.25）。使用`enable_if`伪造的概念重载有时候会强迫我们使用容易出错的设计技术。

##### 实施

???

### T.49: 尽可能避免类型擦除

##### 理由

通过把类型信息隐藏在单独的编译边界中，类型擦除会导致额外的间接层。

##### 示例

```cpp
???
```

**例外**：类型擦除有时候是合适的，例如用于`std::function`。

##### 实施

???

##### 注意

## T.def: 模板定义

模板定义（类或函数）可以包括任意代码，因此只有对完整的C++编程技术进行回顾才能覆盖这个主题。但是，这部分聚焦于模板实现的具体内容。尤其是，聚焦于模板定义在其上下文中的依赖。

### T.60: 尽量减少模板的上下文依赖

##### 理由

容易理解。尽量减少非预期依赖导致的错误。容易使用工具来生成。

##### 示例

```cpp
template<typename C>
void sort(C& c)
{
    std::sort(begin(c), end(c)); // 必要且有用的依赖
}

template<typename Iter>
Iter algo(Iter first, Iter last) {
    for (; first != last; ++first) {
        auto x = sqrt(*first); // 可能会有意料之外的依赖：哪个sqrt()？
        helper(first, x);      // 可能会有意料之外的依赖：helper基于first和x来选择
        TT var = 7;            // 可能会有意料之外的依赖：哪个TT？
    }
}
```

##### 注意

模板一般出现在头文件中，因此它们的上下文依赖比起`.cpp`文件中的函数更容易受到`#include`顺序依赖的影响。

##### 注意

让模板只对其参数进行操作是将依赖数量减少到最低的一种方法，但这通常是不可管理的。例如，一个算法经常使用其它算法，并且调用不仅操作参数的操作。不要让我们从宏开始！

**另见**：T.69。

##### 实施

??? 棘手的

### T.61: 不要过度参数化成员（SCARY）

##### 理由

除了特定的模板参数，不依赖于模板参数的成员不能够使用。这限制了使用，并且通常会增加了代码大小。

##### 示例，不好的

```cpp
template<typename T, typename A = std::allocator{}>
    // requires Regular<T> && Allocator<A>
class List {
public:
    struct Link {   // 不依赖A
        T elem;
        T* pre;
        T* suc;
    };

    using iterator = Link*;

    iterator first() const { return head; }

    // ...
private:
    Link* head;
};

List<int> lst1;
List<int, My_allocator> lst2;

???
```

这看起来没什么问题，但是 ???

```cpp
template<typename T>
struct Link {
    T elem;
    T* pre;
    T* suc;
};

template<typename T, typename A = std::allocator{}>
    // requires Regular<T> && Allocator<A>
class List2 {
public:
    using iterator = Link<T>*;

    iterator first() const { return head; }

    // ...
private:
    Link* head;
};

List<int> lst1;
List<int, My_allocator> lst2;

???
```

##### 实施

* 标记出不依赖于每个模板参数的成员类型。
* 标记出不依赖于每个模板参数的成员函数。

### T.62: 把无依赖的类模板成员放在非模板的基类中

##### 理由

允许基类成员在不指定模板参数以及不进行模板实例化的情况下使用。

##### 示例

```cpp
template<typename T>
class Foo {
public:
    enum { v1, v2 };
    // ...
};
```

???

```cpp
struct Foo_base {
    enum { v1, v2 };
    // ...
};

template<typename T>
class Foo : public Foo_base {
public:
    // ...
};
```

##### 注意

这个准则更一般的版本是“如果模板类的成员只依赖M个模板参数中的N个，那么把它放在只有N个参数的基类中”。对于N == 1，我们可以选择在类作用域的附近定义一个基类，就像T.61中做的那样。

??? 常量怎么办？类的静态成员呢？

##### 实施

* 标记出???

### T.64: 使用特化来提供类模板的其它实现

##### 理由

模板定义了通用的接口。特化特供了强大的机制来提供接口的其它实现。

##### 示例

```cpp
??? string specialization (==)

??? representation specialization ?
```

##### 注意

???

##### 实施

???

### T.65: 使用标签派发来提供函数的其它实现

##### 理由

* 模板定义了通用的接口。
* 标签派发让我们可以基于参数类型的特定属性来选择实现。
* 性能。

##### 示例

这是`std::copy`的简化版本（忽略了非连续序列）

```cpp
struct pod_tag {};
struct non_pod_tag {};

template<class T> struct copy_trait { using tag = non_pod_tag; };   // T不是“普通的旧式数据”

template<> struct copy_trait<int> { using tag = pod_tag; };         // int是“普通的旧式数据”

template<class Iter>
Out copy_helper(Iter first, Iter last, Iter out, pod_tag)
{
    // 使用memmove
}

template<class Iter>
Out copy_helper(Iter first, Iter last, Iter out, non_pod_tag)
{
    // 使用循环来调用拷贝构造函数
}

template<class Itert>
Out copy(Iter first, Iter last, Iter out)
{
    return copy_helper(first, last, out, typename copy_trait<Iter>::tag{});
}

void use(vector<int>& vi, vector<int>& vi2, vector<string>& vs, vector<string>& vs2)
{
    copy(vi.begin(), vi.end(), vi2.begin()); // 使用memmove
    copy(vs.begin(), vs.end(), vs2.begin()); // 使用循环来调用拷贝构造函数
}
```

这是通用且强大的技术来进行编译时算法选择。

##### 注意

当`concept`变得广泛可用时，这些选择可以直接区分开来：

```cpp
template<class Iter>
    requires Pod<Value_type<iter>>
Out copy_helper(In, first, In last, Out out)
{
    // 使用memmove
}

template<class Iter>
Out copy_helper(In, first, In last, Out out)
{
    // 使用循环来调用拷贝构造函数
}
```

##### 实施

???

### T.67: 使用特化来为非常规类型提供其它实现

##### 理由

???

##### 示例

```cpp
???
```

##### 实施

???

### T.68: 在模板中使用`{}`而不是`()`来避免歧义

##### 理由

`()`容易受到语法歧义的影响。

##### 示例

```cpp
template<typename T, typename U>
void f(T t, U u)
{
    T v1(x);    // v1是函数还是变量？
    T v2 {x};   // 变量
    auto x = T(u);  // 构造还是转型？
}

f(1, "asdf"); // 不好的：从const char*转型到int
```

##### 实施

* 标记出`()`初始化
* 标记出函数风格的转型

### T.69: 在模板中，不要进行无限定的非成员函数调用，除非你的意图是让它成为一个定制化点

##### 理由

* 只提供需要的灵活性。
* 避免受到意外的环境因素改变的影响。

##### 示例

有三种主要的方式来让调用代码定制一个模板。

```cpp
template<class T>
    // 调用成员函数
void test1(T t)
{
    t.f();    // 需要T提供f()
}

template<class T>
void test2(T t)
    // 无限定地调用非成员函数
{
    f(t);  // 需要f(/*T*/)在调用者的作用域或者在T的名称空间中可用
}

template<class T>
void test3(T t)
    // 调用一个“特性”
{
    test_traits<T>::f(t); // 需要定制test_traits<>来得到非默认的函数/类型
}
```

特性通常是一个计算类型的类型别名，一个计算值的`constexpr`函数，或者一个基于用户类型特化的传统特性模板。

##### 注意

如果你想要用依赖于模板类型参数的值`t`来调用你自己的辅助函数`helper(t)`，把它放在`::detail`名称空间中，并且限定其调用，如`detail::helper(t);`。无限定的调用会成为一个定制点，在`t`类型所在的名称空间中，任何`helper`函数都都可以被调用；这会导致一些问题，比如“无意中调用了无约束的函数模板”。

##### 实施

* 在模板中，标记出对非成员函数的无限定调用，该函数传递了模板所依赖的类型变量，同时在模板的名称空间中存在同名的非成员函数。

## T.temp-hier: 模板和层次结构准则

模板是C++支持泛型编程的支柱，而类层次结构是支持面向对象编程的支柱。这两种语言机制可以有效地结合使用，但是一些设计陷阱必须要避免。

### T.80: 不要天真地模板化类层次结构

##### 理由

模板化有很多函数，特别是很多虚拟函数的类层次结构，会导致代码膨胀。

##### 示例，不好的

```cpp
template<typename T>
struct Container {         // 一个接口
    virtual T* get(int i);
    virtual T* first();
    virtual T* next();
    virtual void sort();
};

template<typename T>
class Vector : public Container<T> {
public:
    // ...
};

vector<int> vi;
vector<string> vs;
```

把`sort`定义成容器的成员函数可能是愚蠢的主意，但这并不是前所未闻的，并且这是一个关于不要做什么的好例子。

对于这个例子，编译器不知道`vector<int>::sort()`是否被调用，因此它必须为它生成代码。`vector<string>::sort()`也是类似。除非这两个函数被调用了，否则就是代码膨胀。想像一下，在一个类层次结构中，具有数十个成员函数以及数十个有许多实例的派生类，这种情况会发生什么事情。

##### 注意

在很多情况下，你不必通过模板化基类的方式来提供稳定的接口；参阅“稳定的基类”以及“00和GP”。

##### 实施

* 标记出依赖于模板参数的虚拟函数。??? 误报

### T.81: 不要混合层次结构和数组

##### 理由

派生类的数组可以隐式地“衰变”成基类的指针，这可能会导致灾难性的后果。

##### 示例

假设`Apple`和`Pear`是两种`Fruit`。

```cpp
void maul(Fruit* p)
{
    *p = Pear{};     // 把一个Pear放进 *p
    p[1] = Pear{};   // 把一个Pear放进p[1]
}

Apple aa [] = { an_apple, another_apple };   // aa包含了Apple（显然的！）

maul(aa);
Apple& a0 = &aa[0];   // 是一个Pear吗？
Apple& a1 = &aa[1];   // 是一个Pear吗？
```

`aa[0]`很可能是一个`Pear`（没有使用转型！）。如果`sizeof(Apple) != sizeof(Pear)`，对`aa[1]`的访问不会对齐数组中对象的正确开始地址。我们会遇到类型违规以及可能（几乎可以肯定）会出现内存损坏。永远不要写出这样的代码。

注意`maul()`违反了“`T*`应该指向一个单独对象”的准则。

**替代方案**：使用正确的（模板化的）容器：

```cpp
void maul2(Fruit* p)
{
    *p = Pear{};   // 把一个Pear放进 *p
}

vector<Apple> va = { an_apple, another_apple };   // va包含了Apple（显然的！）

maul2(va);       // 错误：不能把vector<Apple>转换成Fruit*
maul2(&va[0]);   // 你自找的

Apple& a0 = &va[0];   // 是一个Pear吗？
```

注意`maul2()`中的赋值违反了“不要发生对象切割”的准则。

##### 实施

* 检测出这种可怕的情况！

### T.82: 当不需要虚函数时，使层次结构线性化

##### 理由

???

##### 示例

```cpp
???
```

##### 实施

???

### T.83: 不要把成员函数模板声明为虚拟的

##### 理由

C++不支持这样做。如果真的这样做，在链接之前虚拟函数表都不能生成。通常，实现必须处理动态链接。

##### 示例，不要这样做

```cpp
class Shape {
    // ...
    template<class T>
    virtual bool intersect(T* p);   // 错误：模板不能是虚拟的
};
```

##### 注意

我们需要这个准则，因为人们一直在问这个问题。

##### 替代方案

双重派发，访问者，计算出调用哪个函数。

##### 实施

编译器处理了。

### T.84: 使用非模板的核心实现来提供一个ABI稳定的接口

##### 理由

提高代码的稳定性。避免代码膨胀。

##### 示例

这可以是一个基类：

```cpp
struct Link_base {   // 稳定的
    Link_base* suc;
    Link_base* pre;
};

template<typename T>   // 模板化的包装来增加类型安全性
struct Link : Link_base {
    T val;
};

struct List_base {
    Link_base* first;   // 第一个元素（如果有的话）
    int sz;             // 元素的数量
    void add_front(Link_base* p);
    // ...
};

template<typename T>
class List : List_base {
public:
    void put_front(const T& e) { add_front(new Link<T>{e}); }   // 隐式转型成Link_base
    T& front() { static_cast<Link<T>*>(first).val; }   // 显式转型回Link<T>
    // ...
};

List<int> li;
List<string> ls;
```

现在只有一份对`List`元素链接和断链操作的副本。`Link`和`List`类不做任何事情，只是类型操作。

除了使用分离的“基础”类型，另一个常见的技术是对`void`或者`void*`进行特化，让`T`的通用模板只是与核心的`void`实现之间进行经过安全封装的转型。

**替代方案**：使用pimpl实现。

##### 实施

???

## T.var: 可变模板准则

???

### T.100: 当你需要一个函数，该函数可以接收各种类型、数量可变的参数时，使用可变模板

##### 理由

可变模板是用于这个目的的最通用的机制，而且是高效且类型安全的。不要使用C的可变参数。

##### 示例

```cpp
??? printf
```

##### 实施

* 标记出在用户代码中使用的`va_arg`。

### T.101: ??? 如何传递参数给可变模板 ???

##### 理由

???

##### 示例

```cpp
??? 小心仅移动和引用的参数
```

##### 实施

???

### T.102: 如何处理传给可变模板的参数

##### 理由

???

##### 示例

```cpp
??? 转发，类型检查，引用
```

##### 实施

???

### T.103: 不要对相同类型的参数列表使用可变模板

##### 理由

有更准确的方式来指定相同类型的序列，例如`initializer_list`。

##### 示例

```cpp
???
```

##### 实施

???

## T.meta: 模板元编程（TMP）

模板为编译时编程提供了通用的机制。

元编程是指至少有一个输入或结果是类型的编程。模板提供了在编译时图灵完备（模组内存容量）的鸭子类型。它所需的语法和技术相当可怕。

### T.120: 只在你真正需要的时候使用模板元编程

##### 理由

模板元编程难以写得正确，减慢编译速度，并且通常很难维护。但是，有一些真实的例子表明模板元编程比任何其它缺少专家级汇编代码的方法有更好的性能。同时，也有一些真实的例子表明模板元编程比运行时代码可以更好地表达基础想法。例如，如果你真的需要在编译时维护AST（比如用于可选的矩阵操作折叠），在C++中可能没有其它方法。

##### 示例，不好的

```cpp
???
```

##### 示例，不好的

```cpp
enable_if
```

相反，应使用概念。但是参阅“如果你没有语言的支持，如何模拟概念”。

##### 示例

```cpp
??? 好的
```

**替代方案**：如果计算的结果是一个值，而不是一个类型，使用“`constexpr`函数”。

##### 注意

如果你觉得需要在宏中隐藏你的模板元编程，你很可能走得太远了。

## 其它模板准则

### T.140: 为所有可能重用的操作命名

##### 理由

文档化，可读性，重用的可能性。

##### 示例

```cpp
struct Rec {
    string name;
    string addr;
    int id;         // 唯一标示符
};

bool same(const Rec& a, const Rec& b)
{
    return a.id == b.id;
}

vector<Rec*> find_id(const string& name);    // 查找所有匹配“name”的记录

auto x = find_if(vr.begin(), vr.end(),
    [&](Rec& r) {
        if (r.name.size() != n.size()) return false; // 用于比较的名称在n中
        for (int i = 0; i < r.name.size(); ++i)
            if (tolower(r.name[i]) != tolower(n[i])) return false;
        return true;
    }
);
```

这里隐藏着一个有用的函数（大小写不敏感的字符串比较），当lambda参数变得长时，一般就会出现这种情况。

```cpp
bool compare_insensitive(const string& a, const string& b)
{
    if (a.size() != b.size()) return false;
    for (int i = 0; i < a.size(); ++i) if (tolower(a[i]) != tolower(b[i])) return false;
    return true;
}

auto x = find_if(vr.begin(), vr.end(),
    [&](Rec& r) { compare_insensitive(r.name, n); }
);
```

或者，也许可以这样（如果你更偏向于避免对n的隐式名称绑定）：

```cpp
auto cmp_to_n = [&n](const string& a) { return compare_insensitive(a, n); };

auto x = find_if(vr.begin(), vr.end(),
    [](const Rec& r) { return cmp_to_n(r.name); }
);
```

##### 注意

不论函数，lambda还是操作符。

##### 例外

* lambda逻辑上只是局部使用，例如给`for_each`以及类似的控制流算法的参数。
* lambda作为初始化器。

##### 实施

* （困难的）标记出相似的lambda
* ???

### T.141: 如果你只在一个地方需要简单的函数对象，使用未命名的lambda

##### 理由

这使得代码简洁，并且比其它方法提供了更好的局部性。

##### 示例

```cpp
auto earlyUsersEnd = std::remove_if(users.begin(), users.end(),
                                        [](const User &a) { return a.id > 100; });
```

##### 例外

命名lambda对清晰性是有帮助的，即使它只使用一次。

##### 实施

* 查找相等和近似相等的lambda（用具名函数或者具名lambda来代替）。

### T.142: 使用模板变量来简化符号

##### 理由

提高可读性。

##### 示例

```cpp
???
```

##### 实施

???

### T.143: 不要无意中写出不通用的代码

##### 理由

通用性。可重用性。不要无故地依赖细节；使用可以使用的最通用的设施。

##### 示例

使用`!=`而不是`<`来比较迭代器；`!=`可以用于更多对象，因为它不依赖顺序。

```cpp
for (auto i = first; i < last; ++i) {   // 没那么通用
    // ...
}

for (auto i = first; i != last; ++i) {   // 好；更通用
    // ...
}
```

当然，基于范围的`for`依然是更好的，它做了你想要做的事情。

##### 示例

使用提供了你所需功能的最少派生的类型。

```cpp
class Base {
public:
    Bar f();
    Bar g();
};

class Derived1 : public Base {
public:
    Bar h();
};

class Derived2 : public Base {
public:
    Bar j();
};

// 不好，除非有特别的原因限制了只能用Derived1对象
void my_func(Derived1& param)
{
    use(param.f());
    use(param.g());
}

// 好，只使用Base接口，因此只依赖于它
void my_func(Base& param)
{
    use(param.f());
    use(param.g());
}
```

##### 实施

* 标记出使用`<`而不是`!=`来比较迭代器。
* 标记出当`x.empty()`或`x.is_empty()`可用时的`x.size() == 0`。判空比`size()`可用于更多容器，因为一些容器不知道它们的大小，或者在概念上有无限的大小。
* 标记出接受派生类型指针或引用的函数，在函数中只使用了在基类声明的函数。

### T.144: 不要特化函数模板

##### 理由

根据语言规则，你不能部分特化一个函数模板。你可以完全特化一个函数模板，但是你几乎肯定想要重载来代替——因为函数模板特化不参与重载，它们不会像你可能想要的那样运作。少数情况下，你实际上应该通过委托到类模板上进行特化，这样你才可以正确地特化。

##### 示例

```cpp
???
```

**例外**：如果你确实有有效的理由来特化一个函数模板，那么只要写一个函数模板，在其中委托给类模板，然后特化这个类模板（包括写部分特化的能力）。

##### 实施

* 标记出函数模板的所有特化。使用重载代替。

### T.150: 使用`static_assert`来检查一个类是否符合概念

##### 理由

如果你希望一个类符合一个概念，应尽早地验证它，减少用户的痛苦。

##### 示例

```cpp
class X {
public:
    X() = delete;
    X(const X&) = default;
    X(X&&) = default;
    X& operator=(const X&) = default;
    // ...
};
```

在某个地方，可能在一个实现文件中，让编译器检查`X`期望的属性：

```cpp
static_assert(Default_constructible<X>);    // 错误：X有非默认的构造函数
static_assert(Copyable<X>);                 // 错误：我们忘记定义X的移动构造函数
```

##### 实施

不可行。