# C++核心指南

2018年3月26日

主编：
* Bjarne Stroustrup
* Herb Sutter

本文档是一份初期草案。我们知道它是不完整的，不正确的，以及有许多不好的格式。假如这是一个开源（代码）项目的话，那么它已经发布了0.8版本。复制，使用，修改以及从这个项目衍生的创作行为都在MIT类型的许可证下获得许可。对这个项目做贡献需要同意贡献者许可证。参考随附的LISENCE文件获取详情。我们让“友好的用户”可以使用，复制，修改以及从本项目衍生，以期望获得有建设性的贡献。

出于改进目的的评论和建议总是受欢迎的。我们计划在我们增进理解，以及语言和可用的程序库集改善的时候，修改和扩展这份文档。当你评论的时候，请注意这个勾勒出我们的目标和整体方法的介绍。贡献者的名单在这里。

问题：
* 准则集还没有彻底地检查完整性，一致性和可行性。
* 三个问号（???）标记表示缺失信息。
* 更新引用部分；许多C++11之前的来源太老了。
* 一份或多或少是最新的待办列表，可以看：待办: 未归类的原始准则。

你可以阅读关于这份指南的适用范围和组织结构的解释，或者直接跳转到：
* In: 前言
* P: 哲学
* I: 接口
* F: 函数
* C: 类和类层次结构
* Enum: 枚举
* R: 资源管理
* ES: 表达式和语句
* Per: 性能
* CP: 并发与并行
* E: 错误处理
* Con: 常量和不变性
* T: 模板和泛型编程
* CPL: C风格编程
* SF: 源文件
* SL: 标准库

支持部分：
* A: 设计意图
* NR: 无准则与神话
* RF: 参考
* Pro: 配置
* GSL: 指南支持库
* NL: 命名和排版规则
* FAQ: 常见问题的回答
* 附录A: 程序库
* 附录B: 现代化代码
* 附录C: 讨论
* 附录D: 支持工具
* 词汇表
* 待办: 未归类的原始准则

你可以针对特定的语言特性选取准则来查看：
* 赋值：常规类型—优先初始化—复制—移动—其它操作—默认值
* 类：数据—不变式—成员—辅助工具—具体类型—构造函数，赋值函数和析构函数—层次结构—操作符
* 概念：规则—在泛型编程中—模板参数—语义
* 构造函数：不变式—建立不变式—`throw`—默认值—不需要的—`explicit`—委托——`virtual`
* 派生类：何时用—作为接口—析构函数—复制—获取器和设置器—多重继承—重载—切割—`dynamic_cast`
* 析构函数：和构造函数—何时需要？—可能不失败
* 异常：错误—`throw`—只为了错误—`noexcept`—最小化`try`—没有异常会怎样？
* `for`：基于范围的`for`与`for`—`for`与`while`—`for`初始化器—空循环体—循环变量—循环变量类型???
* 函数：命名—单一操作—不抛异常—参数—参数传递—多个返回值—指针—lambda
* 内联：小函数—在头文件中
* 初始化：总是—最好用`{}`—lambda—类内初始化器—类成员—工厂函数
* lambda表达式：何时使用
* 操作符：墨守成规的—避免转换操作符—与lambda
* `public`，`private`和`protected`：信息隐藏—一致性—`protected`
* 静态断言：编译时检查—与概念
* 结构体：为了组织数据—没有不变式时使用—没有私有成员
* 模板：抽象—容器—概念
* 无符号：与有符号—位操作
* 虚拟：接口—非虚拟—析构函数—永不失败

你可以查看用来解释准则的设计概念：
* 断言：???
* 错误：???
* 异常：异常保证（???）
* 失败：???
* 不变式：???
* 泄露：???
* 库：???
* 前置条件：???
* 后置条件：???
* 资源：???

## 概要
这份文档是为正确使用C++的指南合集。这份文档的目的是帮助人们有效地使用现代C++。对于“现代C++”，我们指C++17，C++14，以及C++11。换句话说，假设你可以从现在开始，你希望你的代码在5年后看起来是怎样的呢？在10年后呢？

这些指南专注于相对高层级的议题，例如接口，资源管理，内存管理，以及并发。这些准则影响到程序架构和程序库设计。遵守这些准则将会让代码静态类型安全，没有资源泄露，以及比现在的代码捕捉到更多编程逻辑错误。而且它会运行得快——你有能力把事情做好。

我们较少关注低层级的议题，例如命名规范和缩进风格。当然，可以帮助程序员的话题是不算越界的。

我们最初的准则合集强调（各种形式的）安全性和简洁性。它们很可能太严格。我们预计不得不引入更多的例外情况来更好地适应实际的需要。我们也需要更多的准则。

你可能会发现一些准则与你的期望相反，或者甚至与你的经验相反。如果我们没有建议你在任一方面改变你的编码风格，那么我们就失败了！请尝试去证实或者反证准则！特别是，我们真的希望我们的一些准则能得到测量数据或者更好例子的支持。

你可能会发现一些准则是显然的，甚至是无关紧要的。请记住这个指南的其中一个目的是帮助那些缺乏经验，或者来自其它不同背景或语言的人尽快上手。

许多准则设计为可以用分析工具来支持。违反准则的地方会被标记，用引用（或者链接）指向相关的准则。我们不希望你在写代码之前记住所有准则。思考这些指南的一个途径是，作为一个人们偶尔能阅读到的工具规格说明。

这些准则将会逐渐引入到一个代码库中。我们计划为其构建工具，并且希望其他人也这么做。

出于改进目的的评论和建议总是受欢迎的。我们计划在我们增进理解，以及语言和可用的程序库集改善的时候，修改和扩展这份文档。

## In: 前言
这是一份现代C++，即C++17，C++14和C++11的核心指南合集，同时把可能在未来实现的增强和ISO技术规范（TS）也考虑进去。它的目标是帮助C++程序员写出更简洁，更高效，更可维护的代码。

前言概要：
* In.taget: 目标读者
* In.aims: 目的
* In.not: 非目的
* In.force: 实施
* In.struct: 这份文档的结构
* In.sec: 主要章节

### In.target: 目标读者
所有C++程序员。这包括那些可能想用C的程序员。

### In.aims: 目标
这份文档的意图是帮助开发者采用现代C++（C++17，C++14和C++11）以及在代码库之间获得更加统一的风格。

我们不会被每一条准则都可以适用于每一个代码库的错觉欺骗。升级老的系统是困难的。然而，我们确实相信应用了准则的程序比不应用的程序更不容易出错而且更加可维护。通常，准则会让初期开发阶段更快速/更简单。在我们看来，这些准则产出的代码与更老更传统的技术运行得一样，或者更好；它们本身遵循零开销原则（“你不需要为你不使用的东西付出代价”或者“当你合理地使用一个抽象机制时，你会得到跟你用低级语言构件写过的东西一样好的性能”）。在旧代码上工作时，为新的代码思考这些准则的理念，找机会去利用，同时尽可能让这些理念得到实践。记住：

#### Ln.0: 不要惊慌！
花一点时间在你的程序中理解指南准则的含义。

这些指南是根据“超集的子集”原则（Stroustrup05）设计的。它们不是简单地定义一份C++的子集来使用（为了可读性，安全性，性能，或者其它别的）。相反，它们强烈建议使用一些简单的“扩展”（库组件），这些“扩展”使大部分容易出错的C++特性变得冗余，所以它们可以被禁止使用（在我们的准则合集中）。

这些准则强调静态类型安全和资源安全。出于这个原因，它们强调范围检查，避免解引用`nullptr`，避免悬挂指针，以及合理地使用异常（通过RAII）的可能性。部分为了达成目标，部分为了最小化作为错误来源的复杂代码，这些准则也强调简单性，以及把必要的复杂性隐藏在良好规范的接口下。

许多准则是规范的。我们对那些只是说“不要那样做！”而没有提供可代替方案的准则感到不安。这样的一个后果是一些准则只能通过试探法来支持，而不是通过明确和机械性可证实的检查。其它准则清晰地表达了普遍的原则。对于这些更普遍的准则，更详细和具体的准则会提供部分检查。

这些指南针对C++的核心和它的用法。我们预计大部分大型机构，特定应用领域，以及甚至是大型项目会需要更多的准则，可能是更多的限制，以及更多的库支持。例如，硬式实时程序员通常不能随意地使用自由存储（动态内存），而且会在他们选择程序库上收到限制。我们鼓励开发这类更特定的准则作为这些核心指南的补遗。创建你自己理想的小型基础程序库然后使用它，而不是降低你的编程层级来赞美汇编代码。

这些准则被设计来允许渐进采用。

一些准则的目的是增加各种形式的安全性，而另一些准则的目的是减少发生事故的可能性，许多准则两者都有。这些旨在防止事故的指南通常会禁止完全合法的C++。不管怎样，当有两种方式表达一个想法，并且其中一种已经展现出自己是错误的常见来源，而另一种不会的时候，我们会尽量把程序员引导到后者。

### In.not: 非目标
这些准则并非打算要最小化或互不相干。特别是，通用的准则可以是简单的，但不是不可实行的。同样，理解一个通用准则的含义是困难的。更专门的准则通常更容易理解和实行，但如果没有通用准则，它们仅仅是一长串的特殊案例。我们提供旨在帮助新手的准则以及支持专业用法的准则。一些准则可以完全实行，但其它的则基于试探法。

这些准则并不打算像书本一样要按顺序阅读。你可以使用链接在它们之间浏览。当然，它们的主要使用意图是作为工具的目标。也就是说，一个工具查找违规的地方，然后这个工具返回指向违反准则的链接。然后这些准则提供原因，违规的潜在后果的例子，以及建议的改进方法。

这些指南并不打算取代任何C++教程。如果你需要针对一些指定经验等级的教程，参考这里。

这不是一个如何把旧的C++代码转变成更现代的代码的指引。它以具体的方式来表达对新代码清晰的想法。当然，参考现代化章节来看看一些可能的方法来现代化/活力化/升级。重要的是，这些准则支持渐进采用：通常一次性完全转变一个大的代码库是不可能的。

这些指南并不打算在每一个语言技术细节上都做到完整的和准确的。它们也绝对不打算定义一个像Java那样的C++子集。它们不打算定义一个单一的“真正的C++”语言。我们重视表达能力和不妥协的性能。

这些准则不是价值中性的。它们的意图是在不损失性能的前提下，使代码比大部分已有的C++代码更简洁和更正确/安全。它们的意图是防止完美合理的C++代码与错误，不必要的复杂性以及低下的性能有关联。

这些准则不是完美的。一个准则可能由于禁止了一些在给定场景下有用的东西而导致损害。一个准则可能由于没有禁止一些在给定场景下会带来严重错误的东西而导致损害。一个准则可能由于模糊不清，有歧义，不可实行，或者对一个问题给出了每一种解决方法而带来很多损害。完全吻合“没有损害”的标准是不可能的。相反，我们的目标没有那么雄心勃勃：“为大部分程序员做大部分好事”；如果你不能与一个准则共存，反对它，忽略它，但是不要冲淡它直到它变得毫无意义。此外，要提出改进建议。

### In.force: 实施
不能强制实施的准则对于大型代码库来说是不可管理的。强制实施所有准则只对小型的弱准则集合或者一个特定用户社区是可能的。
* 但是我们想要大量准则，而且我们想要那些每个人都可以使用的准则。
* 但是不同的人有不同的需求。
* 但是人们不喜欢阅读大量准则。
* 但是人们不能记住很多准则。

所以，我们需要取子集来满足不同的需求。
* 但是随意的取子集会导致混乱。

我们想要可以帮助很多人，让代码更统一，以及强烈鼓励人们去现代化它们的代码的指南。我们想要鼓励最好的实践，而不是把一切都留给个人选择和管理压力。这里的想法是使用所有的准则；这会带来最大的好处。

这增加了相当多的困境。我们试图用工具来解决那些问题。每个准则有一个强制实施的部分列出了强制实施的想法。强制实施可以通过代码审查，静态分析，编译器或者运行时检查来执行。在尽可能的情况下，我们更喜欢“机械式”检查（人类是缓慢的，不准确地，以及容易厌烦）和静态检查。运行时检查只建议在不存在其它替代方法的情况下使用；我们不想引入“分散的脂肪”。在合适的地方，我们会（在实施部分）用相关准则组合（称为档案）的名字给一个准则加标注。一个准则可以是多个档案的一部分，或者不属于任何档案。作为开头，我们有一些档案对应常见的需求（要求，想法）：
* 类型（type）：没有类型违规（通过转换，联合体或者可变参数将一个类型`T`解析成类型`U`）
* 边界（bounds）：没有边界违规（访问超出数组范围）
* 生命周期（lifttime）：没有泄露（没有调用`delete`或者多重`delete`）以及不访问无效的对象（解引用`nullptr`，使用悬空引用）。

这些档案的意图是在工具中使用，但同时也可以为人类读者提供帮助。我们不会把我们在实施部分的评论限制在我们知道如何实施的东西上；一些评论仅仅是可能会激发一些工具作者的希望。

实现这些准则的工具应该遵守下面的语法来显式地禁止一个准则：
```
[[gsl::suppress(tag)]]
```

这里“tag”是实施规则所在项的锚点名字（例如，对于C.134是“Rh-public”），是准则组合档案的名字（“type”，“bounds”，或者“lifttime”），或者是档案中的一个特定准则（type.4，或者bounds.2）。

### In.struct: 这份文档的结构
每个准则（指南，建议）会有几个部分：
* 准则本身——例如，不使用裸露的`new`
* 一个准则的引用数字——例如C.7（相对于分类的第7条准则）。由于主要部分没有内在的排序，我们使用字母作为一个准则引用“数字”的第一部分。为了最小化在我们添加或移除准则时的“干扰”，我们在数字之间留下空隙。
* 理由（依据）——因为程序员难以遵守他们不理解的准则。
* 示例——因为准则在抽象层面上难以理解；可能是正面的或反面的
* 替代方案——给那些“不要这样做”的准则
* 例外——我们想要简单普遍的准则。然而，许多准则虽然应用广泛，但并不是任何时候都适用，因此例外情况必须要列出来
* 实施——关于准则如何可以被“机械性”检查的想法
* 参见——相关准则的引用，以及/或者进一步的讨论（在本文档或者其它地方）
* 注意（备注）——一些需要说明的，不符合其它类别的东西。
* 讨论——对更广泛的依据的引用，以及/或者放置在准则主列表外的示例。

有一些准则难以机械性地检查，但它们都符合最低的标准，让专业程序员可以发现许多违规而不用太多麻烦。我们希望“机械性”的工具可以改善时间花费来接近一个专业程序员注意到的东西。同样，我们假定随着时间的推移准则会变得精炼，让它们更精确和可检查的。

一个准则旨在简单，而不是用仔细的措辞来提及每一个替代方案和特殊情况。这些信息可以在替代方案段落和讨论部分找到。如果你不理解规则或者不同意它，请查看它的讨论。如果你觉得一个讨论缺失或者不完整，输入一个问题来解释你关注的事情以及一个可能的对应的公关。

这不是一个语言手册。它旨在有帮助的，而不是完整的，完全在技术细节上精确的，或者一个已有代码的指南。推荐信息的来源可以在引用找到。

### In.sec: 主要部分
* In: 前言
* P: 哲学
* I: 接口
* F: 函数
* C: 类和类层次结构
* Enum: 枚举
* R: 资源管理
* ES: 表达式和语句
* Per: 性能
* CP: 并发和并行
* E: 错误处理
* Con: 常量和不变性
* T: 模板和泛型编程
* CPL: C风格编程
* SF: 源代码文件
* SL: 标准库

支持部分：
* A: 设计意图
* NR: 无准则与神话
* RF: 参考
* Pro: 配置
* GSL: 指南支持库
* NL: 命名和排版规则
* FAQ: 常见问题的回答
* 附录A: 程序库
* 附录B: 现代化代码
* 附录C: 讨论
* 附录D: 支持工具
* 词汇表
* 待办: 未归类的原始准则

这些部分不是正交的。

每个部分（例如，“哲学”的“P”）和每个子部分（例如，“类层次结构（OOP）”的“C.hier”）都有一个为了易于搜索和引用的缩写。主要部分的缩写同样用在准则数字上（例如，“使具体类型常规化”的“C.11”）。

## P: 哲学
这部分的准则是非常普遍的。

哲学准则概要：
* P.1: 在代码中表达想法
* P.2: 基于ISO标准C++来写代码
* P.3: 表达意图
* P.4: 理想情况下，一个程序应该是静态类型安全的
* P.5: 宁可使用编译时检查而不是运行时检查
* P.6: 不能在编译时检查的东西应该可在运行时检查
* P.7: 尽早捕获运行时错误
* P.8: 不要泄露任何资源
* P.9: 不要浪费时间或空间
* P.10: 宁可使用不可变数据而不是可变数据
* P.11: 封装凌乱的结构，而不是在代码中扩散
* P.12: 酌情使用支持工具
* P.13: 酌情使用支持库

哲学性的准则一般不能被机械性地检查。然而，个别映射到这些哲学性准则的准则是可以的。如果缺少哲学性的基础，那些更具体/详细/可检查的准则会缺乏依据。

### P.1: 直接在代码中表达想法
##### 理由
编译器不会阅读注释（或者设计文档），很多程序员也（始终）不会。在代码中表达的东西有已定义好的语义，而且（在理论上）可以被编译器和其它工具检查。

##### 示例
```cpp
class Date {
    // ...
public:
    Month month() const;  // 可以这样做
    int month();          // 不要这样做
    // ...
};
```
`month`的第一个声明明确地说明了会返回一个`Month`，而且不会修改`Date`对象的状态。而第二个版本让读者自己去猜测，以及为捕捉不到的缺陷敞开了更多的可能性。

##### 示例；不好的
这个循环是`std::find`的一个有限制的形式：
```
void f(vector<string>& v)
{
    string val;
    cin >> val;
    // ...
    int index = -1;                    // 不好，而且应该使用gsl::index
    for (int i = 0; i < v.size(); ++i) {
        if (v[i] == val) {
            index = i;
            break;
        }
    }
    // ...
}
```

##### 示例；好的
一个更清晰的意图表达可能是：
```cpp
void f(vector<string>& v)
{
    string val;
    cin >> val;
    // ...
    auto p = find(begin(v), end(v), val);  // 好多了
    // ...
}
```
一个设计良好的库比直接使用语言特性更好地表达意图（做了什么事情，而不只是如何做）。

一个C++程序员应该了解标准库的基础知识，并且适当地使用它。任何程序员都应该了解项目中的基础库的基础知识，并且适当地使用它们。任何使用这些指南的程序员都应该了解指南支持库，并且适当地使用它。

##### 示例
```cpp
change_speed(double s);   // 不好：s表示什么？
// ...
change_speed(2.3);
```
一个更好的方法是显式说明double的含义（新的速度还是旧速度的增量？）和它使用的单位：
```cpp
change_speed(Speed s);    // 好多了：指定了s的含义
// ...
change_speed(2.3);        // 错误：没有单位
change_speed(23m / 10s);  // 米每秒
```
我们本可以接受将一个纯（无单位的）`double`作为增量，但那将会是容易出错的。如果我们同时想要绝对速度和增量，那么我们会定义一个`Delta`类型。

##### 实施
通常非常困难。
* 始终使用`const`（检查成员函数是否修改它们的对象；检查函数是否修改以指针或引用传递的参数）
* 标记类型转换的使用（类型转换会使类型系统失去作用）
* 检测与标准库相似的代码（困难）

### P.2: 使用ISO标准C++
##### 理由
这是一份关于ISO标准C++的指南合集。

##### 注意
有些环境下扩展是必要的，例如，访问系统资源。在这些情况下，局部化必要扩展的使用以及用非核心编码指南控制它们的使用。如果可能的话，创建接口来封装扩展以使它们能够被关闭，或者在不支持那些扩展的系统上从编译去掉。

扩展通常没有严格定义的语义。作为没有严格标准定义的直接后果，甚至那些常见的以及被多种编译器实现的扩展会有略微不同的行为和边界行为。当任何这些扩展使用得足够多的时候，期望得到的可移植性会受到冲击。

##### 注意
使用有效的ISO C++不能保证可移植性（更不用说正确性）。避免依赖未定义的行为（例如未定义的估值顺序），以及了解由实现定义意思的构件（例如`sizeof(int)`）。

##### 注意
有些环境下限制标准C++语言或者程序库特性的使用是必要的，例如，由于飞行器控制软件标准的需要而避免动态内存分配。在这些情况下，使用给这些特定环境定制的编码指南的扩展来控制它们的使用与否。

##### 实施
使用最新的C++编译器（目前的C++17，C++14，或者C++11），并且打开不接受扩展的选项。

### P.3: 表达意图
##### 理由
除非一些代码的意图已经被说明了（例如，在名字或者注释中），否则无从知道这些代码是否做了它应该做的事情。

##### 示例
```cpp
gsl::index i = 0;
while (i < v.size()) {
    // ... 用 v[i] 做一些事情 ...
}
```
遍历`v`的元素的意图没有在这里表达出来。使用索引的实现细节被暴露出来（因而它可能会被误用），`i`超出了循环的作用域，这可能是也可能不是预期的。只从这个代码片段读者不能了解到什么。

更好的写法：
```cpp
for (const auto& x : v) { /* 用 x 的值做一些事情 */ }
```
现在，没有显式提到迭代机制，而且循环的操作基于元素的`const`引用，因此不会出现意外的修改。如果想要进行修改，要这样：
```cpp
for (auto& x : v) { /* 修改 x */ }
```

关于for语句的更多细节，参见ES.71。有时还有更好的做法，使用具名的算法：
```cpp
for_each(v, [](int x) { /* 用 x 的值做一些事情 */ });
for_each(par, v, [](int x) { /* 用 x 的值做一些事情 */ });
```
最后一个变体版本表明我们对`v`的元素的处理顺序不感兴趣。

程序员应该熟悉：
* 指南支持库
* ISO C++标准库
* 任何用于当前项目的基础库

##### 注意
另一种表述：说明应该做什么，而不只是应该怎么做。

##### 注意
有些语言构件比其它构件更好地表达意图。

##### 示例
如果以两个`int`作为一个2D点的坐标，那么：
```cpp
draw_line(int, int, int, int);  // 晦涩的
draw_line(Point, Point);        // 更清晰
```

##### 实施
为常见的模式寻找是否有更好的选择。
* 单纯的`for`循环与基于范围的`for`循环
* `f(T*, int)`接口与`f(span<T>)`接口
* 作用域太大的循环变量
* 裸露的`new`和`delete`
* 具有许多内置类型参数的函数
智能和半自动程序转换是一个巨大的领域。

### P.4: 理想情况下，一个程序应该是静态类型安全的
##### 理由
理想情况下，一个程序是完全静态（编译时）类型安全的。不幸的是，这是不可能的。产生问题的地方：
* 联合体
* 类型转换
* 数组衰变
* 范围错误
* 收缩转换

##### 注意
这些地方是严重问题（例如，崩溃和安全违规）的来源。我们会尝试提供替代的技术。

##### 实施
根据不同程序的需求和可行性，我们可以分别禁止，限制或者检测每一种问题。总是提供替代方案的建议。例如：
* 联合体——使用`variant`（在C++17中）
* 类型转换——尽量减少使用；模板可以提供帮助
* 数组衰变——使用`span`（在GSL中）
* 范围错误——使用`span`
* 收缩转换——尽量减少使用，以及在必要的时候使用`narrow`或者`narrow_cast`（在GSL中）。

### P.5: 宁愿使用编译时检查而不是运行时检查
##### 理由
代码清晰性和性能。你不需要为在编译时捕获到的错误写错误处理代码。

##### 示例
```cpp
// Int 是整型的别名
int bits = 0;         // 不要这样做：可避免的代码
for (Int i = 1; i; i <<= 1)
    ++bits;
if (bits < 32)
    cerr << "Int too small\n";
```
这个例子不能完成它想要完成的事情（因为溢出是未定义的），而且应该用一个简单的`static_assert`来替换：
```cpp
// Int 是整型的别名
static_assert(sizeof(Int) >= 4);    // 要这样做：编译时检查
```
或者还有更好的做法，只使用类型系统，以及用`int32_t`替换`Int`。

##### 示例
```cpp
void read(int* p, int n);   // 读取最多n个整数到*p中

int a[100];
read(a, 1000);    // 不好，越界了
```
更好的做法
```cpp
void read(span<int> r); // 读取到整数范围r中

int a[100];
read(a);        // 好多了：让编译器找出元素的个数
```

另一种表述：不要把可以在编译时做的事情推迟到运行时。

##### 实施
* 查找指针参数。
* 查找运行时的范围违规检查。

### P.6: 可以在编译时检查的也应该可以在运行时检查
##### 理由
在程序中留下难以检测的错误是在要求崩溃和坏结果。

##### 注意
理想情况下，我们捕获所有编译时错误和运行时错误（不包括程序员逻辑中的错误）。捕获所有编译时错误是不可能的，而且通常不值得在运行时捕获所有剩下的错误。但是，我们应该努力写出理论上可以被检查，提供足够资源（分析程序，运行时检查，机器资源，时间）的程序。

##### 示例，不好的
```cpp
// 单独编译，可能是动态加载的
extern void f(int* p);

void g(int n)
{
    // 不好：元素的个数没有传递给f()
    f(new int[n]);
}
```
在这里，一个关键的信息（元素的个数）被如此彻底地“掩盖”，以至于静态分析可能不可行，而且当`f()`是ABI的一部分时动态检查可能非常困难，因此我们不能“检测”那个指针。我们可以嵌入有用的信息到自由存储中，但那样需要对一个系统或者可能对编译器进行全局修改。我们这里拥有的是一个让错误非常难被检测的设计。

##### 示例，不好的
我们当然可以跟指针一起传递元素的个数：
```cpp
// 单独编译，可能是动态加载的
extern void f2(int* p, int n);

void g2(int n)
{
    f2(new int[n], m);  // 不好：一个错误的元素个数可能被传递给f()
}
```
传递元素的个数作为参数比仅仅传递指针和依赖一些（假设的）约定来知道或发现元素的个数更好（而且更常见得多）。然而（如上所示），一个简单的输入错误可能会引起一个严重的错误。`f2()`两个参数之间的关联是约定的，而不是显式的。

而且，这里隐含了`f2()`应该用`delete`删除它的参数（否则调用者是否犯了第二个错误？）。

##### 示例，不好的
当标准库的资源管理指针指向一个对象的时候，不能传递大小：
```cpp
// 单独编译，可能是动态加载的
// 注意：这里假定调用代码是ABI兼容的，使用了一个兼容的C++编译器和相同的标准库实现
extern void f3(unique_ptr<int[]>, int n);

void g3(int n)
{
    f3(make_unique<int[]>(n), m);    // 不好：分开传递所有权和大小
}
```

##### 示例
我们需要将指针和元素的个数作为整体对象来传递：
```cpp
extern void f4(vector<int>&);   // 单独编译，可能是动态加载的
extern void f4(span<int>);      // 单独编译，可能是动态加载的
                                // 注意：这里假定调用代码是ABI兼容的，
                                // 使用了一个兼容的C++编译器和相同的标准库实现

void g3(int n)
{
    vector<int> v(n);
    f4(v);                     // 传递一个引用，维持所有权
    f4(span<int>{v});          // 传递一个视图，维持所有权
}
```
这个设计将元素个数作为一个对象的完整部分来传递，因此不大可能出现错误，而且动态（运行时）检查总是可行的，如果不总是值得的话。

##### 示例
为了有效地使用，我们如何同时传输所有权和所有需要的信息？
```cpp
vector<int> f5(int n)    // 好：移动
{
    vector<int> v(n);
    // ... 初始化 v ...
    return v;
}

unique_ptr<int[]> f6(int n)    // 不好：丢失了n
{
    auto p = make_unique<int[]>(n);
    // ... 初始化 *p ...
    return p;
}

owner<int*> f7(int n)    // 不好：丢失了n而且我们可能忘记删除
{
    owner<int*> p = new int[n];
    // ... 初始化 *p ...
    return p;
}
```

##### 示例
* ???
* 演示如何通过传递多态基类的接口来避免可能检查，当它们实际知道它们需要什么的时候？或者字符串作为“自由样式”选项

##### 实施
* 标记（指针，数量）风格的接口（这会标记很多由于兼容原因不能被修正的例子）
* ???

### P.7: 尽早捕获运行时错误
##### 理由
避免“神秘的”崩溃。避免导致（可能不被察觉的）不正确结果的错误。

##### 示例
```cpp
void increment1(int* p, int n)    // 不好：容易出错
{
    for (int i = 0; i < n; ++i) ++p[i];
}

void use1(int m)
{
    const int n = 10;
    int a[n] = {};
    // ...
    increment1(a, m);   // 可能是输入错误，可能应该 m <= n 
                        // 但假设 m == 20
    // ...
}
```
这里我们在`use1`中犯了一个小错误，可能会导致数据被破坏或者崩溃。（指针，数量）风格的接口让`increment1()`没有切实可行的方法来让自己防御超出范围错误。如果我们可以检查下标来发现超出范围的访问，那么直到访问`p[10]`之前错误都不会被发现。我们可以更早地检查以及改善代码：
```cpp
void increment2(span<int> p)
{
    for (int& x : p) ++x;
}

void use2(int m)
{
    const int n = 10;
    int a[n] = {};
    // ...
    increment2({a, m});    // 可能输入错误，可能应该 m <= n
    // ...
}
```
现在，`m <= n`可以在调用点（提早）来检查，而不是在更晚的点。如果我们只是输入错误，那么我们的意思是使用`n`作为边界，代码可以更简单（排除了出错的可能）：
```cpp
void use3(int m)
{
    const int n = 10;
    int a[n] = {};
    // ...
    increment2(a);   // 不需要重复元素的数量
    // ...
}
```

##### 示例，不好的
不要重复检查同一个值。不要以字符串传递结构化数据：
```cpp
Date read_date(istream& is);    // 从istream读取日期

Date extract_date(const string& s);    // 从string提取日期

void user1(const string& date)    // 处理日期
{
    auto d = extract_date(date);
    // ...
}

void user2()
{
    Date d = read_date(cin);
    // ...
    user1(d.to_string());
    // ...
}
```
日期被验证了两次（通过`Date`的构造函数）而且作为一个字符串（非结构化数据）被传递。

##### 示例
过度检查可能会代价高昂。有些时候提前检查是愚蠢的，因为你可能永远不需要这个值，或者可能只是需要这个值的一部分，而检查这部分比检查整个值简单得多。类似的，不要添加会改变你接口的渐进行为的有效性检查（例如，不要添加一个`O(n)`的检查到一个平均复杂度为`O(1)`的接口）。
```cpp
class Jet {    // 物理学说明：e * e < x * x + y * y + z * z
    float x;
    float y;
    float z;
    float e;
public:
    Jet(float x, float y, float z, float e)
        :x(x), y(y), z(z), e(e)
    {
        // 我应该在这里检查这些值是否具有物理意义吗？
    }

    float m() const
    {
        // 我应该在这里处理退化的情况吗？
        return sqrt(x * x + y * y + z * z - e * e);
    }

    ???
};
```
喷气式飞机的物理定律（`e * e < x * x + y * y + z * z`）不是一个不变式，因为可能存在测量错误。

##### 实施
* 查看指针和数组：提早做范围检查而且不重复
* 查看转换：排除或者标记收缩转换
* 查找来自输入的未被检查的值。
* 查找被转换成字符串的结构化数据（具有不变式）的类对象
* ???

### P.8: 不要泄露任何资源
##### 理由
即使资源缓慢增长，随着时间推移，也会耗尽这些资源的可用性。对于长时间运行的程序来说这特别重要，但这也是一个负责任的编程行为的必要部分。

##### 示例，不好的
```cpp
void f(char* name)
{
    FILE* input = fopen(name, "r");
    // ...
    if (something) return;   // 不好：如果 something == true，文件句柄被泄露了
    // ...
    fclose(input);
}
```
应该使用RAII：
```cpp
void f(char* name)
{
    ifstream input {name};
    // ...
    if (something) return;   // 好：没有泄露
    // ...
}
```

##### 参见：资源管理部分

##### 注意
用口语化的表述，泄露是指“任何没有清理的东西”。更重要的分类是“任何不能再清理的东西”。例如，在堆上分配一个对象，然后丢失了最后一个指向这个分配的指针。这个准则不应该被视为要求长生命周期对象中的分配必须在程序结束过程中返还。例如，依赖系统在进程结束时保证的清理，如关闭文件和释放内存，可以简化代码。当然，依赖隐含清理的抽象可以同样简单，通常也更安全。

##### 注意
强制使用生命周期配置来消除泄露。当结合了RAII提供的资源安全时，它消除了“垃圾回收”的需要（通过不生成垃圾）。把它与强制使用类型和边界配置结合，你会得到由工具保证的完整的类型和资源安全。

##### 实施
* 查看指针：把它们分成非所有者（默认）和所有者。可行的时候，把所有者替换成标准库的资源句柄（就像上面的示例那样）。或者，标记出所有者来使用来自GSL的`owner`。
* 查找裸露的`new`和`delete`
* 查找已知的会返回原始指针的资源分配函数（例如`fopen`，`malloc`以及`strdup`）

### P.9: 不要浪费时间或空间
##### 理由
这是C++。

##### 注意
为了达成目标（例如，开发速度，资源安全，或者简化测试），你利用得好的时间和空间并不算浪费。“争取效率的另一个好处是这个过程迫使你更深入地了解问题。”——Alex Stepanov

##### 示例，不好
```cpp
struct X {
    char ch;
    int i;
    string s;
    char ch2;

    X& operator=(const X& a);
    X(const X&);
};

X waste(const char* p)
{
    if (!p) throw Nullptr_error{};
    int n = strlen(p);
    auto buf = new char[n];
    if (!buf) throw Allocation_error{};
    for (int i = 0; i < n; ++i) buf[i] = p[i];
    // ... 处理buffer ...
    X x;
    x.ch = 'a';
    x.s = string(n);    // 把*p的空间赋予x.s
    for (gsl::index i = 0; i < x.s.size(); ++i) x.s[i] = buf[i];  // 把buf复制到x.s
    delete[] buf;
    return x;
}

void driver()
{
    X x = waste("Typical argument");
    // ...
}
```
是的，这是一个夸张的示例，但我们已经在产品代码中分别见过每个错误，甚至更糟糕。注意`x`的布局确保了至少有6个字节（而且很可能会更多）是浪费的。虚构的复制操作符定义禁止了移动语义，因此返回操作是缓慢的（请注意返回值优化，RVO，在这里是不保证生效的）。对`buf`的`new`和`delete`的使用时多余的；如果我们确实需要一个局部字符串，我们应该使用一个局部的`string`。还有几个性能缺陷和不必要的复杂性。

##### 示例，不好
```cpp
void lower(zstring s)
{
    for (int i = 0; i < strlen(s); ++i) s[i] = tolower(s[i]);
}
```
是的，这是一个来自产品代码的示例。我们把它留给读者去发现浪费了什么。

##### 注意
一个单独的浪费示例不怎么严重，当它严重，通常可以被专家轻松地消除。然而，在代码库中大量扩散的浪费容易变得严重，而且专家不是我们想要的那样总是可用。这个准则（以及支持它的更具体的准则）的目标是在大部分与C++用法有关的浪费发生之前消除它们。在这之后，我们可以看看与算法和需求相关的浪费，但这超出了这些指南的范围。

##### 实施
许多更具体的准则旨在实现简化和消除不必要浪费的总体目标。

### P.10: 宁可使用不可变数据而不是可变数据
##### 理由
说出常量比变量好的理由容易得多。不可改变的东西不会被意外修改。有时候不变性可以带来更好的优化。对于一个常量你不会有数据竞争的问题。

参见Con: 常量和不变性

### P.11: 封装混乱的构件，而不是在代码中扩散
##### 理由
混乱的代码更可能隐藏缺陷，而且更难写。好的接口可以更容易更安全地使用。混乱，低层级的代码滋生了更多这样的代码。

##### 示例
```cpp
int sz = 100;
int* p = (int*) malloc(sizeof(int) * sz);
int count = 0;
// ...
for (;;) {
    // ... 读取一个int到x，如果到达了文件的末尾则退出循环 ...
    // ... 检查x是否有效 ...
    if (count == sz)
        p = (int*) realloc(p, sizeof(int) * sz * 2);
    p[count++] = x;
    // ...
}
```
这是低层级的，啰嗦的，以及容易出错的。例如，我们“忘记”去检查内存耗尽。相反，我们可以使用`vector` ：
```cpp
vector<int> v;
v.reserve(100);
// ...
for (int x; cin >> x; ) {
    // ... 检查x是否有效 ...
    v.push_back(x);
}
```

##### 注意
标准库和GSL是这条哲学的例子。例如，为了不被数组，联合体，转换，棘手的生命周期问题，`gsl::owner`等扰乱，有必要实现关键的抽象，例如`vector`，`span`，`lock_guard`，以及`future`，我们使用这些比我们花费更多时间和专长的人设计和实现的库。类似的，我们应该设计和实现更专用的库，而不是给用户（通常是我们自己）留下重复获取低层级代码的挑战。这是超集的子集原则在这些指南下的变体。

##### 实施
* 查找“混乱的代码”，例如复杂的指针维护，以及在抽象实现外部的转换。

### P.12: 适当地使用辅助工具
##### 理由
有许多事情可以“被机器”做得更好。计算机不会疲劳或者对重复任务感到厌倦。我们一般有更好的事情要做，而不是重复做常规的任务。

##### 示例
运行一个静态检查器来验证你的代码是否遵守你想要的指南。

##### 注意
参见
* 静态分析工具
* 并发工具
* 测试工具
有很多其它类型的工具，例如源代码仓库，构建工具，等等，但那超出了这些指南的范围。

##### 注意
小心不要陷入对太精细或者太专用的工具链的依赖。那些东西会使你的可移植代码变得不可移植。

### P.13: 适当地使用辅助库
##### 理由
使用一个有良好设计，良好文档，以及良好支持的库节省时间和精力；如果你的主要时间必须花在实现上，那么它的质量和文档可能会比你能做到的更好。一个库的开销（时间，精力，金钱等）可以在许多用户之间共享。比起一个单独的程序，一个被广泛使用的库更可能保持最新，并且移植到新的操作系统。对一个被广泛使用的库的认识可以在其它/将来的项目中节省时间。所以，如果在你的程序领域中有一个合适的库，使用它。

##### 示例
```cpp
std::sort(begin(v), end(v), std::greater<>());
```
除非你是一个排序专家而且有很多时间，这很可能比你为特定程序写的任何东西更加准确以及运行得更快。你需要一个不使用标准库（或者其它你的程序使用的基础库）的理由，而不是使用它的理由。

##### 注意
默认使用
* ISO C++标准库
* 指南支持库

##### 注意
如果在一个重要的领域中缺少一个有良好设计，良好文档，和良好支持的库，那么可能你应该设计和实现它，然后使用它。

## I: 接口
接口是程序两个部分之间的合同。准确地说明服务供应商和该服务的用户所期望的内容是必要的。具有良好（易于理解，鼓励高效使用，不容易出错，支持测试等）的接口很可能是代码结构中最重要的一个方面。

接口准则总览：
* I.1: 使接口清晰
* I.2: 避免非const全局变量
* I.3: 避免单件
* I.4: 使接口精确和强类型化
* I.5: 声明前置条件（如果有的话）
* I.6: 使用`Expects()`表达前置条件
* I.7: 声明后置条件
* I.8: 使用`Ensures()`表达后置条件
* I.9: 如果接口是模板，使用概念将它的参数文档化
* I.10: 使用异常来指示执行所需任务的失败
* I.11: 永不通过原始指针（`T*`）或引用（`T&`）转移所有权
* I.12: 将不能为空的指针声明成`not_null`
* I.13: 不要将数组作为一个指针来传递
* I.22: 避免全局对象的复杂初始化
* I.23: 将函数参数的数量保持在少量
* I.24: 避免相同类型的相邻的无关系参数
* I.25: 首选抽象类作为接口，而不是类层次结构
* I.26: 如果你想要跨编译器的ABI，使用C风格子集
* I.27: 为了得到稳定的库ABI，考虑使用Pimpl技巧
* I.30: 封装准则违规

##### 另见：
* F: 函数
* C.Concrete: 具体类型
* C.hier: 类层次结构
* C.over: 重载和重写操作符
* C.con: 容器和其它资源句柄
* E: 错误处理
* T: 模板和泛型编程

### I.1: 使接口清晰
##### 理由
正确性。没有在接口说明的假设容易被忽略而且难以测试。

##### 示例，不好的
通过全局（名称空间作用域）变量（调用模式）来控制函数的行为是隐蔽的，以及潜在的令人困惑。例如：
```cpp
int round(double d)
{
    return (round_up) ? ceil(d) : d;    // 不要这样做：“不可见”的依赖
}
```
两次`round(7.2)`调用可能会得到不同结果，这对调用者来说是不明确的。

##### 例外
有时候我们通过环境变量来控制一系列操作的细节，例如，普通与详细输出，或者调试与优化。使用非局部的控制有潜在的困惑性，但它只控制了固定语义下其它方面的实现细节。

##### 示例，不好的
通过非局部变量（例如`errno`）来返回信息容易被忽略。例如：
```cpp
// 不要这样做：没有检查printf的返回值
fprintf(connection, "logging: %d %d %d\n", x, y, s);
```
如果连接被关闭以至于没有产生日志输出怎么办？参见I.???。

*替代方案*：抛异常。异常不能被忽略。

*替代方案*：避免通过非局部或者隐式状态跨接口传递信息。注意非`const`成员函数通过它们所在对象的状态来传递信息给其它成员变量。

*替代方案*：接口应该是一个函数或者一系列函数集合。函数可以是模板函数，函数集合可以是类或者类模板。

##### 实施
* （简单）函数不应该基于在名称空间作用域中声明的变量的值来做控制流决策。
* （简单）函数不应该修改在名称空间作用域中声明的变量。

### I.2: 避免非`const`全局变量
##### 理由
非`const`全局变量隐藏依赖，并且使依赖受到不可预知的修改的影响。

##### 示例
```cpp
struct Data {
    // ... 许多东西 ...
} data;            // 非const的data

void compute()     // 不要这样做
{
    // ... 使用data ...
}

void output()     // 不要这样做
{
    // ... 使用data ...
}
```
还有谁会修改`data`？

##### 注意
全局常量是有用的。

##### 注意
本准则针对全局变量，同时也适用于名称空间作用域变量。

*替代方案*：如果你使用全局（更多的是名称空间作用域）数据来避免复制，考虑将数据作为对象，以`const`引用来传递。其一个方案是将数据定义为一些对象的状态，将操作定义为成员函数。

*警告*：谨防数据竞争：如果一个线程在访问非局部数据（或者通过引用传递的数据），同时另一个线程在执行被调用函数，我们就会遇到数据竞争。每一个对可变数据的指针或引用都有潜在的数据竞争问题。

##### 注意
你不会在不可变数据上遇到竞争状态。

*参考*：参见调用函数的规则。

##### 实施
（简单）报告所有在名称空间作用域声明的非`const`变量。

### I.3: 避免单件
##### 理由
从根本上来说，单件是经过伪装的复杂的全局对象。

##### 示例
```cpp
class Singleton {
    // ... 许多东西来保证只有一个单件对象会被创建，
    // 以及正确地初始化，等等。
};
```
单件的概念有许多变体。这也是问题的一部分。

##### 注意
如果你不想一个全局对象被修改，把它声明为`const`或者`constexpr`。

##### 例外
你可以使用最简单的“单件”（它简单到通常不被认为是单件）来在首次使用的时候得到初始化，如果需要的话：
```cpp
X& myX()
{
    static X my_x {3};
    return my_x;
}
```
这是关于初始化顺序的其中一个最有效的解决方法。在多线程环境下，静态对象的初始化不会导致竞争状态（除非你不小心从一个共享对象的构造函数中访问了它自己）。

注意局部`static`的初始化并不意味着竞争状态。当然，如果`x`的析构发起了一个需要同步的操作，那么我们必须使用更简单的方案。例如：
```cpp
X& myX()
{
    static auto p = new X {3};
    return *p;  // 潜在的泄露
}
```
现在必须有人以合适的线程安全的方式，用`delete`删除对象。这是容易出错的，所以我们不使用这种技术，除非
* `myX`是在多线程执行的代码中，
* `X`对象需要销毁（例如，由于它要释放一个资源），而且
* `X`的析构函数的代码需要同步。

如果你像许多人做的那样，为了只有一个对象被创建而把单件定义成类，那么像`myX`这样的函数就不是单件，而且这个有用的技术不是无单件准则的例外。

##### 实施
通常非常困难。
* 查找名称包含`singleton`的类。
* 查找那些只有一个对象被创建的类（通过计算对象个数或者通过检查构造函数）。
* 如果类X有一个公有静态函数，包含一个类类型为X的函数局部静态变量，并且返回指向它的指针或者引用，那么禁止它。

### I.4: 使接口精确和强类型化
##### 理由
类型是最简单和最好的文档，具有良好定义的含义，而且可以保证在编译时被检查。同时，精确类型化的代码通常可以更好地优化。

##### 示例，不要这样做
考虑以下代码：
```cpp
void pass(void* data);    // void*是可疑的
```
现在被调用者必须将data指针转换回正确的类型来使用。这是容易出错的，而且通常是冗余的。避免`void*`，特别是在接口上。考虑使用`variant`或者指向基类的指针来代替。

*替代方案*：通常，模板参数可以消除`void*`，将它转成`T*`或者`T&`。对于泛型代码，这些`T`可以是普通的或者由概念约束的模板参数。

##### 示例，不好的
考虑以下代码：
```cpp
void draw_rect(int, int, int, int);   // 出错的好机会

draw_rect(p.x, p.y, 10, 20);          // 10, 20是什么意思？
```
`int`可以携带任意形式的信息，因此我们必须猜测四个`int`的含义。最有可能的是，前面两个是`x`，`y`坐标对，但后面两个是什么呢？注释和参数名称可以提供帮助，但我们可以让它更清晰：
```cpp
void draw_rectangle(Point top_left, Point bottom_right);
void draw_rectangle(Point top_left, Size height_width);

draw_rectangle(p, Point{10, 20});  // 两个角
draw_rectangle(p, Size{10, 20});   // 一个角和一对（高度，宽度）
```
显然，我们不能通过静态类型系统捕获到所有错误（例如，第一个参数应该是左上角的点，这个事实留给了约定（通过命名和注释））。

##### 示例，不好的
在下面的例子中，`time_to_blink`的含义从接口来看是不清晰的：是秒？还是毫秒？
```cpp
void blink_led(int time_to_blink) // 不好——单位不明确
{
    // ...
    // 用time_to_blink做些事情
    // ...
}

void use()
{
    blink_led(2);
}
```

##### 示例，好的
`std::chrono::duration`类型（C++11）有助于使时间段的单位清晰。
```cpp
void blink_led(milliseconds time_to_blink) // 好——单位清晰
{
    // ...
    // 用time_to_blink做些事情
    // ...
}

void use()
{
    blink_led(1500ms);
}
```
这个函数也可以按以下方式写成能够接受任意时间段单位。
```cpp
template<class rep, class period>
void blink_led(duration<rep, period> time_to_blink) // 好——接受任意单位
{
    // 假设毫秒是最小的相关单位
    auto milliseconds_to_blink = duration_cast<milliseconds>(time_to_blink);
    // ...
    // 用time_to_blink做些事情
    // ...
}

void use()
{
    blink_led(2s);
    blink_led(1500ms);
}
```

##### 实施
* （简单）报告使用`void*`作为参数或者返回值。
* （难以做好）查找用许多内置类型作为参数的成员函数。

### I.5: 声明前置条件（如果有的话）
##### 理由
参数有一些含义可能会限制它们在被调用者中正确的使用。

##### 示例
考虑以下代码：
```cpp
double sqrt(double x);
```
在这里`x`必须为非负数。类型系统不能（简单和自然地）表达这个含义，因此我们必须使用其它方法。例如：
```cpp
double sqrt(double x); // x必须为非负数
```
有些前置条件可以用断言来表达。例如：
```cpp
double sqrt(double x) { Expects(x >= 0); /* ... */ }
```
理想情况下，`Expects(x >= 0)`应该作为`sqrt()`接口的一部分，但这不容易做到。目前，我们把它放在定义（函数体）中。

*参考资料*：`Expects()`在GSL中描述。

##### 注意
优先使用需求的正式说明，例如`Expects(p);`。如果这不可行，在注释中使用文本说明，例如`// [p:q) 序列使用了<排序`。

##### 注意
大多数成员函数都是某些类不变式持有的前置条件。那些不变式通过构造函数来建立，而且必须通过每个被类外部调用的成员函数在退出之前重新建立。我们不需要为每个成员函数提到这一点。

##### 实施
（不可实施）

*参见*：传递指针的准则。???

### I.6: 优先使用`Expects()`来表达前置条件
##### 理由
清楚地说明这是前置条件，以及可以使用工具。

##### 示例
```cpp
int area(int height, int width)
{
    Expects(height > 0 && width > 0);            // 好的
    if (height <= 0 || width <= 0) my_error();   // 复杂的
    // ...
}
```

##### 注意
前置条件可以通过许多方式来声明，包括注释，`if`语句，以及`assert()`。这会使它们难以从普通代码中区分，难以更新，难以用工具维护，而且可能有错误的语义（你总是想要在调试模式下终止程序而在正式产品运行时不做任何检查吗？）。

##### 注意
前置条件应该是接口的一部分，而不是实现的一部分，但我们还没有语言设施来做到这点。一旦语言的支持变为可用（例如，参见合同提案），我们会采用标准版本的前置条件，后置条件和断言。

##### 注意
`Expects()`也可以在算法的中间用来检查条件。

##### 注意
不，使用`unsigned`并不是一个好方法来绕过保证值为非负数的问题。

##### 实施
（不可实施）查找可以用断言的各种形式的前置条件是不可行的。在缺少语言设施的情况下，对那些可以容易识别出来的断言（`assert()`）进行警告有可怀疑的价值。

### I.7: 声明后置条件
##### 理由
用以发现关于结果的误解，以及可能捕捉到错误的实现。

##### 示例，不好的
考虑以下代码：
```cpp
int area(int height, int width) { return height * width; }  // 不好的
```
在这里，我们（不小心）遗漏了前置条件的规范说明，因此高度和宽度必须为正数是不清晰的。我们也遗漏了后置条件的规范说明，因此这个算法（`height * width`）对那些大于最大整数的区域是错误的。可能会发生溢出。考虑使用以下做法：
```cpp
int area(int height, int width)
{
    auto res = height * width;
    Ensures(res > 0);
    return res;
}
```

##### 示例，不好的
考虑以下著名的安全缺陷：
```cpp
void f()    // 有问题的
{
    char buffer[MAX];
    // ...
    memset(buffer, 0, sizeof(buffer));
}
```
这里没有后置条件来声明缓冲区应该被擦除，优化器会去掉明显冗余的`memset()`调用：
```cpp
void f()    // 好多了
{
    char buffer[MAX];
    // ...
    memset(buffer, 0, sizeof(buffer));
    Ensures(buffer[0] == 0);
}
```

##### 注意
后置条件通常非正式地在声明函数目的的注释中声明；`Ensures()`可以用来使这更加系统，明显以及可被检查。

##### 注意
当后置条件提到的一些东西在返回结果中没有直接反映出来时，它尤其重要，例如用到的数据结构的状态。

##### 示例
考虑以下函数，该函数操作一个`Record`，使用`mutex`来避免竞争状态：
```cpp
mutex m;

void manipulate(Record& r)    // 不要这样做
{
    m.lock();
    // ... 缺少 m.unlock() ...
}
```
在这里，我们“忘记”声明`mutex`应该被释放，因此我们不知道没有确保释放`mutex`是缺陷还是特性。声明后置条件会使其清晰：
```cpp
void manipulate(Record& r)    // 后置条件：m在退出之前解锁
{
    m.lock();
    // ... 缺少 m.unlock() ...
}
```
这个缺陷现在变得明显了（但只对于人们可读的注释）。

还有更好的方法，使用RAII来确保后置条件（“锁必须释放”）在代码中被实行。
```cpp
void manipulate(Record& r)    // 最好的
{
    lock_guard<mutex> _ {m};
    // ...
}
```

##### 注意
理想情况下，后置条件在接口/声明中声明，因此用户可以容易地看到它们。只有跟用户相关的后置条件可以在接口中声明。只跟内部相关的后置条件在定义/实现中声明。

##### 实施
（不可实施）这是一个哲学的指南，在一般情况下直接检查是不可行的。领域特定的检查器（像持锁检查器）在许多工具链中存在。

### I.8: 优先使用`Ensures()`来表达后置条件
##### 理由
清楚地说明这是后置条件，以及可以使用工具。

##### 示例
```cpp
void f()
{
    char buffer[MAX];
    // ...
    memset(buffer, 0, MAX);
    Ensures(buffer[0] == 0);
}
```

##### 注意
后置条件可以通过许多方式声明，包括注释，`if`语句以及`assert()`。这使得它们难以从普通代码中区分，难以更新，难以通过工具维护，以及可能会有错误的语义。

*替代方案*：“该资源必须释放”形式的后置条件可以通过RAII来最好的表达。

##### 注意
理想情况下，`Ensures`应该是接口的一部分，但这不容易做到。目前，我们把它放在了定义（函数体）中。一旦语言的支持变为可用（例如，参见合同提案）我们会采用标准版本的前置条件，后置条件以及断言。

##### 实施
（不可实施）查找可以用断言的各种形式的后置条件是不可行的。在缺少语言设施的情况下，对那些可以容易识别出来的断言（`assert()`）进行警告有可怀疑的价值。

### I.9: 如果接口是模板，使用概念将它的参数文档化
##### 理由
使接口有精确的说明，以及在（不远的）将来可在编译时检查。

##### 示例
使用需求说明的ISO概念TS风格。例如：
```cpp
template<typename Iter, typename Val>
// requires InputIterator<Iter> && EqualityComparable<ValueType<Iter>>, Val>
Iter find(Iter first, Iter last, Val v)
{
    // ...
}
```

##### 注意
不久之后（可能在2018年），一旦`//`被移除，大多数编译器将能够检查`requires`语句。概念在GCC 6.1及之后的版本提供支持。

*另见*：泛型编程和概念。

##### 实施
（还不能实施）语言设施正在进行规范化。当语言设施可用时，如果任何非可变模板参数不受概念（在它的声明或者`requires`语句中提到的）约束时进行警告。

### I.10: 使用异常来指示执行所需任务的失败
##### 理由
不能忽略错误，因为这会导致系统或者计算处于未定义（或者意外）的状态。这是错误的主要来源。

##### 示例
```cpp
int printf(const char* ...);    // 不好：如果输出失败，返回负数

template <class F, class ...Args>
// 好：如果不能开启新线程，抛出system_error
explicit thread(F&& f, Args&&... args);
```

##### 注意
什么是错误？

错误意味着函数不能实现它所宣称目的（包括建立后置条件）。调用忽略错误的代码会导致不正确的结果或者未定义的系统状态。例如，不能连接到远程服务器本身不算是错误：服务器可能出于各种原因拒绝连接，因此自然的做法是返回一个调用者应该总是检查的结果。当然，如果连接失败被认为是错误，那么这个失败应该抛出异常。

##### 例外
许多传统接口函数（例如UNIX信号处理器）使用错误码（例如`errno`）来报告的事实上是状态码，而不是错误。你没有好的替代方案来使用这些接口，因此调用这些接口不违反本准则。

##### 替代方案
如果你不能使用异常（例如，因为你的代码满是旧式原始指针的使用，或者因为存在硬实时的限制），考虑使用返回一对值的方法：
```cpp
int val;
int error_code;
tie(val, error_code) = do_something();
if (error_code) {
    // ... 处理错误或者退出 ...
}
// ... 使用val ...
```
不幸的是，这种方法会导致未初始化的变量。一个用来处理该问题的结构绑定设施将会在C++17变为可用。
```cpp
auto [val, error_code] = do_something();
if (error_code) {
    // ... 处理错误或者退出 ...
}
// ... 使用val ...
```

##### 注意
我们不认为“性能”是不使用异常的有效理由。
* 通常，显式的错误检查和处理会消耗与异常处理一样多的时间和空间。
* 通常，更简洁的代码在异常下会有更好的性能（简化了在程序中跟踪路径及其优化）。
* 对于注重性能的代码来说，一个良好的准则是把检查从代码的关键部分转移出去（检查）。
* 从长远来看，更规范的代码会得到更好的优化。
* 在做出性能要求之前, 总是要仔细地测量。

*另见*：I.5和I.7对前置条件和后置条件违规的报告。

##### 实施
* （不可实施）这是一个哲学指南，直接检查是不可行的。
* 查找`errno`。

### I.11: 永不通过原始指针（`T*`）或引用（`T&`）转移所有权
##### 理由
如果对是否调用者或被调用者拥有对象存有任何疑问，泄露或者过早的销毁就会发生。

##### 示例
考虑以下代码：
```cpp
X* compute(args)    // 不要这样做
{
    X* res = new X{};
    // ...
    return res;
}
```
谁来释放返回的`x`？如果`compute`返回一个引用，这个问题会更难确认。考虑通过值来返回结果（如果结果庞大的话，使用移动语义）：
```cpp
vector<double> compute(args)  // 好
{
    vector<double> res(10000);
    // ...
    return res;
}
```

*替代方案*：使用“智能指针”传递所有权，例如`unique_ptr`（对独占所有权）和`shared_ptr`（对共享所有权）。当然，与返回对象自己相比，这是更不优雅的，而且通常效率更低，因此只有在需要引用语义的时候才使用智能指针。

*替代方案*：有时由于ABI兼容需要或者缺乏资源而不能修改旧代码。在这种情况下，使用来自指南支持库的`owner`来标记所拥有的指针。
```cpp
owner<X*> compute(args)    // 现在清楚地表明所有权被转移了
{
    owner<X*> res = new X{};
    // ...
    return res;
}
```
这告诉分析工具`res`是一个所有者。也就是说，它的值必须被`delete`删除或者转移给其它所有者，就像这里的`return`所做的那样。

在资源句柄的实现中，`owner`被类似地使用。

##### 注意
每个作为原始指针（或迭代器）传递的对象都假设由调用者拥有，因此它的生命周期由调用者来处理。用另一种方式来看：与传递指针的API相比，所有权转移的API相对更少见，因此默认是“没有所有权转移”。

*另见*：参数传递，智能指针参数的使用，以及值返回。

##### 实施
* （简单）如果用`delete`删除的原始指针不是一个`owner<T>`，发出警告。建议使用标准库的资源句柄或者使用`owner<T>`。
* （简单）在每个代码路径上，如果没有调用`reset`或者显式用`delete`删除一个`owner`指针，发出警告。
* （简单）如果`new`的返回值或者返回`owner`的函数调用赋值给一个原始指针或者非`owner`引用，发出警告。

### I.12: 把必须不能为空的指针声明成`not_null`
##### 理由
帮助避免解引用`nullptr`错误。通过避免冗余的检查`nullptr`来提高性能。

##### 示例
```cpp
int length(const char* p);            // 不清楚length(nullptr)是否有效

length(nullptr);                      // OK?

int length(not_null<const char*> p);  // 好多了：我们可以假设p不能为nullptr

int length(const char* p);            // 我们必须假设p可以为nullptr
```
通过在源代码中声明意图，实现者和工具可以提供更好的诊断，例如通过静态分析发现一些类型的错误，以及更好的优化，例如移除分支和空值检查。

##### 注意
`not_null`在指南支持库中定义。

##### 注意
假设指向`char`的指针是指向C风格字符串（以0结尾的字符串）仍然是隐式的，而且是困惑和错误的潜在来源。优先使用`czstring`来代替`const char*`。
```cpp
// 我们可以假定p不能为nullptr
// 我们可以假定p指向以0结尾的字符数组
int length(not_null<zstring> p);
```
注意：当然，`length()`是`std::strlen()`的伪装。

##### 实施
* （简单）（（基础））如果一个函数在所有控制流路径上，在访问一个指针参数之前都要与`nullptr`检查，那么以应该声明为`not_null`进行警告。
* （复杂）如果一个具有指针返回值的函数保证在所有返回路径上都不为`nullptr`，那么以返回类型应该声明为`not_null`进行警告。

### I.13: 不要把数组作为单一指针来传递
##### 理由
（指针，大小）风格的接口容易出错。而且，（指向数组的）单一指针必须依赖于一些约定来允许被调用者确定大小。

##### 示例
考虑以下代码：
```cpp
void copy_n(const T* p, T* q, int n); // 从 [p:p+n) 复制到 [q:q+n)
```
如果`q`指向的数组有少于`n`个的元素会怎么样？这样的话，我们覆写了一些很可能不相关的内存。如果`p`指向的数组有少于`n`个的元素会怎么样？这样的话，我们读取了一些很可能不相关的内存。这两种情况都是未定义行为，以及潜在的糟糕的缺陷。

##### 替代方案
考虑使用显示的片段：
```cpp
void copy(span<const T> r, span<T> r2); // 复制 r 到 r2
```

##### 示例，不好的
考虑以下代码：
```cpp
void draw(Shape* p, int n);  // 糟糕的接口；糟糕的代码
Circle arr[10];
// ...
draw(arr, 10);
```
传递`10`作为参数`n`可能是一个错误：最常见的习惯用法是假设`[0:n)`，但这没有地方来说明。更坏的是对`draw()`的调用可以通过编译：这里有一个从数组到指针的隐式转换（数组衰变），然后有另一个从`Circle`到`Shape`的隐式转换。`draw()`没有办法可以安全地遍历数组：它没有办法知道元素的个数。

*替代方案*：使用一个辅助类型来保证元素的个数是正确的，以及避免危险的隐式转换。例如：
```cpp
void draw2(span<Circle>);
Circle arr[10];
// ...
draw2(span<Circle>(arr));  // 推导元素的个数
draw2(arr);    // 推导元素的类型和数组大小

void draw3(span<Shape>);
draw3(arr);    // 错误：Circle[10] 不能转换成 span<Shape>
```
`draw2()`传递了相同数量的信息给`draw()`，但它让参数应该是一个`Circle`范围成为显式的。参考???。

##### 例外
使用`string`和`czstring`来表示C风格的，以零结束的字符串。但这样做的时候，使用来自GSL的`string_span`来避免范围错误。

##### 实施
* （简单）（（范围））对任何依赖于从数组类型到指针类型的隐式转换表达式进行警告。允许zstring/czstring指针类型的例外情况。
* （简单）（（范围））对任何基于指针类型、结果也是指针类型的算术操作表达式进行警告。允许zstring/czstring指针类型的例外情况。

### I.22: 避免全局对象的复杂初始化
##### 理由
复杂的初始化会导致不确定的执行顺序。

##### 示例
```cpp
// file1.c

extern const X x;

const Y y = f(x);   // 读取x; 写入y

// file2.c

extern const Y y;

const X x = g(y);   // 读取y; 写入x
```
由于`x`和`y`位于不同的编译单元，调用`f()`和`g()`的顺序是不确定的；其中一个将会访问到未初始化的`const`。这个示例展示了全局（名称空间域）对象的初始化顺序问题不仅限于全局/变量/。

##### 注意
在并发代码中，初始化顺序的问题变得特别难以处理。通常最好完全避免使用全局（名称空间域）对象。

##### 实施
* 标记出那些调用非`constexpr`函数的全局对象的初始化。
* 标记处那些访问`extern`对象的全局对象的初始化。

I.23: 保持少量的函数参数
##### 理由
许多的参数为混乱创造了机会。传递许多参数的开销通常比其它方式更昂贵。

##### 讨论
函数有太多参数的两个最常见的原因是：
1. /缺乏抽象/。由于缺乏抽象，复合的值被作为单一的元素来传递，而不是作为一个保证了不变式的单一对象来传递。这不仅仅扩大了参数列表，而且会导致错误，因为其中的组成值不再被保证了的不变式来保护。
2. /违反了“一个函数，一个职责”/。函数尝试去做多于一件的事情，很可能应该被重构。

##### 示例
标准库的`merge()`处于我们能够轻松处理的极限：
```cpp
template<class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
OutputIterator merge(InputIterator1 first1, InputIterator1 last1,
                     InputIterator2 first2, InputIterator2 last2,
                     OutputIterator result, Compare comp);
```
注意这是因为上面提到的问题1——缺乏抽象。STL不传递范围（抽象），而是传递迭代器对（未封装的组成值）。

这里，我们有四个模板参数和六个函数参数。为了简化最频繁和最简单的用法，用于比较的参数可以默认为`<`：
```cpp
template<class InputIterator1, class InputIterator2, class OutputIterator>
OutputIterator merge(InputIterator1 first1, InputIterator1 last1,
                     InputIterator2 first2, InputIterator2 last2,
                     OutputIterator result);
```
这并没有减少整体的复杂度，但它减少了展现给许多用户的表面复杂度。为了真正地减少参数数量，我们需要把参数打包成更高级的抽象：
```cpp
template<class InputRange1, class InputRange2, class OutputIterator>
OutputIterator merge(InputRange1 r1, InputRange2 r2, OutputIterator result);
```
把参数组合成“包”是一个普遍的技术来减少参数数量，以及增加检查的机会。

另外，我们可以使用概念（在ISO TS中定义）来定义三种类型的概念必须是可以用来合并：
```cpp
Mergeable{In1, In2, Out}
OutputIterator merge(In1 r1, In2 r2, Out result);
```

##### 示例
安全性配置建议把：
```cpp
void f(int* some_ints, int some_ints_length);  // 不好：C风格，不安全
```
替换成
```cpp
void f(gsl::span<int> some_ints);              // 好：安全，有边界检查
```
这里，使用抽象带来安全性和健壮性的好处，而且自然地减少了参数的数量。

##### 注意
多少个参数算是太多？尝试使用少于四（4）个参数。有些函数用四个单独的参数能最好地表示，用更多则不行。

*替代方案*：使用更好的抽象：把参数组合成更具含义的对象，然后传递这个对象（传值或传引用）。

*替代方案*：使用默认参数或者重载，以允许用更少的参数来完成最常见的调用方式。

##### 实施
* 当一个函数声明了两个相同类型的迭代器（包括指针）而不是一个范围或者一个视图时，发出警告。
* （不可实施）这是一个不能直接检查的哲学指南。

### I.24: 避免无关的同类型参数相邻
##### 理由
相邻的同类型参数容易被错误地交换。

##### 示例，不好的
考虑以下代码：
```cpp
void copy_n(T* p, T* q, int n);  // 从[p:p + n)复制到[q:q + n)
```
这是令人讨厌K&R C风格接口的变体。它容易调转了“目标”和“来源”参数。

为“来源”参数使用`const`：
```cpp
void copy_n(const T* p, T* q, int n);  // 从[p:p + n)复制到[q:q + n)
```

##### 例外
如果参数的顺序不重要，那么是没有问题的：
```cpp
int max(int a, int b);
```

##### 替代方案
不要以指针传递数组，传递一个表示范围的对象（例如`span`）：
```cpp
void copy_n(span<const T> p, span<T> q);  // 从p复制到q
```

##### 替代方案
定义一个`struct`作为参数类型，并且相应地给那些参数命名：
```cpp
struct SystemParams {
    string config_file;
    string output_path;
    seconds timeout;
};
void initialize(SystemParams p);
```
这会使得这个函数调用对未来的读者更清晰，因为参数通常在调用点通过名字来赋值。

##### 实施
（简单）如果两个连续的参数拥有相同的类型，发出警告。

### I.25: 优先使用抽象类作为接口而不是类层次结构
##### 理由
相较于有状态的基类，抽象类更可能保持稳定。

##### 示例，不好的
你只知道`Shape`会在某个地方出现 :-)
```cpp
class Shape {  // 不好的: 带有数据的接口类
public:
    Point center() const { return c; }
    virtual void draw() const;
    virtual void rotate(int);
    // ...
private:
    Point c;
    vector<Point> outline;
    Color col;
};
```
这会强迫每个派生类都去计算一个中点——即使这个计算不是轻量的以及这个中点从来不使用。类似的，不是每个`Shape`都有`Color`，而且不使用定义为`Point`序列的轮廓的话，许多`Shape`反而能更好的表示。抽象类用来防止用户写出这样的类：
```cpp
class Shape {    // 好多了: Shape是一个纯接口
public:
    virtual Point center() const = 0;   // 纯接口函数
    virtual void draw() const = 0;
    virtual void rotate(int) = 0;
    // ...
    // ... no data members ...
};
```

##### 实施
（简单）如果一个对类`C`的指针/引用被赋值给一个对类`C`的基类的指针/引用，而且这个基类包含数据成员，发出警告。

### I.26: 如果你想要一个跨编译器的ABI，使用C风格子集
##### 理由
不同的编译器对类、异常处理、函数名称以及其它实现细节实现了不同的二进制布局。

##### 例外
你可以小心地使用一些谨慎选择的高层级C++类型来创造接口。参考???。

##### 例外
在一些平台上出现了常见的ABI，使你摆脱更苛刻的限制。

##### 注意
如果你使用单一的编译器，你可以在接口中使用完整的C++。这可能需要在升级到新的编译器版本之后重新编译。

##### 实施
（不可实施）可靠地识别出接口形成了ABI的哪一部分很困难。

### I.27: 为了得到稳定的库ABI，考虑使用pimpl技巧
##### 理由
由于私有数据成员参与了类布局，私有成员函数参与了重载解析，对这些实现细节的修改需要让所有使用了某个类的用户重新编译。一个非多态的，持有一个指向实现（pimpl）的接口类可以将类的用户从修改中隔离出来，以间接访问作为代价。

##### 示例
接口（widget.h）
```cpp
class widget {
    class impl;
    std::unique_ptr<impl> pimpl;
public:
    void draw(); // 公有API，会被转发给实现
    widget(int); // 在实现文件中定义
    ~widget();   // 在实现文件中定义，在该文件中impl是完整的类型。
    widget(widget&&) = default;
    widget(const widget&) = delete;
    widget& operator=(widget&&); // 在实现文件中定义
    widget& operator=(const widget&) = delete;
};
```
实现（widget.cpp）
```cpp
class widget::impl {
    int n; // 私有数据
public:
    void draw(const widget& w) { /* ... */ }
    impl(int n) : n(n) {}
};
void widget::draw() { pimpl->draw(*this); }
widget::widget(int n) : pimpl{std::make_unique<impl>(n)} {}
widget::~widget() = default;
widget& widget::operator=(widget&&) = default;
```

##### 注意
参见GOTW #100 和cppreference以了解与该技巧相关的权衡和额外的实现细节。

##### 实施
（不可实施）可靠地识别出接口形成了ABI的哪一部分很困难。

### I.30: 封装准则违规
##### 理由
为了保持代码简单和安全。有时候，处于逻辑或性能原因，丑陋、不安全或者容易出错的技术是必要的。如果是这样的话，使它们保持局部，而不是“传染”给接口，导致更大范围的程序员必需感知到这些精妙的存在。实现的复杂度应该——如果可能的话——不能通过接口泄露到用户代码中。

##### 示例
考虑一个程序，它依赖于某种形式的输入（例如`main`的参数），应该从文件、从命令行或者标准输入获取输入。我们可能会写
```cpp
bool owned;
owner<istream*> inp;
switch (source) {
case std_in:        owned = false; inp = &cin;                       break;
case command_line:  owned = true;  inp = new istringstream{argv[2]}; break;
case file:          owned = true;  inp = new ifstream{argv[2]};      break;
}
istream& in = *inp;
```
这违反了“避免未初始化变量”准则，“忽略所有权”准则，以及“避免魔法常量”准则。特别是，某个人必须记得在某个地方写
```cpp
if (owned) delete inp;
```
通过使用`unique_ptr`和一个特别的对`cin`什么也不做的删除器，我们可以处理这个具体的例子，但是这对于新手（容易遇到这个问题的人）来说是复杂的，而且这是一个更普遍问题的例子，即我们认为是静态的属性（在这里是所有权）很少需要在运行时处理。常见的、最频繁的以及最安全地例子可以静态地处理，因此我们不想在那上面增加开销和复杂度。但是我们必须同时应付不常见的、不么安全的以及必要的更昂贵的情况。这些例子在[Str15]中讨论。

因此，我们写了一个类
```cpp
class Istream { [[gsl::suppress(lifetime)]]
public:
    enum Opt { from_line = 1 };
    Istream() { }
    Istream(zstring p) :owned{true}, inp{new ifstream{p}} {}            // 从文件读取
    Istream(zstring p, Opt) :owned{true}, inp{new istringstream{p}} {}  // 从命令行读取
    ~Istream() { if (owned) delete inp; }
    operator istream& () { return *inp; }
private:
    bool owned = false;
    istream* inp = &cin;
};
```
现在，`istream`所有权的动态本质已经被封装起来。一些针对潜在错误的检查大概会添加到实际的代码中。

##### 实施
* 困难，判定哪些违反准则的代码必不可少很困难。
* 标记出那些导致跨接口违反准则的准则抑制。

## F: 函数
一个函数描述了一种行为或者一种计算，使系统从一个一致的状态转变到下一个状态。它是程序的基本构造块。

可以用有确切含义的名称来命名函数，说明其参数的需求，以及清楚地说明参数和结果之间的关系。实现并不是规范说明。尝试去思考一个函数做了什么以及它是如何做到的。函数在大部分接口中是最重要的部分，所以参见接口准则。

函数准则概要：

函数定义准则：
* F.1: 把有确切含义的操作“打包”成谨慎命名的函数
* F.2: 一个函数应该执行单一的逻辑操作
* F.3: 保持函数短小和简单
* F.4: 如果一个函数必须在编译时求值，把它声明为`constexpr`
* F.5: 如果一个函数非常小且对时间很关键，把它声明为内联
* F.6: 如果你的函数不会抛出异常，把它声明为`noexcept`
* F.7: 对于普通用法，使用`T*`或者`T&`作为参数而不是智能指针
* F.8: 优先使用纯函数
* F.9: 不使用的参数应该没有名字

参数传递表达式准则：
* F.15: 优先使用简单和常规的方式来传递信息
* F.16: 对于“输入”参数，拷贝廉价的类型以值方式传递，其它类型以`const`引用方式传递
* F.17: 对于“输入-输出”参数，以非`const`引用方式传递
* F.18: 对于“消费”参数，以`X&&`方式传递并且在参数上使用`std::move`
* F.19: 对于“转发”参数，以`TP&&`方式传递并且只在参数上使用`std::forward`
* F.20: 对于“输出”值，优先使用返回值而不是输出参数
* F.21: 为了返回多个“输出”值，优先返回一个元组或结构
* F.60: 当“无参数”是有效的选项时，优先使用`T*`而不是`T&`

参数传递语义准则：
* F.22: 使用`T*`或`owner<T*>`来表示单一对象
* F.23: 使用`not_null<T>`来指明“null”不是有效的值
* F.24: 使用`span<T>`或`span_p<T>`来表示半开序列
* F.25: 使用`zstring`或`not_null<zstring>`来表示C风格字符串
* F.26: 在需要使用指针的地方，使用`unique_ptr<T>`来转移所有权
* F.27: 使用`shared_ptr<T>`来共享所有权

值返回语义准则：
* F.42: 返回`T*`来指示位置（只用于这种情况）
* F.43: 永不（直接或间接）返回指向局部对象的指针或引用
* F.44: 当不希望拷贝以及不需要“返回无对象”时，返回`T&`
* F.45: 不要返回`T&&`
* F.46: `int`是`main()`的返回值
* F.47: 在赋值操作符中返回`T&`

其它函数准则：
* F.50: 在函数不能达到目的的时候使用lambda（捕捉局部变量，或者写一个局部函数）
* F.51: 在可以选择的时候，优先使用默认参数而不是重载
* F.52: 在局部使用的lambda中，优先以引用来捕获变量，包括传递给算法
* F.53: 在非局部使用的lambda中，避免以引用来捕获变量，包括返回，在堆中存储，或者传递给其它线程
* F.54: 如果你捕获了`this`，显式地捕获所有变量（非默认捕获）
* F.55: 不要使用`va_arg`参数

函数与lambda和函数对象有很强的相似性。

*另见*：C.lambdas: 函数对象和lambda

## F.def: 函数定义
函数定义是指同时描述了函数实现，即函数体的函数声明。

### F.1: 把有确切含义的操作“打包”成谨慎命名的函数
##### 理由
把通用的代码重构出来可以使代码更加可读，更可能被重用，以及限制在复杂代码中出现错误。如果有些东西是具有良好说明的行为，把它从周围的代码中分离出来并且给它一个名称。

##### 示例，不要这样做
```cpp
void read_and_print(istream& is)    // 读取和打印一个int
{
    int x;
    if (is >> x)
        cout << "the int is " << x << '\n';
    else
        cerr << "no int on input\n";
}
```
`read_and_print`中几乎所有东西都是错的。它读，它写（到一个固定的`ostream`），它写错误信息（到一个固定的`ostream`），它只处理`int`。没有东西可以重用，逻辑上独立的操作混合在一起，并且局部变量在它们逻辑使用后的作用域内。对于一个细小的例子，这看起来没问题，但如果输入操作、输出操作和错误处理变得更加复杂的时候，纠缠在一起的混乱会变得难以理解。

##### 注意
如果你写了一个非平凡的lambda，它有潜在的可能性用在多个地方，那么把它赋值给一个（通常是非局部的）变量，以给它一个名字。

##### 示例
```cpp
sort(a, b, [](T x, T y) { return x.rank() < y.rank() && x.value() < y.value(); });
```
命名那个lambda会把表达式分解成它的逻辑部分，并且为lambda的含义提供了强烈的提示。
```cpp
auto lessT = [](T x, T y) { return x.rank() < y.rank() && x.value() < y.value(); };

sort(a, b, lessT);
find_if(a, b, lessT);
```
对于性能或者可维护性来说，最短的代码并不总是最好的。

##### 例外
循环体，包括作为循环体使用的lambda，很少需要被命名。然而，大的循环体（例如，许多行或者许多页）可能会是问题。保持函数短小和简单的准则暗示了“保持循环体短小”。类似的，作为回调参数使用的lambda有时是非平凡的，也不太可能被重用。

##### 实施
* 参见保持函数短小和简单
* 标记在多个不同地方使用的相同或非常相似的lambda

### F.2: 一个函数应该执行单一的逻辑操作
##### 理由
一个执行单一操作的函数更容易理解、测试和重用。

##### 示例
考虑以下代码：
```cpp
void read_and_print()    // 不好的
{
    int x;
    cin >> x;
    // 检查错误
    cout << x << "\n";
}
```
这是与特定输入绑定的庞大单元，永远找不到其它（不同的）用途。相反，应该把函数分解成合适的逻辑部分以及参数化：
```cpp
int read(istream& is)    // 好多了
{
    int x;
    is >> x;
    // 检查错误
    return x;
}

void print(ostream& os, int x)
{
    os << x << "\n";
}
```
这些函数现在可以根据需要来组合：
```cpp
void read_and_print()
{
    auto x = read(cin);
    print(cout, x);
}
```
如果需要的话，我们可以进一步在数据类型、输入/输出机制、对错误的响应等方面模板化`read()`和`print()`。例如：
```cpp
auto read = [](auto& input, auto& value)    // better
{
    input >> value;
    // check for errors
};

auto print(auto& output, const auto& value)
{
    output << value << "\n";
}
```

##### 实施
* 多于一个“输出”参数的函数是值得怀疑的。使用返回值来代替，包括使用`tuple`来返回多个返回值。
* 不能在编辑器的一个屏幕中显示完整的“大型”函数是值得怀疑的。考虑把这类函数重构成更小的具有良好命名的子操作。
* 有7个或以上参数的函数是值得怀疑的。

### F.3: 保持函数短小和简单
##### 理由
大的函数难以阅读，更可能包含复杂的代码，而且更可能包含超出其最小作用域的变量。拥有复杂控制结构的函数更可能长而且更可能隐藏逻辑错误。

##### 示例
考虑以下代码：
```cpp
double simple_func(double val, int flag1, int flag2)
    // simple_func: 获取一个值并且计算出期望的ASIC输出，
    // 基于两个模式标记。
{
    double intermediate;
    if (flag1 > 0) {
        intermediate = func1(val);
        if (flag2 % 2)
             intermediate = sqrt(intermediate);
    }
    else if (flag1 == -1) {
        intermediate = func1(-val);
        if (flag2 % 2)
             intermediate = sqrt(-intermediate);
        flag1 = -flag1;
    }
    if (abs(flag2) > 10) {
        intermediate = func2(intermediate);
    }
    switch (flag2 / 10) {
    case 1: if (flag1 == -1) return finalize(intermediate, 1.171);
            break;
    case 2: return finalize(intermediate, 13.1);
    default: break;
    }
    return finalize(intermediate, 0.);
}
```
这过于复杂（和长）。你怎么知道是否所有可能的分支情况都被正确地处理了呢？是的，它也违反了其它准则。

我们可以重构：
```cpp
double func1_muon(double val, int flag)
{
    // ???
}

double funct1_tau(double val, int flag1, int flag2)
{
    // ???
}

double simple_func(double val, int flag1, int flag2)
    // simple_func: 获取一个值并且计算出期望的ASIC输出，
    // 基于两个模式标记。
{
    if (flag1 > 0)
        return func1_muon(val, flag2);
    if (flag1 == -1)
        // 在func1_tau中处理: flag1 = -flag1;
        return func1_tau(-val, flag1, flag2);
    return 0.;
}
```

##### 注意
“不能在一屏中显示完整”通常是“太大”的一个良好、切实可行的定义。一到五行的函数应该认为是正常的。

##### 注意
把大的函数拆分成更小的内聚和命名的函数。当函数调用的开销变得重要时，短小简单的函数容易被内联。

##### 实施
* 标记出“不能在一屏中显示完整”的函数。一屏是多大？试试60行，每行140个字符；这大致是适合书页的最大值。
* 标记出过于复杂的函数。多复杂算是太复杂？你可以使用圈复杂度。试试“超过10个逻辑路径”。将一个简单的分支算作一个路径。

### F.4: 如果一个函数必须在编译时求值，把它声明为`constexpr`
##### 理由
`constexpr`用来告诉编译器允许编译时求值。

##### 示例
（不）著名的阶乘：
```cpp
constexpr int fac(int n)
{
    constexpr int max_exp = 17;      // constexpr允许max_exp在Expects中使用
    Expects(0 <= n && n < max_exp);  // 避免愚蠢和溢出
    int x = 1;
    for (int i = 2; i <= n; ++i) x *= i;
    return x;
}
```
这是C++14。对于C++11，使用`fac()`的递归形式。

##### 注意
`constexpr`不保证编译时求值；它只保证函数可以对常量表达式参数在编译时求值，在程序员要求这么做或者编译器决定这么做来优化的时候。
```cpp
constexpr int min(int x, int y) { return x < y ? x : y; }

void test(int v)
{
    int m1 = min(-1, 2);            // 可能是编译时求值
    constexpr int m2 = min(-1, 2);  // 编译时求值
    int m3 = min(-1, v);            // 运行时求值
    constexpr int m4 = min(-1, v);  // 错误：不能在编译时求值
}
```

##### 注意
`constexpr`函数是纯的：它们不能有副作用。
```cpp
int dcount = 0;
constexpr int double(int v)
{
    ++dcount;   // 错误：在constexpr函数中企图有副作用
    return v + v;
}
```
通常这是非常好的事情。

当给定一个非常量参数，`constexpr`函数会抛出异常。如果你认为抛出异常来退出是一个副作用，那么`constexpr`函数不是完全纯的；否则，这就不是问题。??? 留给委员会的一个问题：一个被`constexpr`函数抛出的异常的构造函数能否修改状态？“不能”会是一个好的答案，符合大部分的实践。

##### 注意
不要尝试把所有函数声明成`constexpr`。大部分计算最好在运行时完成。

##### 注意
最终依赖高层级运行时配置或者业务逻辑的任何API都不应该为`constexpr`。这种定制不能由编译器求值，而且任何依赖于这些API的`constexpr`函数都必须重构或者去掉`constexpr`。

##### 实施
不可能也没必要。如果在需要常量的地方调用了一个非`constexpr`函数，编译器会给出错误。

##### F.5: 如果函数非常短小并且对时间很关键，把它声明为`inline`
##### 理由
在没有程序员的提示下，有些优化器也能做好内联，但不要依赖这种情况。要进行测量！在过去的40年左右，我们已经承诺会有那么一个编译器，在人们没有提示的情况下，它的内联可以比人们做得更好。我们仍然在等待。指定`inline`促使编译器做得更好。

##### 示例
```cpp
inline string cat(const string& s, const string& s2) { return s + s2; }
```

##### 例外
不要把`inline`函数放到被认为是稳定的接口中，除非你确定它不会改变。内联函数是ABI的一部分。

##### 注意
`constexpr`暗含了`inline`。

##### 注意
在类内部定义的成员函数默认是`inline`。

##### 例外
模板函数（包括模板成员函数）通常定义在头文件中，因此是内联的。

##### 实施
标记那些超过三个语句，并且可能已经在行外声明的`inline`函数（例如类成员函数）。

### F.6: 如果你的函数不会抛出异常，把它声明为`noexcept`
##### 理由
如果不应该抛出异常，那么不能假定程序会应付错误，并且应该尽快结束。把函数声明为`noexcept`有助于优化器减少额外的执行路径的数量。它也会提高在失败后退出的速度。

##### 示例
为每个完全用C或其它没有异常的语言写的函数加上`noexcept`。C++标准库对C标准库中的所有函数都隐式地做了这个声明。

##### 注意
在运行时求值的时候，`constexpr`函数可能会抛异常，所以对于这其中的一些函数你可能需要`noexcept`。

##### 示例
你甚至可以在会抛异常的函数上使用`noexcept`：
```cpp
vector<string> collect(istream& is) noexcept
{
    vector<string> res;
    for (string s; is >> s;)
        res.push_back(s);
    return res;
}
```
如果`collect()`耗尽了内存，程序会崩溃。除非程序被制作成可以在内存不足时存活，这可能只是要做的正确事情；`terminate()`会生成合适的错误日志信息（但是在内存耗尽之后，难以做任何聪明的事情）。

##### 注意
当在决定是否为函数加上`noexcept`的时候，你必须意识到你的代码正在运行的执行环境，尤其是因为抛异常和分配的问题。想要完全通用的代码（像标准库和其它这类的工具代码）需要支持可以有意义地处理`bad_alloc`异常的环境。然而，大部分程序和执行环境不能有意义地处理分配失败，在那些情况下，终止程序是对分配失败最干净和最简单的回应。如果你知道你的程序代码不能回应分配失败，那么即使在分配函数上添加`noexcept`也可能是合适的。

换种方式：在大部分程序中，大部分函数会抛异常（例如，由于它们使用了`new`，调用了会这么做的函数，或者使用了通过抛异常来报告失败的库函数），所以不要只是把`noexcept`散播到所有地方，而不考虑可能的异常是否能被处理。

对于频繁使用、低层级的函数来说，`noexcept`是最有用的（而且也是最清晰正确的）。

##### 注意
析构函数、`swap`函数、移动操作符以及默认构造函数应该永不抛出异常。

##### 实施
* 标记出会抛异常的`swap`、`move`、析构函数和默认构造函数。
* 标记出没有`noexcept`也不会抛异常的函数。

### F.7: 对于普通用法，使用`T*`或者`T&`作为参数而不是智能指针
##### 理由
传递智能指针会转移或共享所有权，应该只有在需要所有权语义的时候才使用（参考R.30）。传递智能指针限制了函数只能由使用智能指针的调用者使用。传递共享智能指针（例如`std::shared_ptr`）隐含了运行时开销。

##### 示例
```cpp
// 接受任何int*
void f(int*);

// 只能接受那些你想转移所有权的int
void g(unique_ptr<int>);

// 只能接受那些你想共享所有权的int
void g(shared_ptr<int>);

// 不改变所有权，但要求调用方有特定的所有权
void h(const unique_ptr<int>&);

// 接受任何int
void h(int&);
```

##### 示例，不好的
```cpp
// 被调用者
void f(shared_ptr<widget>& w)
{
    // ...
    use(*w); // 只使用了w——生命周期根本没有使用
    // ...
};
```
参考R.30获取更多信息。

##### 注意
我们可以静态地捕获悬挂指针，所以我们不需要依赖资源管理来避免来自悬挂指针的违规行为。

##### 另见
* 当“没有参数”是有效的选项时，优先使用`T*`而不是`T&`
* 智能指针准则概要

##### 实施
标记出所有权语义没有被使用的智能指针类型（重载了`operator->`或`operator*`的类型）参数；也就是说：
* 可复制但从不复制/移动，或者可移动但从不移动
* 并且从不修改或者传递给其它会这样做的函数。

### F.8: 优先使用单纯函数
##### 理由
单纯函数更容易推理，有时更容易优化（甚至并行化），并且有时可以做备忘缓存。

##### 示例
```cpp
template<class T>
auto square(T t) { return t * t; }
```

##### 注意
`constexpr`函数是单纯的。

当给定一个非常量参数时，`constexpr`函数会抛出异常。如果你认为抛出异常来退出是一个副作用，那么`constexpr`函数不是完全纯的；否则，这就不是问题。??? 留给委员会的一个问题：一个被`constexpr`函数抛出的异常的构造函数能否修改状态？“不能”会是一个好的答案，符合大部分的实践。

##### 实施
不可能。

### F.9: 不使用的参数应该没有名字
##### 理由
可读性。防止出现未使用参数警告。

##### 示例
```cpp
X* find(map<Blob>& m, const string& s, Hint);   // 提示（hint）曾经被使用过
```

##### 注意
允许参数未命名在1980年代早期引入来处理这个问题。

##### 实施
标记出命名的未使用参数。

## F.call: 参数传递
有多种方式来传递参数给函数或者返回值。

### F.15: 优先使用简单和常规的方式来传递信息
##### 理由
使用“与众不同和聪明”的技术会导致意想不到的事情，给其他程序员的理解造成负担，并且容易出现缺陷。如果你真的觉得需要使用超出常见技术的优化，进行测量来确保它真的有提升，并且写好文档/注释，因为这个提升也许不是可移植的。

下面的表格总结了后续指南F.16-21的建议。

普通参数传递：
[image:245B84B0-CCF1-49EA-9563-FF6A685693DF-22679-0002673998E1A97C/537D1B91-819D-4F17-A8FE-DA2C52EC1542.png]

高级参数传递：

[image:157228FA-70C5-4EB9-B07B-683D029432D4-22679-0002673E0B8DFBEA/A4C776D2-B212-46BC-B1C7-D901FBE531F3.png]

仅在证实了需求之后才使用高级技术，并且在注释中做好这个需求的文档。

### F.16: 对于“输入”参数，拷贝廉价的类型以值方式传递，其它类型以`const`引用方式传递
##### 理由
两种方式都让调用者知道函数不会修改参数，并且两者都允许以右值初始化。

什么是“拷贝廉价”取决于机器架构，但两个或三个字的类型（双精度浮点数，指针，引用）通常最好以值来传递。当拷贝是廉价时，没有东西可以胜过拷贝的简洁性和安全性，并且对于小对象（多达两个或三个字）来说，拷贝也会比通过引用传递快，因为它不需要在函数中进行一次额外的间接访问。

##### 示例
```cpp
void f1(const string& s);  // 好的：以const引用传递；总是廉价的

void f2(string s);         // 不好的：有潜在的昂贵

void f3(int x);            // 好的：不可超越

void f4(const int& x);     // 不好的：: 在f4()中有访问开销
```

（仅）对于高级用法，你确实需要对传递给“只用于输入”的右值进行优化的场景：
* 如果函数将会无条件地从参数移动，通过`&&`来接收它。参见F.18。
* 如果函数将会保留参数的拷贝，除了通过`const&`传递（针对左值）之外，添加一个通过`&&`传递（针对右值）参数的重载，并且在函数体中用`std::move`移动到它的目标。本质上，这种做法重载了一个“消费”；参见F.18。
* 在特殊情况下，例如多个“输入+拷贝”参数，考虑使用完美转发。参考F.19。

##### 示例
```cpp
int multiply(int, int); // 只输入整数，以值传递

// suffix是只用于输入，但没有int那么廉价，以const&传递
string& concatenate(string&, const string& suffix);

void sink(unique_ptr<widget>);  // 只用于输入，并且消费了widget
```

避免“深奥的技术”，例如：
* “为了效率”以`T&&`传递参数。大部分关于用`&&`传递的性能优势的谣言都是错误的或者经不起推敲的（但是参见F.18和F.19）。
* 从赋值操作符和类似的操作中返回`const T&`（参见F.47）。

##### 示例
假设`Matrix`具有移动操作（可能通过在一个`std::vector`中保存元素）：
```cpp
Matrix operator+(const Matrix& a, const Matrix& b)
{
    Matrix res;
    // ... 用sum填充res ...
    return res;
}

Matrix x = m1 + m2;  // 移动构造

y = m3 + m3;         // 移动赋值
```

##### 注意
返回值优化不会处理赋值情况，但是移动赋值会。

可以假定一个引用指向一个有效的对象（语言规则）。不存在（合理的）“空引用”。如果你需要一个可选值的概念，使用指针、`std::optional`、或者用来表示“没有值”的特殊值。

##### 实施
* （简单）（（基础））当一个以值传递的参数具有大于`4 * sizeof(int)`的大小，发出警告。建议使用`const`引用代替。
* （简单）（（基础））当一个以引用传递的`const`参数具有小于`3 * sizeof(int)`的大小，发出警告。建议以值传递代替。
* （简单）（（基础））当一个以引用传递的`const`参数是经过了`std::move`移动的，发出警告。

### F.17: 对“输入输出”参数，以非`const`引用来传递
##### 理由
这会让调用者清楚地知道对象是会被修改的。

##### 示例
```cpp
void update(Record& r);  // 假设更新会写到r
```

##### 注意
一个`T&`参数可以传递信息进函数也可以传出去。因此`T&`可以是一个输入输出参数。这本身可能是一个问题和错误的来源：
```cpp
void f(string& s)
{
    s = "New York";  // 不明显的错误
}

void g()
{
    string buffer = ".................................";
    f(buffer);
    // ...
}
```
这里，`g()`的作者提供了一个缓冲区给`f()`填充，但是`f()`简单地替换了它（以某种程度上比简单地复制字符更高的成本）。如果`g()`的作者不正确地假设了`buffer`的大小，可能会出现严重的逻辑错误。

##### 实施
* （中等）（（基础））对于不写入非`const`参数的函数发出警告。
* （简单）（（基础））当一个以引用来传递的非`const`参数是经过了`std::move`移动的，发出警告。

### F.18: 对于“消费”参数，以`X&&`传递并且用`std::move`移动参数
##### 理由
这是高效的，并且能在调用方排除缺陷：`X&&`绑定到右值，如果传递的是左值，在调用方需要显式地使用`std::move`。

##### 示例
```cpp
void sink(vector<int>&& v) {   // sink获取了所有参数拥有的所有权
    // 在这里通常可能会有对v的const访问
    store_somewhere(std::move(v));
    // 在这里通常再也没有对v的使用；它被移走了
}
```
注意`std::move(v)`使得`store_somewhere()`能够把`v`变成被移走状态。这可能是危险的。

##### 例外
只能移动并且移动廉价的唯一所有者类型，例如`unique_ptr`，也能够以值来传递，这会写得更简单并且能达到同样的效果。以值传递的确会生成一个额外的（廉价的）移动操作，但首选简洁性和清晰性。

例如：
```cpp
template <class T>
void sink(std::unique_ptr<T> p) {
    // 使用p ... 可能在别的地方使用了std::move(p)
}   // p被销毁
```

##### 实施
* 标记所有在函数体中没有以`std::move`使用的`X&&`参数（这里`X`不是模板类型参数名称）。
* 标记对已移走对象的访问。
* 不要有条件性地移动对象。

### F.19: 对于“转发”参数，以`TP&&`传递并且只使用`std::forward`转发参数
##### 理由
如果对象被传递给其它代码并且不会被这个函数直接使用，我们要让这个函数不感知参数的常量性和右值性。

在且仅在这种情况下，使参数为`TP&&`，这里`TP`是一个模板类型参数——它同时忽略和保留了常量性和右值性。因此任何使用了`TP&&`的代码隐式地声明了它自己不会关心变量的常量性和右值性（因为被忽略了），但是会把值传递给其它关心常量性和右值性的代码（因为被保留了）。当作为参数使用时`TP&&`是安全的，因为任何从调用者传递来的临时对象会在函数的调用期间中存活。一个类型为`TP&&`的参数应该本质上总是在函数体中通过`std::forward`向前传递。

##### 示例
```cpp
template <class F, class... Args>
inline auto invoke(F f, Args&&... args) {
    return f(forward<Args>(args)...);
}

??? 调用 ???
```

### 实施
* 如果一个函数接受`TP&&`参数（这里`TP`是模板类型参数名称），并且除了在每个静态路径上只用`std::forward`转发它一次之外，还做了其它任何事情，标记这个函数。

### F.20: 对于“输出”输出值，优先使用返回值而不是输出参数
##### 理由
返回值是自带文档的，而`&`可以是输入输出的或者仅输出的，可能被误用。

这包括了大型对象，比如标准容器，它们为了性能使用隐式的移动操作，避免显式的内存管理。

如果你有多个值要返回，使用元祖或者类似的多成员类型。

##### 示例
```cpp
// 好的：返回指向值与x相同的元素的指针
vector<const int*> find_all(const vector<int>&, int x);

// 不好的：在out中存放指向值与x相同的元素的指针
void find_all(const vector<int>&, vector<const int*>& out, int x);
```

##### 注意
一个包含许多元素（各自是移动廉价）的`struct`可能整体上的移动是昂贵的。

不建议返回一个`const`值。这些老的建议现在被淘汰了；它没有增添价值，并且会妨碍移动语义。
```cpp
const vector<int> fct();    // 不好的：那个“const”比它的价值带来更多麻烦

vector<int> g(const vector<int>& vx)
{
    // ...
    fct() = vx;   // 被“const”阻止
    // ...
    return fct(); // 昂贵的拷贝：移动语义被“const”抑制了
}
```
关于添加`const`到返回值的争论是，它避免（非常少的）对临时对象的意外访问。对立的争论是它阻止（非常频繁的）移动语义的使用。

##### 例外
* 对于非值类型，例如在继承层次结构中的类型，以`unique_ptr`或`shared_ptr`返回对象。
* 如果类型移动昂贵（例如，`array<BigPID>`），考虑在自由存储上分配它并且返回一个句柄（例如，`unique_ptr`），或者在一个非`const`引用的目标对象上传递它来填充（作为输出参数来使用）。
* 为了在一个内部循环的多个函数调用之间重用带有容量的对象（例如，`std::string`，`std::vector`）：把它当成输入/输出参数并且以引用传递。

##### 示例
```cpp
struct Package {      // 例外情况：移动昂贵的对象
    char header[16];
    char load[2024 - 16];
};

Package fill();       // 不好的：大的返回值
void fill(Package&);  // 好的

int val();            // 好的
void val(int&);       // 不好的：val是否会读取它的参数？
```

##### 实施
* 标记那些在被写入之前没有读取并且其类型的返回是廉价的非`const`引用参数；它们应该是“输出”返回值。
* 标记返回一个`const`值的情况。修复：移除`const`来返回一个非`const`值。

### F.21: 为了返回多个“输出”值，优先返回元组或结构
##### 理由
作为一个“仅输出”值，返回值自带文档。注意C++没有多个返回值，通过使用`tuple`（包括`pair`）的约定，可能在调用方使用`tie`会有额外的便利。

##### 示例
```cpp
// 不好的：在注释中标注仅输出参数
int f(const string& input, /*output only*/ string& output_data)
{
    // ...
    output_data = something();
    return status;
}

// 好的：自带文档
tuple<int, string> f(const string& input)
{
    // ...
    return make_tuple(status, something());
}
```
C++98的标准库已经使用了这种方式，因为`pair`就像两个元素`tuple`。例如，给定一个`set<string> my_set`，考虑以下代码：
```cpp
// C++98
result = my_set.insert("Hello");
if (result.second) do_something_with(result.first);    // workaround
```
在C++11中我们可以这样写，把结果直接放在已有的局部变量中：
```cpp
Sometype iter;                                // 如果我们还没有值，使用默认初始化
Someothertype success;                        // 为了一些其它目的使用这些变量

tie(iter, success) = my_set.insert("Hello");   // 普通返回值
if (success) do_something_with(iter);
```
在C++17中我们应该能够使用“结构绑定”来声明和初始化多个变量：
```cpp
if (auto [ iter, success ] = my_set.insert("Hello"); success) do_something_with(iter);
```

##### 例外
有时候，我们需要传递一个对象给函数来维护它的状态。在这种情况下，以引用`T&`传递对象通常是正确的技术。显式用返回值再次把一个输入输出参数传出来通常是不必要的。例如：
```cpp
istream& operator>>(istream& is, string& s);    // 很像std::operator>>()

for (string s; cin >> s; ) {
    // do something with line
}
```
这里，`s`和`cin`都作为输入输出参数使用。我们以（非`const`）引用传递`cin`以便能够维护它的状态。我们传递`s`来避免重复的分配。通过重用`s`（以引用传递），我们只在需要扩大`s`的容量时才分配新内存。这个技术有时称为“调用者分配的输出”模式，而且对于需要进行自由存储分配的类型，如`string`和`vector`特别有用。

作为对比，如果我们把所有值作为返回值传出来，我们会有类似下面的代码：
```cpp
pair<istream&, string> get_string(istream& is);  // 不建议
{
    string s;
    is >> s;
    return {is, s};
}

for (auto p = get_string(cin); p.first; ) {
    // 用p.second做些事情
}
```
我们认为明显不那么优雅比明显降低性能好。

为了真正严格地阅读这条准则（F.21），这个例外不是真的例外，因为它依赖于输入输出参数，而不是在这条准则中提到的纯粹的输出参数。然而，我们更想要清晰，而不是模糊。

##### 注意
在许多情况下，返回一个特定的，用户定义的类型可能有用。例如：
```cpp
struct Distance {
    int value;
    int unit = 1;   // 1表示米
};

Distance d1 = measure(obj1);        // 访问d1.value和d1.unit
auto d2 = measure(obj2);            // 访问d2.value和d2.unit
auto [value, unit] = measure(obj3); // 访问value和unit；对于了解measure()的人来说稍微多余
auto [x, y] = measure(obj4);        // 不要这样做；这可能会使人困惑
```
过于通用的`pair`和`tuple`应该仅在返回的值表示独立实体而不是抽象时使用。

其它示例，使用一个特定的类型和`variant<T, error_code>`一起使用，而不是使用通用的`tuple`。

##### 实施
* 输出参数应该用返回值来替换。输出参数是函数会写入，用来调用非`const`成员函数，或者以非`const`传递的参数。

### F.22: 使用`T*`或者`owner<T*>`来表示单一对象
##### 理由
可读性：它使得纯指针的意义更清晰。开启重要工具的支持。

##### 注意
在传统的C和C++代码中，纯`T*`用在许多弱相关的目的，例如：
* 标识一个（单一）对象（不能被这个函数删除）
* 指向一个在自由存储上分配的对象（在稍后删除）
* 持有`nullptr`
* 标识一个C风格字符串（以零结尾的字符数组）
* 与一个分开指定的长度一起标识一个数组
* 标识一个数组中的位置
这会难以理解代码做了什么和它应该做什么。它使得检查和工具支持复杂化。

##### 示例
```cpp
void use(int* p, int n, char* s, int* q)
{
    p[n - 1] = 666; // 不好的：我们不知道p是否指向n个元素；
                    // 假设它没有或不使用span<int>
    cout << s;      // 不好的：我们不知道s是否指向一个以零结尾的字符数组
                    // 假设它没有或不使用zstring
    delete q;       // 不好的：我们不知道*q是否在自由存储上分配的
                    // 假设它没有或不使用owner
}
```
更好的做法
```cpp
void use2(span<int> p, zstring s, owner<int*> q)
{
    p[p.size() - 1] = 666; // 好的，可以捕捉范围错误
    cout << s; // 好的
    delete q;  // 好的
}
```

##### 注意
`owner<T*>`表示所有权，`zstring`表示C风格字符串。

*而且*：假设从一个指向`T`的智能指针（例如，`unique_ptr<T>`）获取的`T*`指向一个单一元素。

*另见*：支持库

##### 实施
* （简单）（（边界））对作用在指针类型表达式上，并且结果是指针类型的算术操作发出警告。

### F.23: 使用`not_null<T>`来指明“null”不是有效值
##### 理由
清晰性。带有`not_null<T>`参数的函数清楚地表明了函数的调用者有责任对任何`nullptr`进行必要的检查。类似的，带有`not_null<T>`返回值的函数清楚地表明了函数的调用者不需要检查`nullptr`。

##### 示例
`not_null<T*>`让读者（人或机器）明显地知道在解引用之前检查`nullptr`是不必要的。另外，在调试的时候，`owner<T*>`和`not_null<T>`可以用来进行正确性检查。

考虑以下代码：
```cpp
int length(Record* p);
```
当我调用`length(p)`的时候我应该先检查`p`是否为`nullptr`吗？`length()`的实现应该检查`p`是否为`nullptr`吗？
```cpp
// 调用者要确保 p != nullptr
int length(not_null<Record*> p);

// length()的实现必须假设 p == nullptr 是可能的
int length(Record* p);
```

##### 注意
`not_null<T*>`是不为`nullptr`的；`T*`可以为`nullptr`；两者在内存中都可以通过`T*`来表示（因此没有隐含运行时开销）。

##### 注意
`not_null`不仅用于内置指针。它可用于`unique_ptr`，`shared_ptr`，以及其它类似指针的类型。

##### 实施
（简单）在一个函数内，如果一个原始指针在解引用之前没有与`nullptr`进行比较（或者等同的操作），发出警告，建议把它声明为`not_null`。
（简单）在一个函数内，如果一个原始指针有时先与`nullptr`进行比较（或者等同的操作）之后再解引用，有时又没有这么做，发出错误。
（简单）在一个函数内，如果一个`not_null`指针与`nullptr`进行比较，发出警告。

### F.24: 使用`span<T>`或`span_p<T>`来表示半开序列
##### 理由
随便的/不明显的区间是错误的来源。

##### 示例
```cpp
X* find(span<X> r, const X& v);    // 在r中查找v

vector<X> vec;
// ...
auto p = find({vec.begin(), vec.end()}, X{});  // 在vec中查找X{}
```

##### 注意
在C++代码中区间非常常见。通常，它们是隐式的而且很难保证它们被正确使用。特别是，给定一对参数`(p, n)`来表示一个数组`[p:p+n)`，一般不可能知道在`*p`后面是否真的有n个元素。`span<T>`和`span_p<T>`是简单的辅助类型，分别表示一个`[p:q)`区间，以及一个以`p`开头并且以判断式为真的首个元素结尾的区间。

##### 示例
`span`表示一个元素区间，但我们如何操作这个区间的元素？
```cpp
void f(span<int> s)
{
    // 区间遍历（正确性得到保障）
    for (int x : s) cout << x << '\n';

    // C风格遍历（有内在的检查）
    for (gsl::index i = 0; i < s.size(); ++i) cout << s[i] << '\n';

    // 随机访问（有内在的检查）
    s[7] = 9;

    // 提取指针（有内在的检查）
    std::sort(&s[0], &s[s.size() / 2]);
}
```

##### 注意
`span<T>`对象不会拥有的元素，而且它小得可以以值来传递。

传递`span`对象作为参数与传递一对指针参数或者传递一个指针和一个整数个数的效率一样高。

*另见*：支持库

##### 实施
（复杂）当访问一个通过其它整数类型指定边界的指针参数时，发出警告，并且建议他们使用`span`。

### F.25: 使用`zstring`或者`not_null<zstring>`来表示C风格字符串
##### 理由
C风格字符串是普遍存在的。它们通过约定来定义：以零字符结尾的字符数组。我们必须把C风格字符与单个字符的指针或者旧式的字符数组指针区分开来。

##### 示例
考虑以下代码：
```cpp
int length(const char* p);
```
当我调用`length(s)`的时候我应该检查`s`是否为`nullptr`吗？`length()`的实现应该检查`p`是否为`nullptr`吗？
```cpp
// length()的实现必须假设p == nullptr是可能的
int length(zstring p);

// 调用者要保证p != nullptr
int length(not_null<zstring> p);
```

##### 注意
`zstring`不表示所有权。

*另见*：支持库

##### F.26: 在需要使用指针的地方，使用`unique_ptr<T>`来转移所有权
##### 理由
使用`unique_ptr`是安全传递指针最廉价的方式。

*另见*：C.50 考虑什么时候从工厂中返回`shared_ptr`。

##### 示例
```cpp
unique_ptr<Shape> get_shape(istream& is)  // 从输入流中组装形状
{
    auto kind = read_header(is); // 读取头部并且在输入中标识下一个形状
    switch (kind) {
    case kCircle:
        return make_unique<Circle>(is);
    case kTriangle:
        return make_unique<Triangle>(is);
    // ...
    }
}
```

##### 注意
如果你转移的是一个来自类层次结构的对象，并且这个类层次结构被（作为基类）使用在接口中，那么你需要传递一个指针而不是一个对象。

##### 实施
（简单）如果一个函数返回一个局部分配的原始指针，发出警告。建议使用`unique_ptr`或者`shared_ptr`代替。

### F.27: 使用`shared_ptr<T>`共享所有权
##### 理由
使用`shared_ptr`是表示共享所有权的标准方式。也就是说，最后一个所有者删除对象。

##### 示例
```cpp
shared_ptr<const Image> im { read_image(somewhere) };

std::thread t0 {shade, args0, top_left, im};
std::thread t1 {shade, args1, top_right, im};
std::thread t2 {shade, args2, bottom_left, im};
std::thread t3 {shade, args3, bottom_right, im};

// 分离线程
// 最后一个结束的线程删除图像
```

##### 注意
如果在同一时刻从来不会有多于一个的所有者，`unique_ptr`优先于`shared_ptr`。`shared_ptr`用来共享所有权。

注意大量使用的`shared_ptr`会带来开销（在`shared_ptr`引用计数上的原子操作有显著的总体开销）。

##### 替代方案
以一个单一对象持有共享对象（例如，一个作用域范围内的对象），当所有用户都使用完之后删除它（最好是隐式的）。

##### 实施
（不可实施）可靠地检测这个模式太复杂了。

### F.60: 当“无参数”是有效的选项时，优先使用`T*`而不是`T&`
##### 理由
指针（`T*`）可以是`nullptr`而引用（`T&`）不能，不存在有效的“空引用”。有时使用`nullptr`作为一个选择来表示“无对象”是有用的，但如果不是这样，引用从符号表示法上来说更简单而且会产出更好的代码。

##### 示例
```cpp
string zstring_to_string(zstring p) // zstring是char*；即C风格字符串
{
    if (!p) return string{};    // p可能是nullptr；记得检查
    return string{p};
}

void print(const vector<int>& r)
{
    // r引用一个vector<int>；不需要检查
}
```

##### 注意
构造一个本质上是`nullptr`的引用是可能的，但这不是合理的C++（例如，`T* p = nullptr; T& r = (T&)*p`）。这种错误是非常罕见的。

##### 注意
如果你更喜欢指针表示法（`->`和/或`*`对比`.`），`not_null<T*>`提供了与`T&`同样的保证。

##### 实施
* 标记???

### F.42: 返回`T*`来指示位置（只用于这种情况）
##### 理由
这是指针擅长的地方。返回`T*`来转移所有权是一个错误用法。

##### 示例
```cpp
Node* find(Node* t, const string& s)  // 在Node的二叉树上查找s
{
    if (!t || t->name == s) return t;
    if ((auto p = find(t->left, s))) return p;
    if ((auto p = find(t->right, s))) return p;
    return nullptr;
}
```
如果`find`返回的指针不为`nullptr`，它表示一个持有`s`的`Node`。重要的是，它没有隐式地把所指对象的所有权转移给调用者。

##### 注意
位置也可以通过迭代器、索引和引用来传递。如果没有必要使用`nullptr`，或者如果指向的对象不应该改变，引用通常是比指针更好的选择。

##### 注意
不要返回指向不在调用者作用域范围内的东西的指针；参阅F.43。

*另见*：避免悬挂指针的讨论

##### 实施
* 标记作用在纯`T*`上的`delete`、`std::free()`等。只有所有者才应该删除。
* 标记赋值给纯`T*`的`new`、`malloc()`等。只有所有者才负责删除。

##### F.43: 永不（直接或间接）返回指向局部对象的指针或引用
##### 理由
避免由于使用悬挂指针导致的崩溃和数据损坏。

##### 示例，不好的
```cpp
int* f()
{
    int fx = 9;
    return &fx;  // 不好的
}

void g(int* p)   // 看起来足够无辜
{
    int gx;
    cout << "*p == " << *p << '\n';
    *p = 999;
    cout << "gx == " << gx << '\n';
}

void h()
{
    int* p = f();
    int z = *p;  // 从废弃的栈帧上读取（不好的）
    g(p);        // 传递指向废弃栈帧的指针给函数（不好的）
}
```
这里，在一个流行的实现上我得到以下输出：
```
*p == 999
gx == 999
```
我猜测这是因为`g()`的调用重用了`f()`的调用废弃的栈空间，因此`*p`指向的空间现在被`gx`占用了。
* 想像一下如果`fx`和`gx`是不同的类型会怎样。
* 想像一下如果`fx`和`gx`是一个具有不变式的类型会怎样。
* 想像一下如果更多的这种悬挂指针在更大的函数集之间传递会怎样。
* 想像一下骇客会用这个悬挂指针来做什么。
幸运的是，大部分（全部？）现代编译器会捕获并警告这个简单的场景。

##### 注意
这也适用于引用：
```cpp
int& f()
{
    int x = 7;
    // ...
    return x;  // 不好的：返回对即将销毁的对象的引用
}
```

##### 注意
这只适用于非`static`的局部变量。所有`static`变量都是静态分配的（正如它们的名称所示），因此指向它们的指针不会变成悬挂。

##### 示例，不好的
并非所有泄露指向局部变量的指针的案例都是那么明显：
```cpp
int* glob;       // 全局变量在许多方面都是不好的

template<class T>
void steal(T x)
{
    glob = x();  // 不好的
}

void f()
{
    int i = 99;
    steal([&] { return &i; });
}

int main()
{
    f();
    cout << *glob << '\n';
}
```
这里，我设法读取被`f`的调用废弃的位置。储存在`glob`中的指针可能很晚才使用，并且以不可预知的方式造成麻烦。

##### 注意
局部变量的地址可以被这些方式“返回”/泄露：通过返回语句，通过一个`T&`输出参数，作为一个返回对象的成员，作为一个返回数组的元素，以及更多的方式。

##### 注意
从一个内部作用域“泄露”指针到外部作用域的类似例子可以被构造出来；这些例子与泄露指针到函数外部同等看待。

这个问题的一个稍微不同的变体是，把一个指针放到容器中，而这个容器的生命周期比指针指向的对象更长。

*另见*：获得悬挂指针的另一个方法是指针无效化。它可以用类似的技术来检测/防御。

##### 实施
* 编译器一般会捕捉到返回指向局部变量的引用，而且可以在许多情况下捕捉到返回指向局部变量的指针。
* 静态分析可以捕捉许多常见的使用指针表示位置的模式（因此可以避免悬挂指针）。

### F.44: 当不希望拷贝以及不需要“返回无对象”时，返回`T&`
##### 理由
语言保证了`T&`指向一个对象，因此检测`nullptr`是没有必要的。

*另见*：引用的返回必须不能隐含所有权的转移：预防悬挂指针的讨论以及所有权的讨论。

##### 示例
```cpp
class Car
{
    array<wheel, 4> w;
    // ...
public:
    wheel& get_wheel(int i) { Expects(i < w.size()); return w[i]; }
    // ...
};

void use()
{
    Car c;
    wheel& w0 = c.get_wheel(0); // w0拥有与c一样的生命周期
}
```

### F.45: 不要返回`T&&`
##### 理由
这是在要求返回一个指向已销毁的临时对象的引用。`&&`是用于临时对象的磁铁。当对临时对象的引用被“向下”传递给被调用者时，这是可以的，因为临时对象的生命周期保证比函数调用长（参阅F.18和F.19）。然而，当“向上”传递这样的引用给更大的调用者作用域时，这是不可以的。另见???。

对于（通过普通引用或者通过完美转发）传入参数的透传函数，如果想要返回值，使用简单的`auto`返回类型推导（不是`auto&&`）。

##### 示例，不好的
如果`F`以值返回，这个函数返回一个指向临时对象的引用。
```cpp
template<class F>
auto&& wrapper(F f)
{
    log_call(typeid(f)); // 或者其它任何指令
    return f();
}
```

##### 示例，好的
好多了：
```cpp
template<class F>
auto wrapper(F f)
{
    log_call(typeid(f)); // 或者其它任何指令
    return f();
}
```

##### 例外
`std::move`和`std::forward`的确返回`&&`，但它们只是转型——只在特定的表达式上下文中按照惯例来使用：当一个指向临时对象的引用在该临时对象销毁之前与同一个表达式一起传递。我们不知道任何其它返回`&&`的好例子。

##### 实施
标记任何使用`&&`作为返回类型的情况，除了`std::move`和`std::forward`。

### F.46: `int`是`maint()`的返回类型
##### 理由
这是语言规则，但经常被“语言扩展”违反，所以值得一提。把`main`（程序唯一全局的`main`）声明为`void`限制了可移植性。

##### 示例
```cpp
void main() { /* ... */ };  // 不好的，不是C++

int main()
{
    std::cout << "This is the way to do it\n";
}
```

##### 注意
我们提及这个只是因为这个错误在社区中一直存在。

##### 实施
* 编译器应该这么做
* 如果编译器不这样做，让工具标记它

### F.47: 在赋值操作符中返回`T&`
##### 理由
操作符重载（特别是对于值类型）的一个约定是，让`operation=(const T&)`执行赋值并且返回（非`const`）`*this`。这保证了与标准库的类型保持一致，并遵循“像整数一样运作”的原则。

##### 注意
历史上有一些指导让赋值操作符返回`const T&`。这主要是为了避免`(a = b) = c`形式的代码——这类代码不够常见，不足以证明违反与标准类型的一致性是正确的。

##### 示例
```cpp
class Foo
{
 public:
    ...
    Foo& operator=(const Foo& rhs) {
      // 拷贝成员。
      ...
      return *this;
    }
};
```

##### 实施
这应该由工具通过检查任何赋值操作符的返回类型（和返回值）来实施。

### F.50: 在函数不能达到目的的时候使用lambda（捕捉局部变量，或者写一个局部函数）
##### 理由
函数不能捕捉局部变量或者声明在局部作用域中；如果你需要这些东西，可能的话优先使用lambda，否则手写一个函数对象。另一方面，lambda和函数对象不会重载；如果你需要重载，优先使用函数（使lambda可重载的变通方法是奢华的）。如果两者都可用，优先写一个函数；使用所需的最简单工具。

##### 示例
```cpp
// 写一个只应该接受一个整数或者一个字符串的函数——重载是自然的
void f(int);
void f(const string&);

// 写一个需要捕捉局部状态以及出现在语句或者表达式作用域的函数对象
// ——lambda是自然的
vector<work> v = lots_of_work();
for (int tasknum = 0; tasknum < max; ++tasknum) {
    pool.run([=, &v]{
        /*
        ...
        ... 处理v的第 1 / max 个元素，tasknum - 第几块
        ...
        */
    });
}
pool.join();
```

##### 例外
泛型lambda提供了简洁的方式来写函数模板，因此它是有用的，即使在一个普通函数模板用更多的语法来做得同样好的情况下。一旦所有函数都获得了拥有概念参数的能力，这个优势在将来可能会消失。

##### 实施
* 对于具名的非泛型lambda（例如，`auto x = [](int i) { /*...*/; };`），如果它没有捕获东西并且出现在全局作用域，发出警告。写一个普通的函数来代替。

### F.51: 在可以选择的时候，优先使用默认参数而不是重载
##### 理由
默认参数简单地为一个单一的实现提供了另一个接口。没有办法保证一组重载函数全部都实现了相同的语义。使用默认参数可以避免代码重复。

##### 注意
 只有当另外的接口来自相同类型的参数集合时，在默认参数和重载之间才有选择。例如：
```cpp
void print(const string& s, format f = {});
```
而不是
```cpp
void print(const string& s);  // 使用默认格式
void print(const string& s, format f);
```
当一组函数用来对一组类型做相同语义的操作时，是没有选择的。例如：
```cpp
void print(const char&);
void print(int);
void print(zstring);
```

##### 另见
虚函数的默认参数

##### 实施
???

### F.52: 在局部使用的lambda中，优先以引用来捕获变量，包括传递给算法
##### 理由
为了效率和正确性，你几乎总是想在局部使用lambda的时候以引用来捕获变量。这包括了写或者调用局部的并行算法，因为它们会在返回之前接合。

##### 讨论
效率的考虑基于大部分类型以引用传递比以值传递更廉价。

正确性的考虑基于许多调用想在调用侧在原始对象上执行副作用（参考下面的示例）。以值传递阻止了这种做法。

##### 注意
不幸的是，没有简单的方式以`const`引用捕捉变量来获得局部调用的效率，同时阻止副作用。

##### 示例
这里，一个大型对象（一个网络消息）被传递给一个迭代算法，拷贝这个消息是否不高效或者不正确（它可能不能拷贝）呢：
```cpp
std::for_each(begin(sockets), end(sockets), [&message](auto& socket)
{
    socket.send(message);
});
```

##### 示例
这是一个简单的三阶并行管道。每个`stage`对象封装了一个工作线程和一个队列，有一个`process`函数来让工作进队列，并且在它的析构函数中，在结束线程之前自动阻塞等待队列变空。
```cpp
void send_packets(buffers& bufs)
{
    stage encryptor([] (buffer& b){ encrypt(b); });
    stage compressor([&](buffer& b){ compress(b); encryptor.process(b); });
    stage decorator([&](buffer& b){ decorate(b); compressor.process(b); });
    for (auto& b : bufs) { decorator.process(b); }
}  // 自动阻塞等待管道完成
```

### F.53: 在非局部使用的lambda中，避免以引用来捕获变量，包括返回，在堆中存储，或者传递给其它线程
##### 理由
指向局部变量的指针和引用的生命周期不应该超过它们所在的作用域。以引用捕获变量的lambda只是另一个地方来保存指向局部对象的引用，如果它们（或者它们的拷贝）的生命周期比作用域长，就不应该这样做。

##### 示例，不好的
```cpp
int local = 42;

// 想要一个指向局部变量的引用。
// 注意，在程序退出了这个作用域之后，local不再存在，
// 因此process()的调用将会有未定义的行为！
thread_pool.queue_work([&]{ process(local); });
```

##### 示例，好的
```cpp
int local = 42;
// 想要一个local的拷贝。
// 由于拷贝了local，这个调用总是可行的。
thread_pool.queue_work([=]{ process(local); });
```

##### 实施
* （简单）当捕获列表包含指向局部声明变量的引用时，发出警告
* （复杂）当捕获列表包含指向局部声明变量的引用，并且这个lambda被传递给一个非`const`和非局部的上下文时，进行标记

## F.54: 如果你捕获了`this`，显式地捕获所有变量（非默认捕获）
##### 理由
这是令人困惑的。在一个成员函数中写`[=]`看起来是以值来捕获，但实际上是以引用捕获数据成员，因为它实际上以值捕获了不可见的`this`指针。如果你意图那样做，显式地写`this`。

##### 示例
```cpp
class My_class {
    int x = 0;
    // ...

    void f() {
        int i = 0;
        // ...

        auto lambda = [=]{ use(i, x); };   // 不好的：“看起来”是以拷贝/值来捕获的
        // [&]有同等的语义并且在当前的准则下复制this指针
        // [=,this]和[&,this]并没有好多少，而且同样令人困惑

        x = 42;
        lambda(); // 调用use(0, 42);
        x = 43;
        lambda(); // 调用use(0, 43);

        // ...

        auto lambda2 = [i, this]{ use(i, x); }; // 好的，最清晰并且最少困惑

        // ...
    }
};
```

##### 注意
在标准化过程中，这个问题被积极地讨论，而且在未来的标准版本中，可能会通过添加新的捕获模式或者调整`[=]`的含义来解决。目前，只要让它保持清晰即可。

##### 实施
* 标记出任何指定了默认捕获并且同时捕获了`this`（不论是显式的或者通过默认捕获的）的lambda捕获列表。

### F.55: 不要使用`va_arg`参数
##### 理由
从`va_arg`读取假定了实际传递的是正确的类型。传递给可变参数假定了会以正确的类型来读取。这是脆弱的，因为在语言中它通常不能保证是安全的，并且依赖于程序员的自律来让它正确执行。

##### 示例
```cpp
int sum(...) {
    // ...
    while (/*...*/)
        result += va_arg(list, int); // 不好的，假设了它传递的是int
    // ...
}

sum(3, 2); // 正确
sum(3.14159, 2.71828); // 坏了，未定义行为

template<class ...Args>
auto sum(Args... args) { // 好的，而且更加灵活
    return (... + args); // 注意：C++17的“折叠表达式”
}

sum(3, 2); // 正确：5
sum(3.14159, 2.71828); // 正确：~5.85987
```

##### 替代方案
* 重载
* 可变参数模板
* `variant`参数
* `initializer_list`（同类的方法）

##### 注意
对于那些不会使用传进来的实参的技术，声明一个`...`参数有时候是有用的，尤其是声明“接受任何东西”的函数，从而在重载集合中禁用“其它所有东西”，或者在模板元程序中表达一个捕获所有东西的情况。

##### 实施
* 对于使用了`va_list`、`va_start`或者`va_arg`的情况，发出诊断报告。
* 如果传递一个参数给一个函数的可变参数，并且该函数在可变参数的位置没有提供一个更具体类型的重载，发出诊断报告。修复方法：使用一个不同的函数，或者`[[suppress(types)]]`。

## C: 类与类层次结构
类是一个用户定义类型，程序员可以用它来定义表示，操作和接口。类层次结构用来组织相关的类到分层的结构中。

类准则概要：
* C.1: 把相关的数据组织到结构中（`struct`或者`class`）
* C.2: 如果类有不变式，使用`class`；如果数据成员可以独立地变化，使用`struct`
* C.3: 使用类来表示接口和实现之间的差异
* C.4: 只有在需要直接访问类的表示时才把函数定义成成员
* C.5: 把辅助函数放在与它们所支持的类的同一个名称空间内
* C.7: 不要在同一个语句中定义类或枚举并且声明这个类型的变量
* C.8: 如果有任一成员是非公有的，使用`class`而不是`struct`
* C.9: 暴露最少的成员

小节：
* C.concrete: 具体类型
* C.ctor: 构造函数，赋值，和析构函数
* C.con: 容器和其它资源句柄
* C.lambdas: 函数对象和lambda
* C.hier: 类层次结构（OOP）
* C.over: 重载和重载操作符
* C.union: 联合

### C.1: 把相关的数据组织到结构中（`struct`或者`class`）
##### 理由
容易理解。如果数据是相关的（出于根本原因），这个事实应该在代码中反映出来。

##### 示例
```cpp
void draw(int x, int y, int x2, int y2);  // 不好的：不必要的隐式关系
void draw(Point from, Point to);          // 好多了
```

##### 注意
没有虚函数的简单类意味着没有空间或时间开销。

##### 注意
从语言来看，`class`和`struct`只在它们成员的默认可视性上有不同。

##### 实施
也许是不可能的。也许启发式地查找一起使用的数据项是可能的。

### C.2: 如果类有不变式，使用`class`；如果数据成员可以独立地变化，使用`struct`
##### 理由
可读性。容易理解。使用`class`提醒程序员不变式的需要。这是一个有用的约定。

##### 注意
不变式是对一个对象的成员的逻辑条件，必须由构造函数来建立，并且由公有成员函数来承担。在不变式建立之后（一般通过构造函数），可以调用对象的每个成员函数。不变式可以非正式地声明（例如，在注释中）或者更正式地使用`Expects`。

如果所有数据成员可以彼此独立地变化，没有不变式是可能的。

##### 示例
```cpp
struct Pair {  // 成员可以独立地变化
    string name;
    int volume;
};
```
但是：
```cpp
class Date {
public:
    // 验证 {yy, mm, dd} 是有效的日期并且初始化
    Date(int yy, Month mm, char dd);
    // ...
private:
    int y;
    Month m;
    char d;    // 天
};
```

##### 注意
如果一个类有任意`private`数据，用户不能在不使用构造函数的情况下完全初始化一个对象。因此，类的定义者要提供一个构造函数并且必须指定它的含义。这实际上意味着定义者需要定义一个不变式。

*另见*：
* 用`class`定义具有私有数据的类
* 优先把类中的接口放在首位
* 暴露最少的成员
* 避免`protected`数据

##### 实施
查找所有数据都是私有的`struct`，以及具有公有成员的`class`。

### C.3: 使用类来区分接口和实现
##### 理由
明显地区分接口和实现可以提高可读性和简化维护。

##### 示例
```cpp
class Date {
    // ... 一些表示 ...
public:
    Date();
    // 验证{yy, mm, dd}是有效的日期并且初始化
    Date(int yy, Month mm, char dd);

    int day() const;
    Month month() const;
    // ...
};
```
如上所示，我们现在可以改变`Date`的表示而不影响到它的用户（尽管很可能要重新编译）。

##### 注意
使用类以这种方式来区分接口和实现当然不是唯一的方法。例如，我们可以使用在一个名称空间中声明的独立函数集合，抽象基类，或者带有概念来表示接口的模板函数。最重要的事情是要明显地区分一个接口和它的实现“细节”。理想的同时也是典型的情况下，一个接口远比它的实现更稳定。

##### 实施
???

### C.4: 只有在需要直接访问类的表示时才把函数定义成成员
##### 理由
比成员函数具有更少的关联，有更少会修改对象状态而导致问题的函数，减少在改变表示之后需要修改的函数数量。

##### 示例
```cpp
class Date {
    // ... 相关的小接口 ...
};

// 辅助函数
Date next_weekday(Date);
bool operator==(Date, Date);
```
“辅助函数”不需要直接访问`Date`的表示。

##### 注意
如果C++有了“统一函数调用”，这个准则会变得更好。

##### 例外
语言需要`virtual`函数是成员，而且并不是所有`virtual`函数都直接访问数据。特别是，抽象类的成员很少这样做。

注意多重方法。

##### 例外
语言要求操作符`=`、`()`、`[]`和`->`为成员。

##### 例外
一个重载集合中可能有些成员不会直接访问`private`数据：
```cpp
class Foobar {
public:
    void foo(long x)    { /* 维护私有数据 */ }
    void foo(double x) { foo(std::lround(x)); }
    // ...
private:
    // ...
};
```
类似的，一系列函数可能设计来用在链中：
```cpp
x.scale(0.5).rotate(45).set_color(Color::red);
```
一般情况下，部分但不是所有这些函数会直接访问`private`数据。

##### 实施
* 查找不会直接接触数据成员的非`virtual`函数。这里的障碍是，许多不需要直接接触数据成员的成员函数会这么做。
* 忽略`virtual`函数。
* 忽略作为重载集合一部分的函数，其中至少有一个函数访问了私有成员。
* 忽略返回`this`的函数。

### C.5: 把辅助函数放在与它们所支持的类的同一个名称空间内
##### 理由
辅助函数是不需要直接访问类的表示的函数（通常由类的作者提供），甚至可以看成是类的有用接口的一部分。把它们跟类放在同一个名称空间使得它们与类的关系更明显，并且允许它们可以被参数依赖查找找到。

##### 示例
```cpp
namespace Chrono { // 这里我们存放了时间相关的服务

    class Time { /* ... */ };
    class Date { /* ... */ };

    // 辅助函数
    bool operator==(Date, Date);
    Date next_weekday(Date);
    // ...
}
```

##### 注意
这对于重载操作来说特别重要。

##### 实施
* 标记出那些接收来自单个名称空间的参数类型的全局函数。

### C.7: 不要在同一个语句中定义类或枚举并且声明这个类型的变量
##### 理由
在同一个声明中混合类型定义和另一个实体的定义令人困惑并且没有必要。

##### 示例；不好的
```cpp
struct Data { /*...*/ } data{ /*...*/ };
```

##### 示例；好的
```cpp
struct Data { /*...*/ };
Data data{ /*...*/ };
```

##### 实施
如果类或枚举定义的`}`后面没有跟着`;`，标记出来。`;`缺失了。

### C.8: 如果有任一成员是非公有的，使用`class`而不是`struct`
##### 理由
可读性。清楚地表明有些东西被隐藏/被抽象了。这是一个有用的约定。

##### 示例，不好的
```cpp
struct Date {
    int d, m;

    Date(int i, Month m);
    // ... 许多函数 ...
private:
    int y;  // 年
};
```
就C++语言规则所关注的而言，这个代码没有错误。但从设计的观点来看几乎所有东西都是错的。私有数据隐藏在远离公有数据的地方。数据分割在类定义的不同部分。数据的不同部分有不同的访问权限。所有这些降低了可读性并且使维护复杂化。

##### 注意
优先把接口放在类的首位，参阅NL.16。

##### 实施
标记出定义成`struct`并且有`private`或`protected`成员的类。

### C.9: 暴露最少的成员
##### 理由
封装。信息隐藏。最小化意外访问的机会。这可以简化维护。

##### 示例
```cpp
template<typename T, typename U>
struct pair {
    T a;
    U b;
    // ...
};
```
不论我们在`//`部分做什么，`pair`的任意用户可以任意和独立地改变它的`a`和`b`。在大型的代码库中，我们不能简单地找到哪些代码对`pair`的成员做了什么事情。这可能的确是我们想要的，但如果我们想保证成员之间的关系，我们需要把它们声明成`private`并且通过构造函数和成员函数保证这个关系（不变式）。例如：
```cpp
class Distance {
public:
    // ...
    double meters() const { return magnitude*unit; }
    void set_unit(double u)
    {
            // ... 检查u是10的因子 ...
            // ... 适当地修改数量 ...
            unit = u;
    }
    // ...
private:
    double magnitude;
    double unit;    // 1是米，1000是千米，0.001是毫米，等等。
};
```

##### 注意
如果一组变量的直接用户不能简单地确定，它们的类型或者用法就不能（简单地）改变/提升。对于`public`和`protected`数据，这是常见的情况。

##### 示例
一个类提供了两部分接口给它的用户。一部分提供给派生类（`protected`），一部分提供给普通用户（`public`）。例如，派生类可能允许跳过一个运行时检查因为它已经保证了正确性：
```cpp
class Foo {
public:
    int bar(int x) { check(x); return do_bar(x); }
    // ...
protected:
    int do_bar(int x); // 在数据上做一些操作
    // ...
private:
    // ... 数据 ...
};

class Dir : public Foo {
    //...
    int mem(int x, int y)
    {
        /* ... 做些事情 ... */
        return do_bar(x + y); // 没问题：派生类可以绕过检查
    }
};

void user(Foo& x)
{
    int r1 = x.bar(1);      // 没问题，会检查
    int r2 = x.do_bar(2);   // 错误：会绕过检查
    // ...
}
```

##### 注意
`protected`数据是不好的想法。

##### 注意
优先以`public`成员，`protected`成员，`private`成员的顺序排列。参阅这里。

##### 实施
* 标记出受保护数据。
* 标记出`public`和`private`数据的混合体。

## C.concrete: 具体类型
关于类的一个观点是定义成常规类型。这大概的意思是“表现地像一个`int`”。具体类型是一种最简单的类。常规类型的值可以被拷贝，并且拷贝的结果是一个与原始对象有相同值的独立对象。如果一个具体类型同时有`=`和`==`，`a = b`应该会使`a == b`的结果为`true`。也可以定义没有赋值和相等操作的具体类型，但这是非常罕见的（也应该如此）。C++内置类型是常规的，因此标准库的类也是如此，例如`string`，`vector`和`map`。具体类型通常也称为值类型，以将它们与作为类层次结构一部分使用的类型区分开来。

具体类型准则概要：
* C.10: 优先使用具体类型而不是类层次结构
* C.11: 使具体类型是常规的

### C.10: 优先使用具体类型而不是类层次结构
##### 理由
具体类型从根本上比层次结构更简单：更容易设计，更容易实现，更容易使用，更容易解释，更小，以及更快。你需要一个使用层次结构的理由（使用场景）。

##### 示例
```cpp
class Point1 {
    int x, y;
    // ... 操作 ...
    // ... 没有虚函数 ...
};

class Point2 {
    int x, y;
    // ... 操作，一些虚函数 ...
    virtual ~Point2();
};

void use()
{
    Point1 p11 {1, 2};   // 在栈上创建一个对象
    Point1 p12 {p11};    // 一个拷贝

    auto p21 = make_unique<Point2>(1, 2);   // 在自由存储上创建一个对象
    auto p22 = p21.clone();                 // 创建一个拷贝
    // ...
}
```
如果一个类是层次结构的一部分，我们必须通过指针或者引用来操作它的对象（如果在小例子中没有必要的话，那么在真实的代码中）。这意味着更多内存开销，更多分配和释放，以及更多运行时开销来执行间接访问的结果。

##### 注意
具体类型可以在栈上分配，并且作为其它类的成员。

##### 注意
间接访问的使用是运行时多态接口的基础。而分配/释放的开销并不是（那只是最常见的情况）。我们可以使用基类作为某个派生类作用域对象的接口。当动态分配被禁止时（例如，硬实时），是可以这样做的，并且这为某些种类的插件提供了稳定的接口。

##### 实施
???

### C.11: 使具体类型是常规的
##### 理由
常规类型比非常规类型更容易理解和解释（不规则的类型需要更多的努力去理解和使用）。

##### 示例
```cpp
struct Bundle {
    string name;
    vector<Record> vr;
};

bool operator==(const Bundle& a, const Bundle& b)
{
    return a.name == b.name && a.vr == b.vr;
}

Bundle b1 { "my bundle", {r1, r2, r3}};
Bundle b2 = b1;
if (!(b1 == b2)) error("impossible!");
b2.name = "the other bundle";
if (b1 == b2) error("No!");
```
特别是，如果具体类型有一个赋值操作，那么要同时给它一个相等操作符，因而`a = b`暗含了`a == b`。

##### 实施
???

## C.ctor: 构造函数，赋值操作符，以及析构函数
这些函数控制了对象的生命周期：创建，拷贝，移动和析构。定义构造函数来保证和简化类的初始化。

这些是默认的操作：
* 默认构造函数：`X()`
* 拷贝构造函数：`X(const X&)`
* 拷贝赋值操作符：`operator=(const X&)`
* 移动构造函数：`X(X&&)`
* 移动赋值操作符：`operator=(X&&)`
* 析构函数：`~X()`

默认情况下，编译器会在每一个操作被使用的时候定义它们，但这个默认行为可以被抑制。

这些默认操作是一组有关联的操作，它们共同实现了一个对象的声明周期语义。默认情况下，C++将类视为像值一样的类型，但并非所有类型都像值一样。

默认操作准则合集：
* C.20: 如果你可以避免定义任何默认操作，那么就这么做
* C.21: 如果你定义或者用`=delete`删除任何默认操作，那么同样定义或者用`=delete`删除全部默认操作
* C.22: 使默认操作保持一致

析构函数准则：
* C.30: 如果类需要在对象销毁的时候执行显式的行为，定义析构函数
* C.31: 类获取的所有资源必须由类的析构函数释放
* C.32: 如果类拥有原始指针（`T*`）或引用（`T&`），要考虑它们是否可能是类自身所有
* C.33: 如果类拥有一个自己所有的指针成员，定义或者用`=delete`删除析构函数
* C.35: 拥有虚函数的基类需要虚析构函数
* C.36: 析构函数不能失败
* C.37: 使析构函数为`noexcept`

构造函数准则：
* C.40: 如果类有不变式，定义构造函数。
* C.41: 构造函数应该创建完全初始化的对象
* C.42: 如果构造函数不能构造有效的对象，抛出异常
* C.43: 保证可拷贝（值类型）的类有默认构造函数
* C.44: 优先使默认构造函数简单并且不会抛出异常
* C.45: 不要定义只初始化数据成员的默认构造函数；使用成员初始化器代替
* C.46: 默认情况下，把单个参数的构造函数声明为`explicit`
* C.47: 根据成员声明的顺序来定义和初始化成员变量
* C.48: 优先在构造函数中对成员初始化器使用类内初始化器，而不是常量初始化器
* C.49: 优先在构造函数中使用初始化而不是赋值
* C.50: 如果你在初始化过程中需要“虚拟行为”，使用工厂函数
* C.51: 使用委托构造函数来表示类的所有构造函数的公共行为
* C.52: 使用继承构造函数把构造函数导入不需要进一步显式初始化的派生类

拷贝和移动准则：
* C.60: 使拷贝赋值操作符非`virtual`，以`const&`接收参数，并且以非`const&`返回
* C.61: 拷贝操作应该拷贝
* C.62: 使拷贝赋值操作符对于自我赋值是安全的
* C.63: 使移动赋值操作符非`virtual`，以`&&`接收参数，并且以非`const&`返回
* C.64: 移动操作应该移动并且让它的来源处于有效的状态
* C.65: 使移动赋值操作符对于自我赋值是安全的
* C.66: 使移动操作为`noexcept`
* C.67: 如果希望拥有“拷贝行为”，基类应该阻止拷贝，并且提供一个虚拟的`clone`来代替

其它默认操作准则：
* C.80: 如果你必须显式说明要使用默认语义，使用`=default`
* C.81: 当你想要禁用默认行为（又不想要其它替代方案）时，使用`=delete`
* C.82: 不要在构造函数和析构函数中调用虚函数
* C.83: 对于值类型，考虑提供一个`noexcept`交换函数
* C.84: `swap`不能失败
* C.85: 使`swap`为`noexcept`
* C.86: 使`==`的操作数类型对称，并且为`noexcept`
* C.87: 注意基类的`==`
* C.89: 使`hash`为`noexcept`

## C.defop: 默认操作
默认情况下，语言提供了具有默认语义的默认操作。当然，程序员可以禁止或者替换这些默认操作。

### C.20: 如果你可以避免定义默认操作，那么就这么做
##### 理由
这是最简单的，并且提供了最干净的语义。

##### 示例
```cpp
struct Named_map {
public:
    // ... 没有声明默认操作 ...
private:
    string name;
    map<int, int> rep;
};

Named_map nm;        // 默认构造
Named_map nm2 {nm};  // 拷贝构造
```
由于`std::map`和`string`有了所有特定的函数，因此不需要更多的工作。

##### 注意
这称为“零准则”。

##### 实施
（不可实施）虽然不可实施，但一个好的静态分析器可以检测出那些指出可能的改善的模式来满足这个准则。例如，在类中拥有一对（指针，大小）的成员，并且在析构函数中用`delete`删除指针，这种情况很可能可以转换成使用`vector`。

### C.21: 如果你定义或者用`=delete`删除任何默认操作，那么同样定义或者用`=delete`删除全部默认操作
##### 理由
特殊的成员函数是默认构造函数，拷贝构造函数，拷贝赋值操作符，移动构造函数，移动赋值操作符，以及析构函数。

这些特殊函数的语义是紧密相关的，因此如果需要声明其中一个，那么很可能其它的也需要考虑一下。

声明任意特殊的成员函数，除了默认构造函数之外，即使只是声明为`=default`或`=delete`，也会阻止移动构造函数和移动赋值操作符的隐式声明。声明移动构造函数或者移动赋值操作符，即使只是声明为`=default`或`=delete`，也会导致隐式生成的拷贝构造函数或隐式生成的拷贝赋值操作符被定义成已删除。因此一旦声明了任意特殊函数，其它的也应该声明，以防出现不想要的结果，例如所有潜在的移动转变成了昂贵的拷贝，或者使得类只能移动。

##### 示例，不好的
```cpp
struct M2 {   // 不好：不完整的默认操作
public:
    // ...
    // ... 没有拷贝或移动操作 ...
    ~M2() { delete[] rep; }
private:
    pair<int, int>* rep;  // zero-terminated set of pairs
};

void use()
{
    M2 x;
    M2 y;
    // ...
    x = y;   // 默认赋值
    // ...
}
```
上面的析构函数需要“特别注意”（在这里用来释放），在这个情况下拷贝和移动赋值（两者都会隐式地删除对象）正确的可能性很低（在这里我们会遇到双重删除）。

##### 注意
这称为“五准则”或者“六准则”，取决于你是否把默认构造函数计算在内。

##### 注意
如果你想要一个默认操作的默认实现（同时定义了其它操作），写上`=default`来表示你是有意对这个函数这么做的。如果你不想要一个默认操作，用`=delete`来阻止它。

##### 示例，好的
当仅仅为了使析构函数为`virtual`而声明它的时候，它可以被定义成默认的。为了避免阻止隐式的移动操作，它们也必须声明，然后为了避免类变成只能移动（并且不可拷贝），拷贝操作也必须声明：
```cpp
class AbstractBase {
public:
  virtual ~AbstractBase() = default;
  AbstractBase(const AbstractBase&) = default;
  AbstractBase& operator=(const AbstractBase&) = default;
  AbstractBase(AbstractBase&&) = default;
  AbstractBase& operator=(AbstractBase&&) = default;
};
```
另外，为了避免C.67提到的对象切割，拷贝和移动操作可以全部删除：
```cpp
class ClonableBase {
public:
  virtual unique_ptr<ClonableBase> clone() const;
  virtual ~ClonableBase() = default;
  ClonableBase(const ClonableBase&) = delete;
  ClonableBase& operator=(const ClonableBase&) = delete;
  ClonableBase(ClonableBase&&) = delete;
  ClonableBase& operator=(ClonableBase&&) = delete;
};
```
只定义移动操作或者拷贝操作在这里会有同样的效果，但是显式地为每个特殊成员说明意图会让它对读者更加明显。

##### 注意
编译器实施了该准则的大部分，而且可以理想地对任何违规进行警告。

##### 注意
在拥有析构函数的类中依赖隐式生成的拷贝操作是已废弃的。

##### 实施
（简单）类应该对全部特殊函数都有声明（甚至是`=delete`的声明），或者全部都不声明。

### C.22: 使默认操作保持一致
##### 理由
从概念上，默认操作是匹配的组合。它们的语义是相互关联的。如果拷贝/移动构造和拷贝/移动赋值执行了不同的逻辑操作，用户会感到惊讶。如果构造函数和析构函数没有提供一致的资源管理视图，用户会感到惊讶。如果拷贝和移动没有反映出构造函数和析构函数的工作方式，用户会感到惊讶。

##### 示例，不好的
```cpp
class Silly {   // 不好的：不一致的拷贝操作
    class Impl {
        // ...
    };
    shared_ptr<Impl> p;
public:
    Silly(const Silly& a) : p{a.p} { *p = *a.p; }   // 深拷贝
    Silly& operator=(const Silly& a) { p = a.p; }   // 浅拷贝
    // ...
};
```
这些操作与拷贝语义不一致。这会导致困惑和缺陷。

##### 实施
* （复杂）拷贝/移动构造函数和对应的拷贝/移动赋值操作符应该在相同级别的解引用上写入同一个成员变量。
* （复杂）任何在拷贝/移动构造函数中写入的成员变量应该也要在所有其它构造函数中初始化。
* （复杂）如果拷贝/移动构造函数执行了一个成员变量的深拷贝，那么析构函数应该修改这个成员变量。
* （复杂）如果析构函数修改了一个成员变量，这个成员变量应该在任意拷贝/移动构造函数或者赋值操作符中写入。

## C.dtor: 析构函数
“这个类需要析构函数吗？”是一个令人惊讶的强大的设计问题。对于大部分类来说答案是“不”，不仅因为类没有持有资源，而且因为析构函数被零准则处理了；也就是说，它的成员可以照管它们自己作为关注的析构。如果答案是“是”，类的许多设计如下（参阅五准则）。

### C.30: 如果类需要在对象销毁的时候执行显式的行为，定义析构函数
##### 理由
析构函数会在对象生命周期结束时隐式调用。如果默认析构函数已经足够，那么使用它。只有在类需要执行的代码不属于其成员的析构函数的一部分时，才定义非默认的析构函数。

##### 示例
```cpp
template<typename A>
struct final_action {   // 稍微做了简化
    A act;
    final_action(A a) :act{a} {}
    ~final_action() { act(); }
};

template<typename A>
final_action<A> finally(A act)   // 推导action的类型
{
    return final_action<A>{act};
}

void test()
{
    auto act = finally([]{ cout << "Exit test\n"; });  // 建立退出的action
    // ...
    if (something) return;   // act在这里执行
    // ...
} // act在这里执行
```
`final_action`的全部目的是让代码片段（通常是lambda）在析构的时候执行。

##### 注意
有两种普遍的类需要用户定义的析构函数：
* 一种是拥有资源的类，这些资源还未以具有析构函数的类，例如`vector`或者事务类来表示。
* 一种是主要用来在析构时执行行为的类，例如追踪器或者`final_action`。

##### 示例，不好的
```cpp
class Foo {   // 不好的；应使用默认析构函数
public:
    // ...
    ~Foo() { s = ""; i = 0; vi.clear(); }  // 清理
private:
    string s;
    int i;
    vector<int> vi;
};
```
默认析构函数做得更好，更高效，并且不会出错。

##### 注意
如果需要使用默认析构函数，但是它被阻止生成（例如，通过定义移动构造函数），那么使用`=default`。

##### 实施
查找可能的“隐式资源”，例如指针和引用。查找即使所有数据成员都有析构函数，但其仍然带有析构函数的类。

### C.31: 类获取的所有资源必须由类的析构函数释放
##### 理由
防止资源泄露，特别是在出错的情况下。

##### 注意
对于那些用带有完整默认操作的类表示的资源，这是自动执行的。

##### 示例
```cpp
class X {
    ifstream f;   // 可能拥有一个文件
    // ... 没有定义默认操作或者=delete ...
};
```
`X`的`ifstream`会在`X`的析构函数执行时隐式地关闭任何已打开的文件。

##### 示例，不好的
```cpp
class X2 {     // 不好的
    FILE* f;   // 可能拥有一个文件
    // ... 没有定义默认操作或者=delete ...
};
```
X2可能会泄露一个文件句柄。

##### 注意
一个不能关闭的套接字会怎样？析构函数，关闭或者清理操作应该永不失败。然而，如果它确实发生了，我们就遇到一个没有真正好的解决方法的问题。对于初学者，析构函数的作者不知道为什么析构函数会被调用，并且不能通过抛出异常来“拒绝执行”。参阅这个讨论。使这个问题更糟糕的是，许多“关闭/释放”操作是不可重试的。许多人尝试去解决这个问题，但没有已知的普遍的解决方法。如果可能的话，考虑将关闭/释放的错误视为基本的设计错误，并且终止程序。

##### 注意
类可能持有指向不属于它的对象的指针和引用。显然，这些对象不应该被类的析构函数用`delete`删除。例如：
```cpp
Preprocessor pp { /* ... */ };
Parser p { pp, /* ... */ };
Type_checker tc { p, /* ... */ };
```
这里`p`引用了`pp`，但并没有拥有它。

##### 实施
* （简单）如果拥有指针或引用成员变量的类是所有者（例如，通过使用`gsl::owner`被视为所有者），那么这些变量应该在类的析构函数中有所引用。
* （困难）在没有显式声明所有权的时候，确定指针或者引用成员变量是否所有者（例如，查看构造函数）。

### C.32: 如果类拥有原始指针（`T*`）或引用（`T&`），要考虑它们是否可能是类自身所有
##### 理由
有许多代码没有明确说明所有权。

##### 示例
```cpp
???
```

##### 注意
如果`T*`或者`T&`是类所有的，用`owning`标记它。如果`T*`不是类所有，考虑用`ptr`标记它。这会有助于文档和分析。

##### 实施
查看原始成员指针和成员引用的初始化，看是否使用了分配。

### C.33: 如果类拥有一个自己所有的指针成员，定义析构函数
##### 理由
一个被持有的对象必须在持有它的对象的析构函数中删除。

##### 示例
指针成员可能表示资源。`T*`不应该这么做，但在旧代码中，这是常见的。考虑`T*`的可能的所有者，然后据此进行推测。
```cpp
template<typename T>
class Smart_ptr {
    T* p;   // 不好的：*p的所有权是模糊的
    // ...
public:
    // ... 没有用户定义的默认操作 ...
};

void use(Smart_ptr<int> p1)
{
    // 错误：p2.p泄露了（如果不是nullptr，而且没有被其它代码持有）
    auto p2 = p1;
}
```
注意，如果你定义了析构函数，那么你必须定义或者删除所有默认操作：
```cpp
template<typename T>
class Smart_ptr2 {
    T* p;   // 不好的：*p的所有权是模糊的
    // ...
public:
    // ... 没有用户定义的拷贝操作 ...
    ~Smart_ptr2() { delete p; }  // p是所有者！
};

void use(Smart_ptr2<int> p1)
{
    auto p2 = p1;   // 错误：双重删除
}
```
默认的拷贝操作只会把`p1.p`拷贝到`p2.p`，导致`p1.p`的双重析构。应该显式地声明所有权：
```cpp
template<typename T>
class Smart_ptr3 {
    owner<T*> p;   // 好的：*p的所有权是清晰的
    // ...
public:
    // ...
    // ... 拷贝和移动操作 ...
    ~Smart_ptr3() { delete p; }
};

void use(Smart_ptr3<int> p1)
{
    auto p2 = p1;   // 错误：双重删除
}
```

##### 注意
通常获得析构函数的最简单方法是把指针替换成智能指针（例如，`std::unique_ptr`），并且让编译器负责生成适当的隐式析构。

##### 注意
为什么不干脆把全部持有的指针定义成“智能指针”？因为这有时会要求非平凡的代码修改，并且会影响到ABI。

##### 实施
* 一个拥有指针数据成员的类是可疑的。
* 一个拥有`owner<T>`的类应该定义它的默认操作。

### C.35: 基类的析构函数应该要么是公有的和虚拟的，要么是受保护的和非虚拟的
##### 理由
为了避免未定义的行为。如果析构函数是公有的，那么调用代码可以尝试通过基类指针来删除派生类对象，然而，如果基类的析构函数是非虚拟的，结果是未定义的。如果析构函数是受保护的，那么调用代码不能通过基类指针来销毁对象，从而析构函数不需要是虚拟的；它确实需要是受保护的，而不是私有的，因此派生的析构函数可以调用它。通常，基类的作者不知道在析构时要执行的正确行为。

##### 讨论
参阅在讨论部分的这个内容。

##### 示例，不好的
```cpp
struct Base {  // 不好的：没有虚析构函数
    virtual void f();
};

struct D : Base {
    string s {"a resource needing cleanup"};
    ~D() { /* ... 做一些清理 ... */ }
    // ...
};

void use()
{
    unique_ptr<Base> p = make_unique<D>();
    // ...
} // p的析构函数调用~Base()，而不调用~D()，会导致泄露D::s以及可能更多的内容
```

##### 注意
虚函数为派生类定义了一个接口，该接口可以在不查看派生类的时候使用。如果该接口允许销毁，它应该能够安全地这么做。

##### 注意
析构函数必须是非私有的，否则它会阻止使用这个类型：
```cpp
class X {
    ~X();   // 私有析构函数
    // ...
};

void use()
{
    X a;                        // 错误：不能销毁
    auto p = make_unique<X>();  // 错误：不能销毁
}
```

##### 例外
我们可以想象出一个你想要受保护的虚析构函数的场景：当一个派生类型（只有这个类型）的对象被允许通过指向基类的指针销毁另一个对象（不是它自己）时。不过，我们还没有在实践见过这种场景。

##### 实施
* 拥有任何虚函数的类应该有一个析构函数，该析构函数要么是公有的和虚拟的，或者是受保护的和非虚拟的。

#### C.36: 析构函数不能失败
##### 理由
通常，如果一个析构函数可以失败，那么我们不知道如何写出没有错误的代码。标准库要求所有它处理的类都要有一个不通过抛异常来退出的析构函数。

##### 示例
```cpp
class X {
public:
    ~X() noexcept;
    // ...
};

X::~X() noexcept
{
    // ...
    if (cannot_release_a_resource) terminate();
    // ...
}
```

##### 注意
许多人试图设计一个防呆的模式来处理析构函数中的失败。没有人能成功地找到一个通用的模式。这是一个真正的实际问题：例如，套接字不能关闭怎么办？析构函数的作者不知道为什么析构函数会被调用，不能通过抛出异常来“拒绝执行”。参阅讨论。使问题更糟糕的是，很多“关闭/释放”操作是不可重试的。如果可能的话，考虑把关闭/清理的失败视为基本的设计错误，然后结束程序。

##### 注意
把析构函数声明为`noexcept`。这会保证它要么正常地完成，要么结束程序。

##### 注意
如果资源不能释放而且程序不能失败，尝试以某种方式把失败发送到系统的其它地方（可能甚至通过修改一些全局的状态，然后希望有些东西会注意到并且能够处理该问题）。要明确知道这个技术是目标特定的，并且容易出错。考虑“我的连接关闭不了”的例子。很可能在连接的另一端存在问题，而且只有同时负责连接两端的一小块代码可以正确地处理该问题。析构函数可以发送一个消息（以某种方式）给系统中负责任的部分，并认为连接已经关闭，然后正常地返回。

##### 注意
如果析构函数使用了会失败的操作，它可以捕获异常，然后在一些情况下仍然成功地完成（例如，使用了不同的会抛出异常的清理机制）。

##### 实施
（简单）如果析构函数会抛出异常，它应该声明为`noexcept`。

### C.37: 使析构函数为`noexcept`
##### 理由
析构函数不能失败。如果析构函数试图用异常来退出，这是一个槽糕的设计错误，程序最好终止。

##### 注意
如果类的所有成员都有`noexcept`析构函数，那么该类的析构函数（不论是用户定义的还是编译器生成的）会隐式地声明为`noexcept`（与函数体中的代码无关）。通过显式标记析构函数为`noexcept`，作者可以避免通过添加或修改类成员导致析构函数隐式地变为`noexcept(false)`。

##### 实施
（简单）如果析构函数会抛出异常，它应该声明为`noexcept`。

## C.ctor: 构造函数
构造函数定义了一个对象如何初始化（构造）。

### C.40: 如果类有不变式，定义构造函数
##### 理由
这就是构造函数的要做的。

##### 示例
```cpp
class Date {  // Date表示在1900年1月1日到2100年12月31日范围内的有效日期
    Date(int dd, int mm, int yy)
        :d{dd}, m{mm}, y{yy}
    {
        if (!is_valid(d, m, y)) throw Bad_date{};  // 确保不变式
    }
    // ...
private:
    int d, m, y;
};
```
在构造函数中用`Ensures`表达不变式通常是一个好主意。

##### 注意
即使类没有不变式，也能出于方便而使用构造函数。例如：
```cpp
struct Rec {
    string s;
    int i {0};
    Rec(const string& ss) : s{ss} {}
    Rec(int ii) :i{ii} {}
};

Rec r1 {7};
Rec r2 {"Foo bar"};
```

##### 注意
C++11的初始化列表规则消除了很多构造函数的需要。例如：
```cpp
struct Rec2{
    string s;
    int i;
    Rec2(const string& ss, int ii = 0) :s{ss}, i{ii} {}   // 冗余的
};

Rec2 r1 {"Foo", 7};
Rec2 r2 {"Bar"};
```
`Rec2`的构造函数是冗余的。此外，`int`的默认值使用成员初始化器会更好。

*另见*：构造有效的对象和构造函数抛异常。

##### 实施
* 标记出拥有用户定义的拷贝构造函数但没有构造函数的类（用户定义的拷贝是很好地指示，说明类有不变式）。

### C.41: 构造函数应该创建完全初始化的对象
##### 理由
构造函数为类建立不变式。类的用户应该可以假定一个构造好的对象是可用的。

##### 示例，不好的
```cpp
class X1 {
    FILE* f;   // 在任何其它函数之前调用init()
    // ...
public:
    X1() {}
    void init();   // 初始化f
    void read();   // 读取f
    // ...
};

void f()
{
    X1 file;
    file.read();   // 崩溃或者读取到坏数据！
    // ...
    file.init();   // 太迟了
    // ...
}
```
编译器不会阅读注释。

#####  例外
如果有效的对象不能方便地通过构造函数来构造，使用工厂函数。

##### 实施
* （简单）每个构造函数都应该初始化每个成员变量（可以是显式的，也可以通过委托构造调用或者通过默认构造）。
* （未知）如果构造函数有`Ensures`契约，尝试看看它是否持有一个后置条件。

##### 注意
如果构造函数需要一个资源（来创建有效的对象），那么该资源应该由析构函数释放。由构造函数获得资源然后由析构函数释放的惯用法称为RAII（“资源获取即初始化”）。

### C.42: 如果构造函数不能构造有效的对象，抛出异常
##### 理由
留下一个无效的对象是自找麻烦。

##### 示例
```cpp
class X2 {
    FILE* f;   // 在任何其它函数之前调用init()
    // ...
public:
    X2(const string& name)
        :f{fopen(name.c_str(), "r")}
    {
        if (!f) throw runtime_error{"could not open" + name};
        // ...
    }

    void read();      // 读取f
    // ...
};

void f()
{
    X2 file {"Zeno"}; // 如果文件不能打开，抛出异常
    file.read();      // 没问题
    // ...
}
```

##### 示例，不好的
```cpp
class X3 {     // 不好的：构造函数留下了一个无效的对象
    FILE* f;   // 在任何其它函数之前调用init()
    bool valid;
    // ...
public:
    X3(const string& name)
        :f{fopen(name.c_str(), "r")}, valid{false}
    {
        if (f) valid = true;
        // ...
    }

    bool is_valid() { return valid; }
    void read();   // 读取f
    // ...
};

void f()
{
    X3 file {"Heraclides"};
    file.read();   // 崩溃或者读取到坏数据！
    // ...
    if (file.is_valid()) {
        file.read();
        // ...
    }
    else {
        // ... 处理错误 ...
    }
    // ...
}
```

##### 注意
对于变量的定义（例如在栈上定义，或者作为另一个对象的成员），没有显式的函数调用可以返回一个错误码。留下一个无效的对象并且依赖用户不断地在使用之前检查`is_valid()`函数，这是单调乏味的，容易出错，并且效率低下。

##### 例外
有些领域，例如一些硬实时系统（想一下飞机控制），（在没有额外工具的支持下）异常处理从时间的观点来看没有足够的可预测性。此时必须使用`is_valid()`技术。在这些情况下，不断地检查`is_valid()`并且立即去模仿RAII。

##### 替代方案
如果你受到诱惑去使用一些“构造后初始化”或者“两阶段初始化”的惯用法，尽量不要这么做。如果你真的必须要这样做，看一下工厂函数。

##### 注意
人们使用`init()`函数而不是在构造函数中做初始化工作的其中一个原因是为了避免代码重复。委托构造函数和默认成员初始化会做得更好。另一个原因是为了延迟初始化直到需要对象的时候；解决方法通常是不要声明变量直到它能够被正确地初始化。

##### 实施
???

### C.43: 保证可拷贝（值类型）的类有默认构造函数
##### 理由
许多语言和库的设施依赖默认构造函数来初始化它们的元素，例如`T a[10]`和`std::vector<T> v(10)`。默认构造函数通常简化了为一个可拷贝类型定义合适的移出状态的任务。

##### 注意
值类型是可拷贝的类（通常也是可比较的）。它与来自EoP和Palo Alto TR的正规类型紧密相关。

##### 示例
```cpp
class Date { // 不好的：没有默认构造函数
public:
    Date(int dd, int mm, int yyyy);
    // ...
};

vector<Date> vd1(1000);   // 这里需要默认的Date
vector<Date> vd2(1000, Date{Month::October, 7, 1885});   // 另一种方式
```
默认构造函数只有在没有用户声明的构造函数时才会自动生成，因此在上面的例子中不可能初始化vector `vd1`。缺乏默认值会导致用户惊讶并且使它的使用复杂化，所以如果如果可以合理地定义构造函数，那就应该这样做。

选择`Date`作为例子是用来鼓励思考：不存在“自然的”默认日期（大爆炸太久远了，对大部分人来说没有用），所以这个例子是非平凡的。在大部分日历系统上`{0, 0, 0}`不是有效的日期，因此选择这个值的话会引入一些像浮点数的`NaN`之类的错误。当然，大部分现实的`Date`类有“第一个日期”（例如，受欢迎的1970年1月1日），因此把它作为默认值通常是不重要的。
```cpp
class Date {
public:
    Date(int dd, int mm, int yyyy);
    Date() = default; // [另见](#Rc-default)
    // ...
private:
    int dd = 1;
    int mm = 1;
    int yyyy = 1970;
    // ...
};

vector<Date> vd1(1000);
```

##### 注意
所有成员都有默认构造函数的类会隐式获得一个默认构造函数：
```cpp
struct X {
    string s;
    vector<int> v;
};

X x; // 等同于X{{}, {}}; 是一个空字符串和空vector
```

要小心内置类型不会正确地默认构造：
```cpp
struct X {
    string s;
    int i;
};

void f()
{
    X x;    // x.s初始化成空字符串；x.i未初始化

    cout << x.s << ' ' << x.i << '\n';
    ++x.i;
}
```
静态分配的内置类型对象会默认初始化成`0`，但局部的内置变量不会。要小心你的编译器可能会默认对局部内置变量进行初始化，而在优化构建中则不会这样做。因此，像上面例子中的代码可能能够正常运行，但它依赖了未定义的行为。假如你想要初始化，显式的默认初始化能提供帮助：
```cpp
struct X {
    string s;
    int i {};   // 默认初始化（为0）
};
```

##### 注意
没有合理的构造函数的类通常也是不可拷贝的，所以它们不受这个准则的影响。

例如，基类不是值类型（基类应该是不可拷贝的），因此不需要默认构造函数：
```cpp
// Shape是一个抽象基类，不是一个可拷贝的值类型。
// 它可能需要也可能不需要默认构造函数。
struct Shape {
    virtual void draw() = 0;
    virtual void rotate(int) = 0;
    // =delete 拷贝/移动函数
    // ...
};
```
必须在构造期间由调用者提供资源的类通常不能有默认构造函数，但它不受这个准则的影响，因为这样的类通常不管怎样都是不可拷贝的：
```cpp
// std::lock_guard不是可拷贝的值类型。
// 它没有默认构造函数。
lock_guard g {mx};  // guard the mutex mx
lock_guard g2;      // error: guarding nothing
```
拥有“特殊状态”的类必须由成员函数与其它状态区分处理，否则会给用户带来额外的工作（很可能是更多的错误）。这样的类型可以自然地使用特殊状态作为默认构造的值，不管它是否可拷贝：
```cpp
// std::ofstream不是可拷贝的值类型。
// 它确实有一个默认构造函数，伴随一个特殊的“未打开”状态。
ofstream out {"Foobar"};
// ...
out << log(time, transaction);
```
类似的，可拷贝的带有特殊状态的类型，例如可拷贝的智能指针，拥有特殊的状态“==nullptr”，应该使用这个特殊状态作为它们默认构造的值。

不管怎样，最好在默认构造函数中构造有意义的默认状态，例如`std::string`的`""`和`std::vector`的`{}`。

##### 实施
* 标记出可通过`=`拷贝而没有默认构造函数的类。
* 标记出可通过`==`比较但不可拷贝的类。

### C.44: 优先使默认构造函数简单并且不会抛出异常
##### 理由
能够不通过可能会失败的操作来将值设置成“默认值”，简化了关于移动操作的错误处理和说明。

##### 示例，有问题的
```cpp
template<typename T>
// elem指向使用new分配的元素
class Vector0 {
public:
    Vector0() :Vector0{0} {}
    Vector0(int n) :elem{new T[n]}, space{elem + n}, last{elem} {}
    // ...
private:
    own<T*> elem;
    T* space;
    T* last;
};
```
这很好而且常见，但在出现错误后把`Vector0`设置为空会涉及到分配，而分配可能会失败。而且，用`{new T[0], 0, 0}`表示默认的`Vector`似乎是浪费的。例如，`Vector0 v(100)`花费100个分配。

##### 示例
```cpp
template<typename T>
// elem为nullptr，或者指向使用new分配的元素
class Vector1 {
public:
    // 把内部表示设置为{nullptr, nullptr, nullptr}；不会抛异常
    Vector1() noexcept {}
    Vector1(int n) :elem{new T[n]}, space{elem + n}, last{elem} {}
    // ...
private:
    own<T*> elem = nullptr;
    T* space = nullptr;
    T* last = nullptr;
};
```
使用`{nullptr, nullptr, nullptr}`让`Vecotor1{}`更廉价，但需要额外的特殊情况和隐式的运行时检查。在检测到错误后把`Vector`设置成空是没有什么影响的。

##### 实施
* 标记会抛异常的默认构造函数。

### C.45: 不要定义只初始化数据成员的默认构造函数；使用类内部成员初始化器代替
##### 理由
使用类内部成员初始化器让编译器为你生成所需的函数。编译器生成的函数会更高效。

##### 示例，不好的
```cpp
class X1 { // 不好：没有使用成员初始化器
    string s;
    int i;
public:
    X1() :s{"default"}, i{1} { }
    // ...
};
```

##### 示例
```cpp
class X2 {
    string s = "default";
    int i = 1;
public:
    // 使用编译器生成的默认构造函数
    // ...
};
```

##### 实施
（简单）比起仅仅用常量初始化成员变量，默认构造函数应该做更多事情。

### C.46: 默认情况下，把单个参数的构造函数声明为`explicit`
##### 理由
避免意外的转换。

##### 示例，不好的
```cpp
class String {
    // ...
public:
    String(int);   // 不好的
    // ...
};

String s = 10;   // 意外：大小为10的String
```

##### 例外
如果你真的想要从构造函数的参数类型隐式转换成类类型，不要使用`explicit`：
```cpp
class Complex {
    // ...
public:
    Complex(double d);   // 好的：我们想要从d转换成{d, 0}
    // ...
};

Complex z = 10.7;   // 不意外的转换
```

*另见*：隐式转换的讨论

##### 注意
拷贝和移动构造函数不应为`explicit`，因为他们不执行转换。带有`explicit`的拷贝/移动构造函数使按值来传递和返回变得困难。

##### 实施
（简单）单个参数的构造函数应该声明为`explicit`。合理的单参数且非`explicit`的构造函数在大多数代码库里都是很罕见的。对于所有不在“确定列表”上的这种构造函数发出警告。

### C.47: 根据成员声明的顺序来定义和初始化成员变量
##### 理由
最小化困惑和错误。成员声明的顺序即初始化的顺序（与成员初始化器的顺序不相关）。

##### 示例，不好的
```cpp
class Foo {
    int m1;
    int m2;
public:
    Foo(int x) :m2{x}, m1{++x} { }   // 不好的：有误导的初始化器顺序
    // ...
};

Foo x(1); // 意外：x.m1 == x.m2 == 2
```

##### 实施
（简单）成员初始化列表应该按照成员声明的相同顺序来初始化。

*另见*：讨论

### C.48: 优先在构造函数中对成员初始化器使用类内初始化器，而不是常量初始化器
##### 理由
显式表明希望在所有构造函数中使用相同值。避免重复。避免维护问题。这会产出最短和最高效的代码。

##### 示例，不好的
```cpp
class X {   // 不好的
    int i;
    string s;
    int j;
public:
    X() :i{666}, s{"qqq"} { }   // j没有初始化
    X(int ii) :i{ii} {}         // s为""，而且j没有初始化
    // ...
};
```
维护者怎么知道`j`是否故意不初始化（总之很可能是糟糕的想法），以及`s`的默认值是否有意在一种情况下为`""`而在另一种情况下为`qqq`呢（几乎可以肯定是一个缺陷）？`j`的问题（忘记初始化成员）通常出现在往一个已存在的类添加新成员时。

##### 示例
```cpp
class X2 {
    int i {666};
    string s {"qqq"};
    int j {0};
public:
    X2() = default;        // 所有成员都以默认值初始化
    X2(int ii) :i{ii} {}   // s和j初始化为它们的默认值
    // ...
};
```

*替代方案*：我们可以从构造函数的默认参数中获取部分好处，在旧的代码中这并不罕见。不管怎样，这是不够明显的，会导致传递更多参数，而且如果多于一个构造函数的话会出现重复。
```cpp
class X3 {   // 不好的：不明显，传递参数有额外开销
    int i;
    string s;
    int j;
public:
    X3(int ii = 666, const string& ss = "qqq", int jj = 0)
        :i{ii}, s{ss}, j{jj} { }   // 所有成员都初始化为默认值
    // ...
};
```

##### 实施
* （简单）每个构造函数都应该初始化每个成员变量（可以是显式的，也可以通过委托构造调用或者通过默认构造）。
* （简单）带有默认参数的构造函数表明类内初始化器可能会更合适。

### C.49: 优先在构造函数中使用初始化而不是赋值
##### 理由
初始化显式地表明了执行的是初始化而不是赋值，而且这是更优雅且更高效的。避免“在使用之前设置”的错误。

##### 示例，好的
```cpp
class A {   // 好的
    string s1;
public:
    A() : s1{"Hello, "} { }    // 好的：直接构造
    // ...
};
```

##### 示例，不好的
```cpp
class B {   // 不好的
    string s1;
public:
    B() { s1 = "Hello, "; }   // 不好的：在默认构造函数后紧接着赋值
    // ...
};

class C {   // 难看，又非常不好
    int* p;
public:
    C() { cout << *p; p = new int{10}; }   // 在初始化之前意外地使用
    // ...
};
```

### C.50: 如果你在初始化过程中需要“虚拟行为”，使用工厂函数
##### 理由
如果基类对象的状态必须依赖对象派生部分的状态，我们需要使用虚函数（或者等价的东西），同时尽量减少误用一个未完全构造好的对象的机会。

##### 注意
工厂的返回值类型一般应该默认为`unique_ptr`；如果有些使用的地方是共享的，调用者可以通过`move`把`unique_ptr`移动到`shared_ptr`。当然，如果工厂的作者知道使用返回对象的所有地方都是共享使用，那么可以返回`shared_ptr`并且在函数体中使用`make_shared`来节省一次分配。

##### 示例，不好的
```cpp
class B {
public:
    B()
    {
        // ...
        f();   // 不好的：在构造函数中的虚拟调用
        // ...
    }

    virtual void f() = 0;

    // ...
};
```

##### 示例
```cpp
class B {
protected:
    B() { /* ... */ }              // 创建一个未完全初始化的对象

    virtual void PostInitialize()  // 在构造之后立即调用
    {
        // ...
        f();    // 好的：虚拟派发是安全地
        // ...
    }

public:
    virtual void f() = 0;

    template<class T>
    static shared_ptr<T> Create()  // 创建共享对象的接口
    {
        auto p = make_shared<T>();
        p->PostInitialize();
        return p;
    }
};

class D : public B { /* ... */ };  // 一些派生类

shared_ptr<D> p = D::Create<D>();  // 创建D对象
```
通过使构造函数为`protected`，我们避免了未完全构造的对象逃逸到外部。通过提供工厂函数`Create()`，我们使构造（在自由存储上）更方便。

##### 注意
常规的工厂函数在自由存储上分配，而不是在栈上或者封闭的对象里。

*另见*：讨论

### C.51:使用委托构造函数来表示类的所有构造函数的公共行为
##### 理由
避免重复和意外的差异。

##### 示例，不好的
```cpp
class Date {   // 不好的：重复
    int d;
    Month m;
    int y;
public:
    Date(int ii, Month mm, year yy)
        :i{ii}, m{mm}, y{yy}
        { if (!valid(i, m, y)) throw Bad_date{}; }

    Date(int ii, Month mm)
        :i{ii}, m{mm} y{current_year()}
        { if (!valid(i, m, y)) throw Bad_date{}; }
    // ...
};
```
公共的行为写起来单调乏味，而且可能意外地变得不公共。

##### 示例
```cpp
class Date2 {
    int d;
    Month m;
    int y;
public:
    Date2(int ii, Month mm, year yy)
        :i{ii}, m{mm}, y{yy}
        { if (!valid(i, m, y)) throw Bad_date{}; }

    Date2(int ii, Month mm)
        :Date2{ii, mm, current_year()} {}
    // ...
};
```

*另见*：如果“重复的行为”是简单的初始化，考虑使用类内部的成员初始化器。

##### 实施
（中等）查找相似的构造函数体。

### C.52: 使用继承构造函数把构造函数导入不需要进一步显式初始化的派生类
##### 理由
如果你需要在派生类中使用那些构造函数，重新实现它们是单调乏味而且容易出错的。

##### 示例
`std::vector`有许多复杂的构造函数，所以如果我想要我自己的`vector`，我不想重新实现它们：
```cpp
class Rec {
    // ... 数据和许多不错的构造函数 ...
};

class Oper : public Rec {
    using Rec::Rec;
    // ... 没有数据成员 ...
    // ... 许多不错的工具函数 ...
};
```

##### 示例，不好的
```cpp
struct Rec2 : public Rec {
    int x;
    using Rec::Rec;
};

Rec2 r {"foo", 7};
int val = r.x;   // 未初始化
```

##### 实施
确保派生类的每个成员都经过初始化。

## C.copy: 拷贝和移动
值类型通常应该是可拷贝的，但在类层次结构中的接口则不应该。资源句柄可能可以拷贝，也可能不可以。为了逻辑和性能原因，类型可以定义成可移动的。

### C.60: 使拷贝赋值操作符非`virtual`，以`const&`接收参数，并且以非`const&`返回
##### 理由
这是简单且高效的。如果你想针对右值进行优化，提供一个接受`&&`参数的重载版本（参阅F.18）。

##### 示例
```cpp
class Foo {
public:
    Foo& operator=(const Foo& x)
    {
        // 好的：不需要检查自我赋值（除了性能之外）
        auto tmp = x;
        std::swap(*this, tmp);
        return *this;
    }
    // ...
};

Foo a;
Foo b;
Foo f();

a = b;    // 赋值左值：拷贝
a = f();  // 赋值右值：隐式地移动
```

##### 注意
使用`swap`来实现的技术提供了强力的保证。

##### 示例
不过，如果你可以通过不生成临时拷贝的方式获得轻微的性能提升，会怎么样呢？考虑一个简单的`Vector`，在使用它的场景中，经常出现大型且相同大小的`Vector`的赋值。在这种情况下，由`swap`实现技术隐含的元素拷贝会导致成本在数量级上的增加：
```cpp
template<typename T>
class Vector {
public:
    Vector& operator=(const Vector&);
    // ...
private:
    T* elem;
    int sz;
};

Vector& Vector::operator=(const Vector& a)
{
    if (a.sz > sz) {
        // ... 使用swap技术，这不能被改善 ...
        return *this
    }
    // ... 从*a.elem拷贝元素到elem ...
    if (a.sz < sz) {
        // ... 销毁*this*中剩余的元素，并且调整大小 ...
    }
    return *this;
}
```
通过直接向目标元素写入，我们只得到基础的保证而不是由`swap`技术提供的强力保证。要小心自我赋值。

*替代方案*：如果你认为你需要一个`virtual`赋值操作符，并且理解为什么这是很有问题的，不要称之为`operator=`。创建一个具名的函数如`virtual void assign(const Foo&)`。参阅拷贝构造函数对比`clone()`。

##### 实施
* （简单）赋值操作符不应该是虚拟的。这是邪恶的巨龙！
* （简单）赋值操作符应该返回`T&`以支持链式调用，而不是返回`const T&`这类会干扰可组合性和把对象放到容器中的类型。
* （中等）赋值操作符应该（隐式或显式）调用所有基类和成员的拷贝操作符。查看析构函数来确定该类型是具有指针语义还是值语义。

### C.61: 拷贝操作应该拷贝
##### 理由
这是普遍认定的语义。在执行了`x = y`之后，我们应该有`x == y`的结果。在拷贝之后，`x`和`y`是独立的对象（值语义，非指针的内置类型和标准库类型的使用方式）或者引用共享的对象（指针语义，指针使用的方式）。

##### 示例
```cpp
class X {   // 好：值语义
public:
    X();
    X(const X&);     // 拷贝X
    void modify();   // 修改X的值
    // ...
    ~X() { delete[] p; }
private:
    T* p;
    int sz;
};

bool operator==(const X& a, const X& b)
{
    return a.sz == b.sz && equal(a.p, a.p + a.sz, b.p, b.p + b.sz);
}

X::X(const X& a)
    :p{new T[a.sz]}, sz{a.sz}
{
    copy(a.p, a.p + sz, p);
}

X x;
X y = x;
if (x != y) throw Bad{};
x.modify();
if (x == y) throw Bad{};   // 呈现出值语义
```

##### 示例
```cpp
class X2 {  // 好：指针语义
public:
    X2();
    X2(const X2&) = default; // 浅拷贝
    ~X2() = default;
    void modify();          // 修改指向的值
    // ...
private:
    T* p;
    int sz;
};

bool operator==(const X2& a, const X2& b)
{
    return a.sz == b.sz && a.p == b.p;
}

X2 x;
X2 y = x;
if (x != y) throw Bad{};
x.modify();
if (x != y) throw Bad{};  // 呈现出指针语义
```

##### 注意
优先使用拷贝语义除非你正在创建一个“智能指针”。值语义是最容易理解的，并且是标准库的设施所期望的。

##### 实施
（不可实施）

### C.62: 使拷贝赋值操作符对于自我赋值是安全的
##### 理由
如果`x = x`改变了`x`的值，人们会惊讶，并且会发生严重的错误（通常包含了泄露）。

##### 示例
标准库容器优雅且高效地处理了自我赋值：
```cpp
std::vector<int> v = {3, 1, 4, 1, 5, 9};
v = v;
// v的值仍然是{3, 1, 4, 1, 5, 9}
```

##### 注意
默认赋值在成员正确处理自我赋值时，也能保证正确处理自我赋值。
```cpp
struct Bar {
    vector<pair<int, int>> v;
    map<string, int> m;
    string s;
};

Bar b;
// ...
b = b;   // 正确和高效的
```

##### 注意
你可以通过显式地检测自我赋值来处理它，但通常不使用检测来应付的话会更快且更高效（例如，使用`swap`）。
```cpp
class Foo {
    string s;
    int i;
public:
    Foo& operator=(const Foo& a);
    // ...
};

Foo& Foo::operator=(const Foo& a)   // 可以，但有额外开销
{
    if (this == &a) return *this;
    s = a.s;
    i = a.i;
    return *this;
}
```
这是明显安全和有效的。然而，要是我们每一百万次赋值才执行一次自我赋值呢？那么就会存在大约一百万次冗余的检测（但由于检测的结果基本上总是相同的，计算机的分支预测基本上每次都会猜对）。考虑下面的：
```cpp
Foo& Foo::operator=(const Foo& a)   // 更简单，并且可能更好
{
    s = a.s;
    i = a.i;
    return *this;
}
```
`std::string`对于自我赋值是安全的，`int`也是。所有额外开销都由（罕见的）自我赋值情况带走了。

##### 实施
（简单）赋值操作符不应该包含`if (this == &a) return *this;`的模式。???

### C.63: 使移动赋值操作符非`virtual`，以`&&`接收参数，并且以非`const&`返回
##### 理由
这是简单和高效的。

*参阅*：拷贝赋值的准则。

##### 实施
与拷贝赋值做的事情相同。
* （简单）赋值操作符不应该是虚拟的。这是邪恶的巨龙！
* （简单）赋值操作符应该返回`T&`以支持链式调用，而不是返回`const T&`这类会干扰可组合性和把对象放到容器中的类型。
* （中等）移动赋值操作符应该（隐式或显式）调用所有基类和成员的移动操作符。

### C.64: 移动操作应该移动并且让它的来源处于有效的状态
##### 理由
这是普遍认定的语义。在执行了`y = std::move(x)`之后，`y`的值应该是`x`原来的值，并且`x`应该处于有效的状态。

##### 示例
```cpp
template<typename T>
class X {   // 好：值语义
public:
    X();
    X(X&& a) noexcept;  // 移动X
    void modify();     // 改变X的值
    // ...
    ~X() { delete[] p; }
private:
    T* p;
    int sz;
};


X::X(X&& a)
    :p{a.p}, sz{a.sz}  // 偷取内部表示
{
    a.p = nullptr;     // 设置为“空”
    a.sz = 0;
}

void use()
{
    X x{};
    // ...
    X y = std::move(x);
    x = X{};   // 好
} // 好：x可以被销毁
```

##### 注意
理想情况下，在被移走之后，对象应该是类型的默认值。要保证这一点，除非有特别好的理由不这么做。当然，不是所有类型都有默认值，而且有些类型建立默认值是昂贵的。C++标准只要求被移走的对象能够销毁。通常，我们可以容易且廉价地做得更好：标准库假定对被移走的对象赋值是可能的。总是让被移走的对象处于某种有效的状态。

##### 注意
除非有特别强烈的理由不这么做，否则应使`x = std::move(y); y = z;`能按照惯用语义正常执行。

##### 实施
（不可实施）查找在移动操作中对成员的赋值。如果存在默认构造函数，把那些赋值与默认构造函数中的初始化进行对比。

### C.65: 使移动赋值操作符对于自我赋值是安全的
##### 理由
如果`x = x`改变了`x`的值，人们会感到惊讶，并且会发生严重的错误。当然，人们一般不会直接写出会转变成移动的自我赋值，但它是可能发生的。不管怎样，`std::swap`使用了移动操作来实现，因此如果你意外地执行了`swap(a, b)`，而`a`和`b`指向同一个对象的话，不能处理自我移动是严重且不易察觉的错误。

##### 示例
```cpp
class Foo {
    string s;
    int i;
public:
    Foo& operator=(Foo&& a);
    // ...
};

Foo& Foo::operator=(Foo&& a) noexcept  // 没问题，但是有额外的开销
{
    if (this == &a) return *this;  // 这一行是冗余的
    s = std::move(a.s);
    i = a.i;
    return *this;
}
```
在自我赋值的论述中，关于`if (this == &a) return *this;`这个检测存在的“一百万次中的一次”问题的讨论，对于自我移动来说甚至更有意义。

##### 注意
没有已知的普遍适用的方法来避免移动赋值中的`if (this == &a) return *this;`检测，而又仍然能够得到正确的结果（例如，在执行了`x = x`之后`x`的值不发生改变）。

##### 注意
ISO标准保证了对于标准库容器只有一个“有效但不确定的”状态。显然，在将近10年的试验和正式产品使用中这还不是问题。如果你发现了反例，请联系作者。这里的准则会更加谨慎且坚持完全的安全。

##### 示例
这里是一个移动指针而不需要检测的方法（想像这是在一个移动赋值的实现中的代码）：
```cpp
// 从other.ptr移动到this->ptr
T* temp = other.ptr;
other.ptr = nullptr;
delete ptr;
ptr = temp;
```

##### 实施
* （中等）在自我赋值的情况下，移动赋值操作符不应该让对象持有已经被`delete`删除或者设置成`nullptr`的指针成员。
* （不可实施）查看标准库容器类型的使用（包括`string`），并考察它们对于普通用法（非生命周期紧密相关的）是否安全。

### C.66: 使移动操作为`noexcept`
##### 理由
会抛异常的移动操作违背了大多数人合理的假设。不会抛异常的移动操作在标准库和语言的设施中用起来更高效。

##### 示例
```cpp
template<typename T>
class Vector {
    // ...
    Vector(Vector&& a) noexcept :elem{a.elem}, sz{a.sz} { a.sz = 0; a.elem = nullptr; }
    Vector& operator=(Vector&& a) noexcept { elem = a.elem; sz = a.sz; a.sz = 0; a.elem = nullptr; }
    // ...
public:
    T* elem;
    int sz;
};
```
这些操作不会抛异常。

##### 示例，不好的
```c
template<typename T>
class Vector2 {
    // ...
    Vector2(Vector2&& a) { *this = a; }             // 只使用了拷贝
    Vector2& operator=(Vector2&& a) { *this = a; }  // 只使用了拷贝
    // ...
public:
    T* elem;
    int sz;
};pp
```
`Vector2`不仅效率低，而且由于拷贝需要分配，可能会抛异常。

##### 实施
（简单）移动操作应该标记为`noexcept`。

### C.67: 如果希望拥有“拷贝行为”，基类应该阻止拷贝，并且提供一个虚拟的`clone`来代替
##### 理由
避免对象切割，因为普通的拷贝操作只拷贝派生对象的基类部分。

##### 示例，不好的
```cpp
class B { // 不好的：基类没有屏蔽拷贝
    int data;
    // ... 拷贝操作不需要做什么，因此使用默认的 ...
};

class D : public B {
    string more_data; // 添加一个数据成员
    // ...
};

auto d = make_unique<D>();

// 糟糕，切割了对象；只得到d.data，丢失了d.more_data
auto b = make_unique<B>(d);
```

##### 示例
```cpp
class B { // 好：基类屏蔽了拷贝
public:
    B(const B&) = delete;
    B& operator=(const B&) = delete;
    virtual unique_ptr<B> clone() { return /* B object */; }
    // ...
};

class D : public B {
    string more_data; // 添加一个数据成员
    unique_ptr<B> clone() override { return /* D object */; }
    // ...
};

auto d = make_unique<D>();
auto b = d.clone(); // 没问题，深克隆
```

##### 注意
返回智能指针是好的，但它不像原始指针那样可以使用协变返回类型（例如，`D::clone`不能返回`unique_ptr<D>`。不要让这个引诱你返回原始指针；与智能指针提供的主要健壮性好处相比，这是次要的缺点。

##### 例外
如果你需要协变返回类型，返回`owner<derived*>`。参阅C.130。

##### 实施
具有任何虚拟函数的类不应该有拷贝构造函数或者拷贝赋值操作符（不论是编译器生成的还是手写的）。

## C.other: 其它默认操作准则
除了语言提供默认实现的操作，还有一些操作非常基础，因此需要准则来规范它们的定义：比较，`swap`和`hash`。

### C.80: 如果你必须显式说明要使用默认语义，使用`=default`
##### 理由
编译器更可能得到正确的默认语义，而且你不可能把这些函数实现得比编译器更好。

##### 示例
```cpp
class Tracer {
    string message;
public:
    Tracer(const string& m) : message{m} { cerr << "entering " << message << '\n'; }
    ~Tracer() { cerr << "exiting " << message << '\n'; }

    Tracer(const Tracer&) = default;
    Tracer& operator=(const Tracer&) = default;
    Tracer(Tracer&&) = default;
    Tracer& operator=(Tracer&&) = default;
};
```
因为我们定义了析构函数，所以我们必须定义拷贝和移动操作。使用`=default`达到这个目的是最好且最简单的。

##### 示例，不好的
```cpp
class Tracer2 {
    string message;
public:
    Tracer2(const string& m) : message{m} { cerr << "entering " << message << '\n'; }
    ~Tracer2() { cerr << "exiting " << message << '\n'; }

    Tracer2(const Tracer2& a) : message{a.message} {}
    Tracer2& operator=(const Tracer2& a) { message = a.message; return *this; }
    Tracer2(Tracer2&& a) :message{a.message} {}
    Tracer2& operator=(Tracer2&& a) { message = a.message; return *this; }
};
```
写出拷贝和移动操作的的函数体是冗余的，单调乏味的，而且容易出错的。编译器会做得更好。

##### 实施
（中等）特殊操作的函数体不应该与编译器生成的版本具有相同的访问操作和语义，因为那是冗余的。

### C.81: 当你想要禁用默认行为（又不想要其它替代方案）时，使用`=delete`
##### 理由
在一些情况下，不希望使用默认操作。

##### 示例
```cpp
class Immortal {
public:
    ~Immortal() = delete;   // 不允许析构
    // ...
};

void use()
{
    Immortal ugh;   // 出错：ugh不能被销毁
    Immortal* p = new Immortal{};
    delete p;       // 出错：不能销毁*p
}
```

##### 示例
`unique_ptr`可以移动，但不能拷贝。为了达到这个目的，它的拷贝操作被删除了。为了避免拷贝，有必要在接受左值的拷贝操作上使用`=delete`：
```cpp
template <class T, class D = default_delete<T>> class unique_ptr {
public:
    // ...
    constexpr unique_ptr() noexcept;
    explicit unique_ptr(pointer p) noexcept;
    // ...
    unique_ptr(unique_ptr&& u) noexcept;   // 移动构造函数
    // ...
    unique_ptr(const unique_ptr&) = delete; // 禁用对左值的拷贝
    // ...
};

unique_ptr<int> make();   // 创建“一些东西”然后通过移动来返回

void f()
{
    unique_ptr<int> pi {};
    auto pi2 {pi};      // 错误：不存在接受左值的移动构造函数
    auto pi3 {make()};  // 没问题，移动：make()的结果是一个右值
}
```
注意被删除的方法应该是公有的。

##### 实施
是否排除默认操作（应该）基于类所期望的语义。要对排除了默认操作的类持有怀疑态度，但同时要维护一份“正确列表”，这份列表中的类已经由人们断定语义是正确的。

### C.82: 不要在构造函数和析构函数中调用虚函数
##### 理由
调用的函数是到调用点为止已构造对象的函数，而不是可能在派生类中重写的函数。这是最令人困惑的。更糟糕的是，在构造函数或者析构函数中直接或者间接调用未实现的纯虚函数会导致未定义的行为。

##### 示例，不好的
```cpp
class Base {
public:
    virtual void f() = 0;   // 未实现
    virtual void g();       // 实现了基类版本
    virtual void h();       // 实现了基类版本
};

class Derived : public Base {
public:
    void g() override;   // 提供派生实现
    void h() final;      // 提供派生实现

    Derived()
    {
        // 不好：尝试调用未实现的虚函数
        f();

        // 不好：会调用Derived::g，不会进一步派发虚拟调用
        g();

        // 好：显式声明意图只调用可见的版本
        Derived::g();

        // 没问题，不需要限定，h是最终的
        h();
    }
};
```
注意，调用指定了显式限定的函数不是虚拟调用，即使该函数是`virtual`。

*另见*工厂函数来看看如何达到调用派生类函数的效果而不会有未定义行为的风险。

##### 注意
从构造函数和析构函数中调用虚函数不存在内在的错误。这些调用的语义是类型安全地。然而，经验表明这些调用很少需要，容易迷惑维护者，而且当新手使用的时候会成为错误的来源。

##### 实施
* 标记出在构造函数和析构函数中调用的虚函数。

### C.83: 对于值类型，考虑提供一个`noexcept`交换函数
##### 理由
`swap`可以用来方便地实现许多惯用法，从平滑地移动对象到容易地实现赋值，它提供了有保证的提交函数来实现强错误安全的调用代码。考虑使用交换来根据拷贝构造实现拷贝赋值。另外可参阅析构函数、析构和交换不能失败。

##### 示例，好的
```cpp
class Foo {
    // ...
public:
    void swap(Foo& rhs) noexcept
    {
        m1.swap(rhs.m1);
        std::swap(m2, rhs.m2);
    }
private:
    Bar m1;
    int m2;
};
```
为了方便调用者，可以在与你的类型相同的名称空间内提供一个非成员`swap`函数。
```cpp
void swap(Foo& a, Foo& b)
{
    a.swap(b);
}
```

##### 实施
* （简单）没有虚函数的类应该声明一个`swap`成员函数。
* （简单）如果类有一个`swap`成员函数，它应该声明为`noexcept`。

### C.84: `swap`不能失败
##### 理由
`swap`广泛地用在假定不会失败的地方，而且假如存在会失败的`swap`，则不能容易地写出仍然能够正确运行的程序。标准库的容器和算法在元素类型的交换函数失败时不能够正确执行。

##### 示例，不好的
```cpp
void swap(My_vector& x, My_vector& y)
{
    auto tmp = x;   // 拷贝元素
    x = y;
    y = tmp;
}
```
这样做不仅仅慢，而且如果`tmp`内的元素发生了内存分配，这个`swap`可能会抛异常，导致使用了它的STL算法失败。

##### 实施
（简单）如果类有一个`swap`成员函数，它应该声明为`noexcept`。

### C.85: 使`swap`为`noexcept`
##### 理由
`swap`不能失败。如果`swap`试图用异常来退出，这是糟糕的设计错误，程序最好终止。

##### 实施
（简单）如果类有一个`swap`成员函数，它应该声明为`noexcept`。

### C.86: 使`==`的操作数类型对称，并且为`noexcept`
##### 理由
不对称地对待操作数是令人诧异的，当存在可能的类型转换时，这是错误的来源。`==`是基础的操作，程序员应该能够在不担心失败的情况下使用它。

##### 示例
```cpp
struct X {
    string name;
    int number;
};

bool operator==(const X& a, const X& b) noexcept {
    return a.name == b.name && a.number == b.number;
}
```

##### 示例，不好的
```cpp
class B {
    string name;
    int number;
    bool operator==(const B& a) const {
        return name == a.name && number == a.number;
    }
    // ...
};
```
`B`的比较接受第二个操作数的转换，但第一个操作数不能。

##### 注意
如果类具有失败状态，比如`double`的`NaN`，它会诱惑你在与失败状态比较时抛异常。替代方法是让两个失败状态的比较结果为相等，并且任何正确状态与失败状态的比较结果为不相等。

##### 注意
该准则适用于所有常见的比较操作符：`!=`，`<`，`<=`和`>=`。

##### 实施
* 标记出参数类型不一样的`operator==()`；其它比较操作符也一样：`!=`，`<`，`<=`，`>`和`>=`。
* 标记出作为成员的`operator==()`；其它比较操作符也一样：`!=`，`<`，`<=`，`>`和`>=`。

### C.87: 注意基类的`==`
##### 理由
为类层次结构写出不会出错而且有用的`==`真的非常困难。

##### 示例，不好的
```cpp
class B {
    string name;
    int number;
    virtual bool operator==(const B& a) const
    {
         return name == a.name && number == a.number;
    }
    // ...
};
```
`B`的比较操作接受第二个操作数的转换，但它的第一个操作数不能。

```cpp
class D :B {
    char character;
    virtual bool operator==(const D& a) const
    {
        return name == a.name && number == a.number && character == a.character;
    }
    // ...
};

B b = ...
D d = ...
b == d;    // 比较name和number，忽略d的character
d == b;    // 出错：没有定义相关的==
D d2;
d == d2;   // 比较name，number和character
B& b2 = d2;
b2 == d;   // 比较name和number，忽略d2和d的character
```
当然有办法可以让`==`在类层次结构中运作，但是这个天真的方法是不通用的。

##### 注意
该准则适用于所有常见的比较操作符：`!=`，`<`，`<=`和`>=`。

##### 实施
* 标记出虚拟的`operator==()`；其它比较操作符也一样：`!=`，`<`，`<=`和`>=`。

### C.89: 使`hash`为`noexcept`
##### 理由
哈希容器的用户会直接使用`hash`，而且不希望这个简单的访问会抛异常。这是标准库的要求。

##### 示例，不好的
```cpp
template<>
struct hash<My_type> {  // 完全错误的hash特化
    using result_type = size_t;
    using argument_type = My_type;

    size_t operator() (const My_type & x) const
    {
        size_t xs = x.s.size();
        if (xs < 4) throw Bad_My_type{};    // "Nobody expects the Spanish inquisition!"
        return hash<size_t>()(x.s.size()) ^ trim(x.s);
    }
};

int main()
{
    unordered_map<My_type, int> m;
    My_type mt{ "asdfg" };
    m[mt] = 7;
    cout << m[My_type{ "asdfg" }] << '\n';
}
```
如果你必须定义`hash`的特化版本，尽量用`^`（异或）组合标准库中的`hash`特化版本来简化它。对于非专家来说，这比“聪明”运作得更好。

##### 实施
* 标记出会抛异常的`hash`。

## C.con: 容器和其它资源句柄
容器是一个对象，它持有某种类型的对象序列；`std::vector`是基础的容器。资源句柄是一个类，它持有资源；`std::vector`是典型的资源句柄；它的资源是它的对象序列。

容器准则概要：
* C.100: 定义容器的时候遵守STL
* C.101: 为容器提供值语义
* C.102: 为容器提供移动操作
* C.103: 为容器提供初始化列表构造函数
* C.104: 为容器提供设置为空的默认构造函数
* C.105: 提供构造函数和`Extent`构造函数
* ???
* C.109: 如果资源句柄有指针语义，提供`*`和`->`

*另见*：资源

## C.lambdas: 函数对象和lambda
函数对象是一个提供了`()`重载的对象，因此你可以调用它。lambda表达式（在口语上通常简称为“lambda”）是生成函数对象的表示法。函数对象的拷贝应该是廉价的（因此可以以值来传递）。

概要：
* F.50: 在函数不能达到目的的时候使用lambda（捕捉局部变量，或者写一个局部函数）
* F.52: 在局部使用的lambda中，优先以引用来捕获变量，包括传递给算法
* F.53: 在非局部使用的lambda中，避免以引用来捕获变量，包括返回，在堆中存储，或者传递给其它线程
* ES.28: 对复杂的初始化使用lambda，特别是`const`变量

## C.hier: 类层次结构（OOP）
类层次结构（只）用来表示一组分层组织的概念。通常基类会作为接口。对于层次结构有两种主要的用法，通常称之为实现继承和接口继承。

类层次结构准则概要：
* C.120: （只）使用类层次结构来表示继承的层次概念
* C.121: 如果基类用作接口，使其为纯抽象类
* C.122: 当需要完全分离接口和实现的时候，使用抽象类作为接口

层次结构中类的设计准则概要：
* C.126: 抽象类通常不需要构造函数
* C.127: 有虚函数的类应该有虚拟或者受保护的析构函数
* C.128: 虚函数应该只指定`virtual`、`override`或者`final`的其中一个
* C.129: 在设计类层次结构的时候，区分实现继承和接口继承
* C.130: 在基类中重定义或者禁止拷贝；优先使用虚拟的`clone`函数代替
* C.131: 避免无意义的获取函数和设置函数
* C.132: 不要无故使使函数为`virtual`
* C.133: 避免`protected`数据
* C.134: 保证所有非`const`数据成员有相同的访问级别
* C.135: 使用多重继承来表示多个不同的接口
* C.136: 使用多重继承来表示实现属性的合并
* C.137: 使用`virtual`基类来避免过于通用的基类
* C.138: 使用`using`为派生类和它的基类创建重载集合
* C.139: 保守地使用`final`
* C.140: 不要为虚拟函数和它的覆写函数提供不同的默认参数

在层次结构中访问对象的准则概要：
* C.145: 通过指针和引用访问多态对象
* C.146: 当类层次结构的类型访问不可避免时，使用`dynamic_cast`
* C.147: 当不能找到所需的类视为错误时，在引用类型上使用`dynamic_cast`
* C.148: 当不能找到所需的类视为有效的可选状态时，在指针类型上使用`dynamic_cast`
* C.149: 使用`unique_ptr`或`shared_ptr`来避免忘记用`delete`删除由`new`创建的对象
* C.150: 使用`make_unique()`来构造由`unique_ptr`持有的对象
* C.151: 使用`make_shared()`来构造由`shared_ptr`持有的对象
* C.152: 永不将指向派生类对象数组的指针赋值给指向其基类的指针
* C.153: 优先使用虚拟函数而不是类型转换

###  C.120: （只）使用类层次结构来表示继承的层次概念
##### 理由
直接在代码中表达想法易于理解和维护。要确保在基类中表达的想法完全匹配所有派生类型，并且没有比使用紧耦合继承更好表达地这个想法的方式。

当简单地持有数据成员就能够达到目的的时候，不要使用继承。通常这意味着派生类需要覆写基类的虚拟函数或者需要访问受保护成员。

##### 示例
```cpp
class DrawableUIElement {
public:
    virtual void render() const = 0;
    // ...
};

class AbstractButton : public DrawableUIElement {
public:
    virtual void onClick() = 0;
    // ...
};

class PushButton : public AbstractButton {
    virtual void render() const override;
    virtual void onClick() override;
    // ...
};

class Checkbox : public AbstractButton {
// ...
};
```

##### 示例，不好的
不要把无层次的领域概念表示为类层次结构。
```cpp
template<typename T>
class Container {
public:
    // list operations:
    virtual T& get() = 0;
    virtual void put(T&) = 0;
    virtual void insert(Position) = 0;
    // ...
    // vector operations:
    virtual T& operator[](int) = 0;
    virtual void sort() = 0;
    // ...
    // tree operations:
    virtual void balance() = 0;
    // ...
};
```
这里，大部分覆写的类不能很好地实现接口要求的大部分函数。所以这个基类变成了实现负担。而且，`Container`的用户不能指望成员函数真的合理高效地执行了有意义的操作；相反它可能会抛出异常。因此，用户必须求助于运行时检查，并且/或者不使用这个（过于）通用的接口，转而使用基于运行时类型查询（例如`dynamic_cast`）创建的特殊接口。

##### 实施
* 查找那些拥有许多不做事情只抛出异常的成员的类。
* 标记出对非公有基类`B`的每处使用，其中`B`的派生类`D`不覆写虚拟函数或访问`B`的受保护成员，而且`B`不是以下情况中的一种：空类，模板参数或者`D`的参数包，用`D`特化的类模板。

### C.121: 如果基类用作接口，使其为纯抽象类
##### 理由
如果一个类不包含数据，会更加稳定（更不脆弱）。接口通常应该完全有公有的纯虚拟函数和默认/空的虚拟析构函数组成。

##### 示例
```cpp
class My_interface {
public:
    // ... 这里只有纯虚拟函数 ...
    virtual ~My_interface() {}   // 或者 =default
};
```

##### 示例，不好的
```cpp
class Goof {
public:
    // ... 这里只有纯虚拟函数 ...
    // 没有虚拟析构函数
};

class Derived : public Goof {
    string s;
    // ...
};

void use()
{
    unique_ptr<Goof> p {new Derived{"here we go"}};
    f(p.get()); // 通过Goof的接口使用Derived
    g(p.get()); // 通过Goof的接口使用Derived
} // 泄露
```
`Derived`通过它的`Goof`接口用`delete`来删除，所以它的`string`泄露了。为`Goof`提供虚拟析构函数之后，一切都没问题了。

##### 实施
* 对于任意类，如果它包含数据成员，同时有可覆写（非`final`）的虚拟函数，发出警告。

### C.122: 当需要完全分离接口和实现的时候，使用抽象类作为接口
##### 理由
比如说在ABI（链接）的边界上

##### 示例
```cpp
struct Device {
    virtual ~Device() = default;
    virtual void write(span<const char> outbuf) = 0;
    virtual void read(span<char> inbuf) = 0;
};

class D1 : public Device {
    // ... 数据 ...

    void write(span<const char> outbuf) override;
    void read(span<char> inbuf) override;
};

class D2 : public Device {
    // ... 不同的数据 ...

    void write(span<const char> outbuf) override;
    void read(span<char> inbuf) override;
};
```
用户现在可以通过`Device`提供的接口可交换地使用`D1`和`D2`。而且，我们可以使用与旧版本非二进制兼容的方式来更新`D1`和`D2`，只要所有访问都通过`Device`。

##### 实施
???

## C.hierclass: 设计在层次结构中的类
### C.126: 抽象类通常不需要构造函数
##### 理由
抽象类通常没有任何数据让构造函数初始化。

##### 示例
???

##### 例外
* 基类的构造函数确实有用，例如在某个地方注册一个对象，可能需要构造函数。
* 在极端罕见的情况下，你可能会发现抽象类拥有一点被所有派生类共享的数据是合理的（例如，使用静态数据，调试信息等）；这些类倾向于有构造函数。但是要提醒你：这些类同样容易倾向于需要虚拟继承。

##### 实施
标记出有构造函数的抽象类。

### C.127: 有虚函数的类应该有虚拟或者受保护的析构函数
##### 理由
拥有虚拟函数的类时常（而且通常）通过基类的指针来使用。一般情况下，最后的用户必须在基类的指针上调用`delete`，这通常是通过基类的智能指针，因此这个类的析构函数应该是公有的和虚拟的。在较不常见的情况下，如果不希望支持通过基类指针来删除，析构函数应该是受保护的和非虚拟的；参阅C.35。

##### 示例，不好的
```cpp
struct B {
    virtual int f() = 0;
    // ... 没有用户提供的析构函数，默认为公有非虚拟的 ...
};

// 糟糕的：从没有虚拟析构函数的类派生
struct D : B {
    string s {"default"};
};

void use()
{
    unique_ptr<B> p = make_unique<D>();
    // ...
} // 未定义行为。可能只调用B::~B并且泄露了string
```

### 注意
有些人不遵循该准则，因为他们希望只通过`shared_ptr`来使用类：`std::shared_ptr<B> p = std::make_shared<D>(args);`。这里，共享的指针会处理好删除，因此对基类不合适的`delete`不会发生泄露。经常这样做的人会错误地乐观，但该准则是重要的——如果有一个对象是使用`make_unique`分配的呢？这是不安全的，除非`B`的作者保证了它永远不会被误用，例如让所有构造函数都为私有的，并且提供工厂函数来保证用`make_shared`分配。

##### 实施
* 拥有任何虚拟函数的类都应该有一个析构函数，该函数即可以是公有且虚拟的，也可以是受保护且非虚拟的。
* 标记出作用于有虚拟函数但没有虚拟析构函数的类上的`delete`。

### C.128: 虚函数应该只指定`virtual`、`override`或者`final`的其中一个
##### 理由
可读性。检测错误。写出明显的`virtual`、`override`或者`final`是自带文档的，并且能够让编译器捕捉在基类和派生类之间不匹配的类型以及/或者名称。然而，在这三者中，写出一个以上都是冗余的，而且是潜在的错误来源。

只有在声明新的虚拟函数时使用`virtual`。只有在声明覆写函数时使用`override`。只有在声明终结的覆写函数时使用`final`。如果基类的析构函数声明为`virtual`，那么要避免声明派生类的析构函数为`virtual`或者`override`。一些代码库和工具可能会坚持在析构函数使用`override`，但在这些指南中这是不建议的。

##### 示例，不好的
```cpp
struct B {
    void f1(int);
    virtual void f2(int) const;
    virtual void f3(int);
    // ...
};

struct D : B {
    void f1(int);        // 不好的（希望能有警告）：D::f1()隐藏了B::f1()
    void f2(int) const;  // 不好的（但符合习惯并且有效）：没有显式覆写
    void f3(double);     // 不好的（希望能有警告）：D::f3()隐藏了B::f3()
    // ...
};
```

##### 示例，好的
```cpp
struct Better : B {
    void f1(int) override;        // 错误（被捕捉）：D::f1()隐藏了B::f1()
    void f2(int) const override;
    void f3(double) override;     // 错误（被捕捉）：D::f3()隐藏了B::f3()
    // ...
};
```

##### 实施
* 比较基类和派生类中的名称，标记出使用了相同名称但没有覆写的函数。
* 标记出既没有用`override`也没有用`final`的覆写函数。
* 标记出使用了`virtual`、`override`和`final`中超过一个以上的函数声明。

### C.129: 在设计类层次结构的时候，区分实现继承和接口继承
##### 理由
在接口中存在的实现细节会使接口脆弱；也就是说，会让它的用户容易受到影响，在修改了接口实现之后不得不重新编译。在基类中的数据增加了基类实现的复杂度，而且会导致重复代码。

##### 注意
定义：
* 接口继承是用来隔离用户和实现的继承，特别是允许在不影响基类用户的前提下添加和修改派生类。
* 实现继承是用来简化新功能实现的继承，为新操作的实现提供有用的相关操作（有时候称为“根据差异编程”）。

纯接口类是简单的纯虚拟函数集合；参阅I.25。

在早期的OOP中（例如，在1980年代和1990年代），实现继承和接口继承通常混淆在一起，这个坏习惯很难消灭。即使是现在，这种混合的代码在旧代码库和旧式教材里并非罕见。

保持这两种继承的重要性在增加
* 随着层次结构大小的增长（例如，很多的派生类），
* 随着层次结构被使用的时间长度的增加（例如，数十年），以及
* 随着使用层次结构的不同组织数量的增加（例如，难以对基类发布新的更新）。

##### 示例，不好的
```cpp
class Shape {   // 不好的，混合了接口和实现
public:
    Shape();
    Shape(Point ce = {0, 0}, Color co = none): cent{ce}, col {co} { /* ... */}

    Point center() const { return cent; }
    Color color() const { return col; }

    virtual void rotate(int) = 0;
    virtual void move(Point p) { cent = p; redraw(); }

    virtual void redraw();

    // ...
private:
    Point cent;
    Color col;
};

class Circle : public Shape {
public:
    Circle(Point c, int r) :Shape{c}, rad{r} { /* ... */ }

    // ...
private:
    int rad;
};

class Triangle : public Shape {
public:
    Triangle(Point p1, Point p2, Point p3); // 计算中点
    // ...
};
```
存在的问题：
* 随着层次结构增长，以及更多的数据添加到`Shape`，构造函数会更加难以编写和维护。
* 为什么要为`Triangle`计算中点？我们也许从来不使用它。
* 添加一个数据成员到`Shape`（例如，绘制样式或者画布），所有派生类和所有用户都需要重新检查，可能要进行修改，可能要重新编译。

`Shape::move()`的实现是实现继承的例子：我们只为所有派生类定义`move()`一次。越多代码在基类的成员函数实现中，以及越多数据放在基类中来共享，我们就会得到更多好处——同时层次结构会更不稳定。

##### 示例
这个`Shape`的层次结构可以使用接口继承来重写：
```cpp
class Shape {  // 纯接口
public:
    virtual Point center() const = 0;
    virtual Color color() const = 0;

    virtual void rotate(int) = 0;
    virtual void move(Point p) = 0;

    virtual void redraw() = 0;

    // ...
};
```
注意纯接口几乎不会有构造函数：没有东西要构造。
```cpp
class Circle : public Shape {
public:
    Circle(Point c, int r, Color c) :cent{c}, rad{r}, col{c} { /* ... */ }

    Point center() const override { return cent; }
    Color color() const override { return col; }

    // ...
private:
    Point cent;
    int rad;
    Color col;
};
```
该接口现在没那么脆弱了，但在成员函数的实现中会有更多工作。例如，`center`必须由每个派生自`Shape`的类实现。

##### 示例，双重层次结构
我们怎样可以从接口继承得到稳定的层次结构，同时从实现继承得到复用实现的好处呢？一个广泛使用的技术是双重层次结构。有许多方法来实现双重层次结构的想法；这里，我们使用一个多重继承的变体。

首先我们设计接口类的层次结构：
```cpp
class Shape {   // 纯接口
public:
    virtual Point center() const = 0;
    virtual Color color() const = 0;

    virtual void rotate(int) = 0;
    virtual void move(Point p) = 0;

    virtual void redraw() = 0;

    // ...
};

class Circle : public Shape {   // 纯接口
public:
    virtual int radius() = 0;
    // ...
};
```
为了让这个接口有用，我们必须提供它的实现类（这里，类的命名一样，但在`Impl`名称空间中）：
```cpp
class Impl::Shape : public Shape { // 实现
public:
    // 构造函数，析构函数
    // ...
    Point center() const override { /* ... */ }
    Color color() const override { /* ... */ }

    void rotate(int) override { /* ... */ }
    void move(Point p) override { /* ... */ }

    void redraw() override { /* ... */ }

    // ...
};
```
现在`Shape`是一个带有实现的类的拙劣例子，但我们可以容忍，因为这只是一个针对复杂层次结构技术的简单的示例。
```cpp
class Impl::Circle : public Circle, public Impl::Shape {   // 实现
public:
    // 构造函数，析构函数

    int radius() override { /* ... */ }
    // ...
};
```
然后我们可以添加一个`Smiley`类（:-)）来扩展这个层次结构：
```cpp
class Smiley : public Circle { // 纯接口
public:
    // ...
};

class Impl::Smiley : public Smiley, public Impl::Circle {   // 实现
public:
    // 构造函数，析构函数
    // ...
}
```
现在有了两个层次结构：
* 接口：`Smiley` -> `Circle` -> `Shape`
* 实现：`Impl::Smiley` -> `Impl::Circle` -> `Impl::Shape`

由于每个实现都从它的接口和实现基类派生，我们得到一个格子框架（DAG）：
```
Smiley     ->         Circle     ->  Shape
  ^                     ^               ^
  |                     |               |
Impl::Smiley -> Impl::Circle -> Impl::Shape
```

正如上面提到的，这只是构建双重层次结构的一种方法。

实现层次结构可以直接使用，而不用通过抽象接口。
```cpp
void work_with_shape(Shape&);

int user()
{
    Impl::Smiley my_smiley{ /* args */ };   // 创建具体形状
    // ...
    my_smiley.some_member();        // 直接使用实现类
    // ...
    work_with_shape(my_smiley);     // 通过抽象接口使用实现
    // ...
}
```
如果实现类含有的成员没有在抽象接口中提供，或者如果直接使用成员能提供优化的机会，这种做法是有用的（例如，如果一个实现的成员函数为`final`）。

##### 注意
另一个与隔离接口和实现（相关的）技术是Pimpl。

##### 注意
在把通用功能作为（实现）基类中的函数和自由函数（在一个实现名称空间中）之间，通常会有个选择。基类提供了更短的表示符号，而且更容易访问（在基类中的）共享数据，代价是这个功能只对层次结构的用户可用。

##### 实施
* 标记出派生来到基类转换，该基类同时拥有数据和虚拟函数（除了从派生类成员到基类成员的调用）。
* ???

### C.130: 在基类中重定义或者禁止拷贝；优先使用虚拟的`clone`函数代替
##### 理由
拷贝基类通常会导致对象切割。如果你真的需要拷贝语义，那么要深拷贝：提供一个虚拟的`clone`函数，该函数会拷贝实际最深层派生的类型，并且返回一个指向新对象的指针，然后在派生类中返回这个派生类型（使用协变返回类型）。

##### 示例
```cpp
class Base {
public:
    virtual owner<Base*> clone() = 0;
    virtual ~Base() = 0;

    Base(const Base&) = delete;
    Base& operator=(const Base&) = delete;
};

class Derived : public Base {
public:
    owner<Derived*> clone() override;
    virtual ~Derived() override;
};
```
注意，由于语言规则，协变返回类型不能用于智能指针。参阅C.67。

##### 实施
* 标记出拥有虚拟函数以及非用户定义拷贝操作的类。
* 标记出对基类对象的赋值（对象的类派生于另一个对象的类）。

### C.131: 避免无意义的获取函数和设置函数
##### 理由
无意义的获取函数和设置函数没有增加语义价值；数据项也可以是`public`的。

##### 示例
```cpp
class Point {   // 不好的：啰嗦
    int x;
    int y;
public:
    Point(int xx, int yy) : x{xx}, y{yy} { }
    int get_x() const { return x; }
    void set_x(int xx) { x = xx; }
    int get_y() const { return y; }
    void set_y(int yy) { y = yy; }
    // 没有具有行为的成员函数
};
```
考虑把这种类定义成`struct`——也就是说，没有行为的变量捆绑，所有成员都是公有数据，没有成员函数。
```cpp
struct Point {
    int x {0};
    int y {0};
};
```
注意我们可以在成员变量中使用默认初始化器：C.49: 优先在构造函数中使用初始化而不是赋值。

##### 注意
这个准则的关键是获取函数/设置函数的语义是否无意义的。可是“无意义”并没有完整的定义，因此要想想如果获取函数/设置函数是公有数据成员的话，在语法之上是否会有任何不同。非无意义语义的例子有：维护类不变式或者在内部类型和接口类型之间转换。

##### 实施
标记出多个`get`和`set`成员函数，这些函数只是简单的访问成员而没有额外的语义。

### C.132: 不要无故使使函数为`virtual`
##### 理由
多余的`virtual`增加了运行时开销和对象代码的大小。虚拟函数可以被覆写，因此会在派生类中产生错误。模板层次结构中的虚拟函数会导致代码重复。

##### 示例，不好的
```cpp
template<class T>
class Vector {
public:
    // ...
    virtual int size() const { return sz; }   // 不好的：派生类能做什么？
private:
    T* elem;   // 元素
    int sz;    // 元素个数
};
```
这种“向量”根本不是用作基类的。

##### 实施
* 标记出有虚拟函数但没有派生类的类。
* 标记出所有成员函数都是虚拟而且有实现的类。

### C.133: 避免`protected`数据
##### 理由
`protected`数据是复杂度和错误的来源。`protected`数据使不变式语句复杂化。`protected`数据本质上违反了不要把数据放在基类中的指导，而这通常会导致必须同时处理虚拟继承。

##### 示例，不好的
```cpp
class Shape {
public:
    // ... 接口函数 ...
protected:
    // 在派生类中使用的数据
    Color fill_color;
    Color edge_color;
    Style st;
};
```
现在每个派生的`Shape`都要正确地维护受保护数据。这种做法很受欢迎，但同时也是维护问题的主要来源。在大型的类层次结构中，经常使用受保护数据会难以维护，因为这会让很多代码散布在很多类中。可以接触那些数据的类集合是开放的：任何人都可以派生一个新的类，然后开始操作受保护数据。通常，不可能去检查完整的类集合，所以任何对类的表示的修改会变得不可行。受保护数据没有可保证的不变式；它更像是一系列全局变量。受保护数据实际上成为了庞大代码体中的全局数据。

##### 数据
受保护数据常常看起来很诱人，可以通过派生来进行任意改进。通常，你得到的是无原则的修改和错误。优先使用`private`数据，这些数据具有良好的说明和可保证的不变式。另一个通常更好的方法是，不要在作为接口使用的类中定义数据。

##### 注意
受保护的成员函数是没有问题的。

##### 实施
标记出拥有`protected`数据的类。

### C.134: 保证所有非`const`数据成员有相同的访问级别
##### 理由
防止逻辑上的困惑导致出现错误。如果非`const`数据成员没有相同的访问级别，这个类型试图要做什么是令人困惑的。这个类型维护了一个不变式还是简单地作为值的集合？

##### 讨论
核心的问题是：什么代码负责维护变量有意义的/正确的值？

有两种确切的数据成员：
* A: 不参与对象不变式的成员。这些成员的任何组合值都是有效的。
* B: 参与对象不变式的成员。并非所有组合值都是有意义的（否则就不会存在不变式）。因此所有对这些变量拥有写入访问的代码必须知道它们的不变式，知道它们的语义，以及知道（并且主动实现和保证）保持值正确的规则。

在分类A的数据成员应该只是`public`的（或者，更少见的，如果你只想派生类看到它们，使用`protected`）。它们不需要封装。系统中的所有代码也可以看到和维护它们。

在分类B中的数据成员应该是`private`或者`const`的。这是因为封装是重要的。使它们为非`private`和非`const`意味着对象不能控制它自己的状态：在类之外的无限制数量的代码需要知道不变式的存在并且参与正确地维护它——如果这些数据成员是`public`的，那么这会是所有使用了该对象的调用代码；如果它们是`protected`的，那么这会是所有现在以及将来的派生类的代码。这会导致脆弱和紧耦合的代码，很快会变成维护噩梦。任何不经意把数据成员设置成无效或者意外组合值的代码，会使对象以及所有对该对象的后续使用产生错乱。

大部分类要么都是A或者要么都是B：
* 全部公有：如果你正在写一个聚合的变量捆绑类，在这些变量之间不需要不变式，那么所有变量应该为`public`。为了方便，把这些类声明成`struct`而不是`class`。
* 全部私有：如果你正在写的类型维护了一个不变式，那么所有非`const`变量应该是私有的——它们应该被封装起来。

##### 例外
在个别情况下，类会混合A和B，通常是为了调试的原因。被封装的对象可能会包含一些类似非`const`的调试数据，它不是不变式的一部分因此落入分类A——它真的不是对象值的一部分，或者有意义的可观察状态。在这种情况下，属于A的部分应该当做A来看待（定义成`public`，或者在少数情况下，如果它们应该只对派生类可见，定义成`protected`），而属于B的部分应该仍然当做B来看待（`private`或者`const`）。

##### 实施
标记出任何有非`const`数据成员，而且它们的访问级别不一样的类。

### C.135: 使用多重继承来表示多个不同的接口
##### 理由
并非所有类都有必要支持全部接口，而且不是所有调用者都有必要处理所有操作。特别是将庞大的接口拆分成由指定派生类支持的多个“方面”的行为。

##### 示例
```cpp
class iostream : public istream, public ostream {   // 非常简单
    // ...
};
```
`istream`提供了输入操作的接口；`ostream`提供了输出操作的接口。`iostream`提供了`istream`和`ostream`接口的结合，以及在单个流上允许两种操作的同步需求。

##### 注意
这是继承非常常见的用法，因为多个不同接口和实现的需求很常见，而且这种接口通常不容易或者自然地组织成单个根节点的层次结构。

##### 注意
这些接口通常是抽象类。

##### 实施
???

### C.136: 使用多重继承来表示实现属性的合并
##### 理由
一些形式的混合类型拥有状态，而且通常会在这个状态上进行操作。如果操作是虚拟的，那么继承的使用是必需的，如果不是，那么使用继承可以避免样板和转发。

##### 示例
```cpp
class iostream : public istream, public ostream {   // 非常简单
    // ...
};
```
`istream`为输入操作（和一些数据）提供了接口；`ostream`为输出操作（和一些数据）提供了接口。`iostream`提供了`istream`和`ostream`接口的结合，以及在单个流上允许两种操作的同步需求。

##### 注意
这是一种相对少见的用法，因为实现通常可以组织成一个单个根节点的层次结构。

##### 示例
有时候，“实现属性”更像是一个“混合类型”，它决定了实现的操作，并且注入成员来启用它所需要的策略的实现。例如，参考`std::enable_shared_from_this`或者来自boost.instrusive的不同基类（例如`list_base_hook`或者`instrusive_ref_counter`）。

##### 实施
???

### C.137: 使用`virtual`基类来避免过于通用的基类
##### 理由
允许分开共享的数据和接口。避免所有共享的数据都放进一个终极基类中。

##### 示例
```cpp
struct Interface {
    virtual void f();
    virtual int g();
    // ... 这里没有数据 ...
};

class Utility {  // 有数据
    void utility1();
    virtual void utility2();    // 允许自定义的点
public:
    int x;
    int y;
};

class Derive1 : public Interface, virtual protected Utility {
    // 覆写接口函数
    // 可能覆写Utility的虚拟函数
    // ...
};

class Derive2 : public Interface, virtual protected Utility {
    // 覆写接口函数
    // 可能覆写Utility的虚拟函数
    // ...
};
```
如果许多派生类共享重要的“实现细节”，把`Utility`重构出来是合理的。

##### 注意
显然，这里的例子过于“理论化”，但找到一个小型的真实例子很困难。`Interface`是一个接口层次结构的根节点，而`Utility`是一个实现层次结构的根节点。这里有一个带有解释的稍微更真实的例子。

##### 注意
通常，层次结构的线性化是更好的解决方法。

##### 实施
标记出混合了接口和实现的层次结构。

### C.138: 使用`using`为派生类和它的基类创建重载集合
##### 理由
如果没有使用using声明，在派生类中的成员函数会隐藏掉全部继承下来的重载集合。

##### 示例，不好的
```cpp
#include <iostream>
class B {
public:
    virtual int f(int i) { std::cout << "f(int): "; return i; }
    virtual double f(double d) { std::cout << "f(double): "; return d; }
};
class D: public B {
public:
    int f(int i) override { std::cout << "f(int): "; return i + 1; }
};
int main()
{
    D d;
    std::cout << d.f(2) << '\n';   // 输出 "f(int): 3"
    std::cout << d.f(2.3) << '\n'; // 输出 "f(int): 3"
}
```

##### 示例，好的
```cpp
class D: public B {
public:
    int f(int i) override { std::cout << "f(int): "; return i + 1; }
    using B::f; // 暴露 f(double)
};
```

##### 注意
这个问题同时影响到虚拟和非虚拟成员函数。

对于可变个数的基类，C++17引入了一个using声明的可变个数形式：
```cpp
template <class... Ts>
struct Overloader : Ts... {
    using Ts::operator()...; // 从每个基类暴露 operator()
};
```

##### 实施
诊断名称隐藏。

### C.139: 保守地使用`final`
##### 理由
为了逻辑原因用`final`封锁层次结构是很罕见的需求，并且会损害层次结构的可扩展性。

##### 示例，不好的
```cpp
class Widget { /* ... */ };

// 没有人会想去改善My_widget（或者是你认为的）
class My_widget final : public Widget { /* ... */ };

class My_improved_widget : public My_widget { /* ... */ };  // 错误：不能这样做
```

##### 注意
不是每个类都要成为基类。大多数标准库的类是这方面的例子（例如，`std::vector`和`std::string`并非设计用来派生的）。这个准则是关于在带有虚拟函数的类上使用`final`，这些类是要成为类层次结构中的接口。

##### 注意
用`final`封锁一个单独的虚拟函数是容易出错的，因为在定义/覆写一系列函数的时候，`final`会容易被看漏。幸运的是，编译器会捕捉到这类错误：你不能在派生类中重新声明/重新打开一个`final`成员。

##### 注意
从`final`得到性能提升的说法应该要去证实。这种说法往往基于推测或者其它语言的经验。

有些例子可以说明`final`在逻辑和性能原因上都是重要的。一个例子是，在编译器或者语言分析工具中的一个性能攸关的AST层次结构。新的派生类并不是经常添加，而且只能由库的实现来添加。然而，错误的使用（或者至少）更加常见。

##### 实施
标记出`final`的使用。

### C.140: 不要为虚拟函数和它的覆写函数提供不同的默认参数
##### 理由
这样会导致困惑：覆写函数不能继承默认参数。

##### 示例，不好的
```cpp
class Base {
public:
    virtual int multiply(int value, int factor = 2) = 0;
};

class Derived : public Base {
public:
    int multiply(int value, int factor = 10) override;
};

Derived d;
Base& b = d;

b.multiply(10);  // 这两个调用会调用相同的函数，但是用不同的参数，
d.multiply(10);  // 因此会产生不同的结果。
```

##### 实施
标记出虚拟函数上的默认参数，如果它们在基类和派生类声明中不一样的话。

## C.hier-access: 访问层次结构中的对象
### C.145: 通过指针和引用访问多态对象
##### 理由
如果你有一个带有虚拟函数的类，你（一般）不知道是哪个类提供了要使用的函数。

##### 示例
```cpp
struct B { int a; virtual int f(); };
struct D : B { int b; int f() override; };

void use(B b)
{
    D d;
    B b2 = d;   // 切割
    B b3 = b;
}

void use2()
{
    D d;
    use(d);   // 切割
}
```
两个`d`都被切割了。

##### 例外
你可以在对象的定义范围内安全地访问一个具名的多态对象，而不会导致它被切割。
```cpp
void use3()
{
    D d;
    d.f();   // 没问题
}
```

##### 实施
标记出所有对象切割。

### C.146: 当类层次结构的类型访问不可避免时，使用`dynamic_cast`
##### 理由
`dynamic_cast`是在运行时检查的。

##### 示例
```cpp
struct B {   // 一个接口
    virtual void f();
    virtual void g();
};

struct D : B {   // 一个更大的接口
    void f() override;
    virtual void h();
};

void user(B* pb)
{
    if (D* pd = dynamic_cast<D*>(pb)) {
        // ... 使用D的接口 ...
    }
    else {
        // ... 使用B的接口 ...
    }
}
```
使用其它的转型会违反类型安全，并且会导致程序在访问一个实际类型为`X`的变量时，它会被当作一个不相关的类型`Z`来访问：
```cpp
void user2(B* pb)   // 糟糕的
{
    D* pd = static_cast<D*>(pb);    // 我知道pb实际上指向的是D；相信我
    // ... 使用D的接口 ...
}

void user3(B* pb)    // 不安全
{
    if (some_condition) {
        D* pd = static_cast<D*>(pb);   // 我知道pb实际上指向的是D；相信我
        // ... 使用D的接口 ...
    }
    else {
        // ... 使用B的接口 ...
    }
}

void f()
{
    B b;
    user(&b);   // 没问题
    user2(&b);  // 糟糕的错误
    user3(&b);  // 没问题，*如果*程序员对some_condition的检查是正确的话
}
```

##### 注意
像其它转型一样，`dynamic_cast`被过度使用。应优先使用虚拟函数做转型。应优先使用静态的多态性而不是层次结构浏览，当它是可能的（没必要做运行时解析）并且合理方便的时候。

##### 注意
在使用`typeid`更合适的时候，有些人却会使用`dynamic_cast`；`dynamic_cast`是通用的“是一种”的操作，来发现一个对象上最适合的接口，然而`typeid`是“给我这个对象的准确类型”的操作，来发现一个对象的实际类型。后者是一个从内部来说更简单的操作，因而会更快。后者（`typeid`）在必要时是很容易手工实现的（例如，在一个由于某些原因禁止了RTTI的系统上工作），而前者（`dynamic_cast`）通常更加难以正确地实现。

考虑以下代码：
```cpp
struct B {
    const char* name {"B"};
    // 如果pb1->id() == pb2->id()， *pb1与*pb2有相同的类型
    virtual const char* id() const { return name; }
    // ...
};

struct D : B {
    const char* name {"D"};
    const char* id() const override { return name; }
    // ...
};

void use()
{
    B* pb1 = new B;
    B* pb2 = new D;

    cout << pb1->id(); // "B"
    cout << pb2->id(); // "D"


    if (pb1->id() == "D") {         // 看起来没有坏处
        D* pd = static_cast<D*>(pb1);
        // ...
    }
    // ...
}
```
`pb2->id() == "D"`的结果实际上是由实现定义的。我们把它加入到了home-brew RTTI的危险警告中。这个代码可能符合预期地执行了多年，只在那些不会统一字符字面量的新机器、新编译器、或者新链接器上失败。

如果你要实现你自己的RTTI，要小心。

##### 例外
如果你使用的实现提供了一个确实很慢的`dynamic_cast`，你可能不得不使用变通的方法。然而，所有不能被静态解析的变通方法都要调用显式的转型（通常是`static_cast`），并且是容易出错的。基本上你要制作你自己的特殊目的的`dynamic_cast`。因此，首先要确保你的`dynamic_cast`确实与你认为的一样慢（有相当数量的关于这方面的不被支持的谣言），而且你使用`dynamic_cast`的地方确实是性能攸关的。

我们认为目前`dynamic_cast`的实现是不必要的慢。例如，在适当的条件下，是有可能在快速常量时间内执行一次`dynamic_cast`的。然而，即使所有人都认为进行优化的努力是值得的，但兼容性问题使得这个改变很困难。

在很少见的情况下，如果你已经测量过`dynamic_cast`的开销是重要的，你有其它方法来静态地保证向下转型会成功（例如，你正在小心地使用CRTP），并且没有虚拟继承被调用，可以考虑有策略地使用`static_cast`，同时写上一段显眼的注释和总结这个段落的免责声明，这样在维护的时候人们需要注意，因为类型系统不能保证正确性。即使是这样，在我们的经验中，这种“我知道我在做什么”的情况仍然是已知的缺陷来源。

##### 例外
考虑以下代码：
```cpp
template<typename B>
class Dx : B {
    // ...
};
```

##### 实施
* 标记出所有用`static_cast`的向下转型，包括会执行`static_cast`的C风格转型。
* 这个准则是类型安全性简介的一部分。

### C.147: 当不能找到所需的类视为错误时，在引用类型上使用`dynamic_cast`
##### 理由
在一个你期望得到有效对象的引用表达式上转型，这个转型必须成功。`dynamic_cast`会在不成功的时候抛出异常。

##### 示例
```cpp
???
```

##### 实施
???

### C.148: 当不能找到所需的类视为有效的可选状态时，在指针类型上使用`dynamic_cast`
##### 理由
`dynamic_cast`转换允许检测一个指针是否指向一个在层次结构中指定类的多态对象。由于在找不到类的情况下仅仅返回一个空值，它可以在运行时进行测试。这样可以写出依赖返回值选择分支路径的代码。

与C.147不同的是，它的失败是一个错误，不应该用在条件式执行上。

##### 示例
下面的例子描述了`Shape_owner`的`add`方法，该方法接管了已构造对象`Shape`的所有权。根据它们的几何属性，这些对象也会在不同视图中排序。在这个示例中，`Shape`没有继承于`Geometric_attributes`。只有它的子类会。
```cpp
void add(Shape* const item)
{
  // 所有权总是被接管
  owned_shapes.emplace_back(item);

  // 检查Geometric_attributes，然后把shape添加到零个/一个/几个/全部视图中

  if (auto even = dynamic_cast<Even_sided*>(item))
  {
    view_of_evens.emplace_back(even);
  }

  if (auto trisym = dynamic_cast<Trilaterally_symmetrical*>(item))
  {
    view_of_trisyms.emplace_back(trisym);
  }
}
```

##### 注意
找不到需要的类会导致`dynamic_cast`返回一个空值，而且解引用一个空值的指针会导致未定义行为。因此`dynamic_cast`的结果应该总是认为可能会包含空值，并且要去检查。

##### 实施
* （复杂）除非在指针类型上的`dynamic_cast`已经有对结果进行空值检查，否则对指针上的解引用发出警告。

### C.149: 使用`unique_ptr`或`shared_ptr`来避免忘记用`delete`删除由`new`创建的对象
##### 理由
避免资源泄露。

##### 示例
```cpp
void use(int i)
{
    auto p = new int {7};           // 糟糕：用new初始化局部指针
    auto q = make_unique<int>(9);   // 没问题：保证释放用内存分配的9
    if (0 < i) return;              // 可能在这里返回并导致泄露
    delete p;                       // 太晚了
}
```

##### 实施
* 标记出用`new`的结果初始化的裸露指针。
* 标记出作用在局部变量上的`delete`。

### C.150: 使用`make_unique()`来构造由`unique_ptr`持有的对象
##### 理由
`make_unique`提供了更简洁的构造语句。它也确保了在复杂表达式中的异常安全性。

##### 示例
```cpp
unique_ptr<Foo> p {new<Foo>{7}};   // 没问题：但是重复

auto q = make_unique<Foo>(7);      // 好多了：没有重复Foo

// 不是异常安全的：编译器可能会把参数的计算按以下方式打乱：
//
// 1. 为Foo分配内存，
// 2. 构造Foo，
// 3. 调用bar，
// 4. 构造unique_ptr<Foo>。
//
// 如果bar抛出异常，Foo不会被销毁，为它分配的内存会泄露。
f(unique_ptr<Foo>(new Foo()), bar());

// 异常安全地：调用函数永远不会被打乱。
f(make_unique<Foo>(), bar());
```

##### 实施
* 标记出模板特化列表`<Foo>`的重复使用。
* 标记出声明为`unique_ptr<Foo>`的变量。

### C.151: 使用`make_shared()`来构造由`shared_ptr`持有的对象
##### 理由
`make_shared`提供了更简洁的构造语句。它也提供了一个机会来消除为引用计数的单独分配，通过把`shared_ptr`的使用计数放到它指向的对象旁边来达到这个目的。

##### 示例
```cpp
void test() {
    // 没问题：但是重复；而且Bar和shared_ptr的使用计数是单独分配的
    shared_ptr<Bar> p {new<Bar>{7}};

    auto q = make_shared<Bar>(7);   // 好多了：没有重复Bar；只有一个对象
}
```

##### 实施
* 标记出模板特化列表`<Bar>`的重复使用。
* 标记出声明为`shared_ptr<Bar>`的变量。

### C.152: 永不将指向派生类对象数组的指针赋值给指向其基类的指针
##### 理由
对这样的基类指针执行下标操作会导致无效的对象访问，并且可能导致内存损坏。

##### 示例
```cpp
struct B { int x; };
struct D : B { int y; };

void use(B*);

D a[] = {{1, 2}, {3, 4}, {5, 6}};
B* p = a;     // 糟糕的：衰变成&a[0]，同时转换成B*
p[1].x = 7;   // 覆写了D[0].y

use(a);       // 糟糕的：衰变成&a[0]，同时转换成B*
```

##### 实施
* 标记出所有数组衰变和基类到派生类转换的组合。
* 通过`span`传递数组而不是通过指针，并且在生成`span`之前不要让数组的名称遭受派生类到基类的转换。

### C.153: 优先使用虚拟函数而不是类型转换
##### 理由
虚拟函数的调用是安全地，而类型转换容易出错。虚拟函数调用会到达最底层的派生函数，而类型转换可能会到达一个中间的类，因而会得到错误的结果（特别是在维护的过程中层次结构被修改）。

##### 示例
```cpp
???
```

##### 实施
参阅C.146和???

## C.over: 重载和重载操作符
你可以重载普通函数、模板函数和操作符。你不能重载函数对象。

重载准则概要：
* C.160: 定义操作符来主要地模拟习惯用法
* C.161: 对于对称操作符使用非成员函数
* C.162: 重载严格相等的操作
* C.163: 只重载严格相等的操作
* C.164: 避免使用转换操作符
* C.165: 为自定义的扩展点使用`using`
* C.166: 只重载一元的`&`作为智能指针和引用系统的一部分
* C.167: 以操作符的惯用含义执行操作
* C.168: 在操作数的名称空间中定义重载操作符
* C.170: 如果你想重载lambda，使用泛型lambda

### C.160: 定义操作符来主要地模拟习惯用法
##### 理由
最小化意料之外的事情。

##### 示例
```cpp
class X {
public:
    // ...
    X& operator=(const X&); // 定义为成员函数的赋值
    friend bool operator==(const X&, const X&); // == 需要访问内部表示
                                                // 执行了 a = b 之后我们有 a == b
    // ...
};
```
这里，维持了惯用的语义：拷贝、比较和相等。

##### 示例，糟糕的
```cpp
X operator+(X a, X b) { return a.v - b.v; }   // 糟糕的：使 + 做减法
```

##### 注意
非成员操作符应该是友元，或者定义在与操作数相同的名称空间内。二元操作符应该同等地对待它们的操作数。

##### 实施
大概是不可能的。

### C.161: 对于对称的操作符使用非成员函数
##### 理由
如果你使用了成员函数，你需要两个。除非你为（举例）`==`使用了非成员函数，否则`a == b`和`b == a`会有微妙的差别。

##### 示例
```cpp
bool operator==(Point a, Point b) { return a.x == b.x && a.y == b.y; }
```

##### 实施
标记出成员操作符函数。

### C.162: 重载严格相等的操作
##### 理由
逻辑上相等的操作在不同参数类型上有不同名字是令人困惑的，会导致在函数名称中编码类型信息，而且会妨碍泛型编程。

##### 示例
考虑以下代码：
```cpp
void print(int a);
void print(int a, int base);
void print(const string&);
````
这三个函数都会（合适地）打印出它们的参数。相反：
```cpp
void print_int(int a);
void print_based(int a, int base);
void print_string(const string&);
```
这三个函数都会（合适地）打印出它们的参数。往名称中添加只会引入冗余并且妨碍泛型代码。

##### 实施
???

### C.163: 只重载严格相等的操作
##### 理由
逻辑上不同的函数有相同的名字是令人困惑的，并且在使用泛型编程的时候会导致错误。

##### 示例
考虑以下代码：
```cpp
void open_gate(Gate& g);   // 从车库的出口通道移除障碍
void fopen(const char* name, const char* mode);   // 打开文件
```
这两个操作基本上是不同的（而且也不相关），因此它们的名称不一样是准确的。相反：
```cpp
void open(Gate& g);   // 从车库的出口通道移除障碍
void open(const char* name, const char* mode ="r");   // 打开文件
```
这两个操作基本上仍然是不同的（而且也不相关），但它们的名称缩减到它们（共同）的最少量，敞开了令人困惑的机会。幸运的是，类型系统会捕捉到很多这种错误。

##### 注意
要特别注意通用和常见的名称，例如`open`、`move`、`+`和`==`。

##### 实施
???

### C.164: 避免转换操作符
##### 理由
隐式转换可能是必要的（例如`double`到`int`），但通常会导致意料之外的情况（例如`String`到C风格字符串）。

##### 注意
应优先使用显式的具名转换，直到重要的需求表露出来。“重要的需求”是指在应用程序领域中很基础（例如整数到复数的转换）并且被频繁的需要的原因。不要仅仅为了得到一点便利而引入隐式转换。

##### 示例，不好的
```cpp
class String {   // 处理所有权，以及访问字符序列
    // ...
    String(czstring p); // 从 *p 拷贝到 *(this->elem)
    // ...
    operator zstring() { return elem; }
    // ...
};

void user(zstring p)
{
    if (*p == "") {
        String s {"Trouble ahead!"};
        // ...
        p = s;
    }
    // 使用 p
}
```
分配给`s`并且赋值给`p`的字符串在使用之前就被销毁了。

##### 实施
标记出所有转换操作符。

### C.165: 为自定义的扩展点使用`using`
##### 理由
查找定义在另一个名称空间中的函数对象和函数，来“自定义”一个通用的函数。

##### 示例
考虑`swap`。这是一个通用的（标准库）函数，它被定义成可以作用于任何类型。然而，对于特定的类型，它需要为其定义特定的`swap()`函数。例如，通用的`swap()`会拷贝两个被交换的`vector`中的元素，而一个好的特定实现根本不会拷贝元素。
```cpp
namespace N {
    My_type X { /* ... */ };
    void swap(X&, X&);   // 为N::X的交换进行过优化
    // ...
}

void f1(N::X& a, N::X& b)
{
    std::swap(a, b);   // 很可能不是我们想要的：调用std::swap()
}
```
`f1()`中的`std::swap()`准确地做了我们要求做的事情：它调用了`std`名称空间中的`swap()`。不幸的是，这很可能不是我们想要的。我们该如何让`N::X`被考虑进来呢？
```cpp
void f2(N::X& a, N::X& b)
{
    swap(a, b);   // 调用N::swap
}
```
但这可能不是我们在泛型代码中想要的。在那里，我们通常想在特定函数存在的时候使用它，不存在的时候使用通用函数。通过在函数的查找域中包含通用函数，即可达到这个目的：
```cpp
void f3(N::X& a, N::X& b)
{
    using std::swap;  // 使std::swap可用
    swap(a, b);       // 如果N::swap存在的话调用它，否则调用std::swap
}
```

##### 实施
不太可能，除了已知的自定义扩展点，例如`swap`。这里的问题是未限定的和限定的查找域会同时使用。

### C.166: 只重载一元的`&`作为智能指针和引用系统的一部分
##### 理由
`&`操作符在C++是基本的。C++语义的很多部分会假定它是默认的含义。

##### 示例
```cpp
class Ptr { // 某种智能指针
    Ptr(X* pp) :p(pp) { /* 检查 */ }
    X* operator->() { /* 检查 */ return p; }
    X operator[](int i);
    X operator*();
private:
    T* p;
};

class X {
    Ptr operator&() { return Ptr{this}; }
    // ...
};
```

##### 注意
如果你“搞混”了`&`操作符，要确保它的定义与`->`、`[]`和`.`在结果类型上有匹配的含义。要注意`.`操作符目前不能被重载，所以完美的系统是不可能存在的。我们希望弥补这个问题：http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4477.pdf。要注意`std::addressof()`总是产出一个内置指针。

##### 实施
棘手的。如果`&`是用户定义的，而且没有同时为结果类型定义`->`，发出警告。

### C.167: 以操作符的惯用含义执行操作
##### 理由
可读性。符合习惯。可复用性。支持泛型代码。

##### 示例
```cpp
void cout_my_class(const My_class& c) // 令人困惑的，非习惯用法，非泛型代码
{
    std::cout << /* 类成员在这里 */;
}

std::ostream& operator<<(std::ostream& os, const my_class& c) // 没问题
{
    return os << /* 类成员在这里 */;
}
```
对它自己来说，`count_my_class`是没问题的，但对于那些依赖`<<`作为惯用输出方式的代码，它并非可用/可组合的：
```cpp
My_class var { /* ... */ };
// ...
cout << "var = " << var << '\n';
```

##### 注意
大部分操作符有强烈且有力的惯用含义，例如
* 比较（`==`、`!=`、`<`、`<=`、`>`和`>=`）
* 算术操作（`+`、`-`、`*`、`/`和`%`）
* 访问操作（`.`、`->`、一元`*`和`[]`）
* 赋值（`=`）
不要定义那些不符合习惯的，也不要为它们发明你自己的名称。

##### 实施
棘手的。需要洞察出语义。

### C.168: 在操作数的名称空间中定义重载操作符
##### 理由
可读性。具有使用ADL查找操作符的能力。避免在不同的名称空间中有不一致的定义。

##### 示例
```cpp
struct S { };
bool operator==(S, S);   // 没问题：在与S相同的名称空间中，甚至就在S的旁边
S s;

bool x = (s == s);
```
这是`==`默认要做的，如果我们需要这种默认的话。

##### 示例
```cpp
namespace N {
    struct S { };
    bool operator==(S, S);   // 没问题：在与S相同的名称空间中，甚至就在S的旁边
}

N::S s;

bool x = (s == s);  // 通过ADL找到 N::operator==()
```

##### 示例，不好的
```cpp
struct S { };
S s;

namespace N {
    S::operator!(S a) { return true; }
    S not_s = !s;
}

namespace M {
    S::operator!(S a) { return false; }
    S not_s = !s;
}
```
这里，`!s`的含义在`N`和`M`中不一样。这会非常令人困惑的。移除了`namespace M`的定义后，这个困惑会变成制造错误的机会。

##### 注意
如果一个二元操作符是为两个在不同名称空间中的类型定义的，你不能遵守这个准则。例如：
```cpp
Vec::Vector operator*(const Vec::Vector&, const Mat::Matrix&);
```
这种东西可能最好要避免。

##### 另见
这是“辅助函数应该与它们的类定义在相同名称空间中”的特殊情况。

##### 实施
* 标记出不在操作数所在名称空间中的操作符定义。

### C.170: 如果你想重载lambda，使用泛型lambda
##### 理由
你不能用相同的名称定义两个不同的lambda来进行重载。

##### 示例
```cpp
void f(int);
void f(double);
auto f = [](char);   // 错误：不能重载变量和函数

auto g = [](int) { /* ... */ };
auto g = [](double) { /* ... */ };   // 错误：不能重载变量

auto h = [](auto) { /* ... */ };   // 没问题
```

##### 实施
编译器会捕捉试图重载lambda的错误。

## C.union: 联合体
`union`是一个`struct`，它的所有成员都在同一个地址开始，因此在同一时刻它只能持有一个成员。`union`不会记录保存了哪个成员，所以程序员必须要正确地处理；这是本质上容易出错的，但有方法去弥补。

由一个`union`加上一个指示当前持有的是哪个成员的指示符组成的类型称为标签联合体、可区分联合体或者变体。

联合体准则概要：
* C.180: 使用`union`来节省内存
* C.181: 避免“裸露”的`union`
* C.182: 使用匿名的`union`来实现标签联合体
* C.183: 不要使用`union`作为类型双关语
* ???

### C.180: 使用`union`来节省内存
##### 理由
`union`允许一块内存在不同时刻用于不同类型的对象。因此，当我们有多个从来不会同时使用的对象时，它可以用来节省内存。

##### 示例
```cpp
union Value {
    int x;
    double d;
};

Value v = { 123 };  // 现在v持有一个int
cout << v.x << '\n';    // 写入123
v.d = 987.654;  // 现在v持有一个double
cout << v.d << '\n';    // 写入987.654
```
不过要留意这个警告：避免“裸露”的`union`。

##### 示例
```cpp
// 短字符串优化

constexpr size_t buffer_size = 16; // 稍微比指针的大小大一点

class Immutable_string {
public:
    Immutable_string(const char* str) :
        size(strlen(str))
    {
        if (size < buffer_size)
            strcpy_s(string_buffer, buffer_size, str);
        else {
            string_ptr = new char[size + 1];
            strcpy_s(string_ptr, size + 1, str);
        }
    }

    ~Immutable_string()
    {
        if (size >= buffer_size)
            delete string_ptr;
    }

    const char* get_str() const
    {
        return (size < buffer_size) ? string_buffer : string_ptr;
    }

private:
    // 如果字符串足够短，我们保存字符串本身，而不是保存字符串的指针。
    union {
        char* string_ptr;
        char string_buffer[buffer_size];
    };

    const size_t size;
};
```

##### 实施
???

### C.181: 避免“裸露”的`union`
##### 理由
裸露的联合体没有一个关联的指示符来指示它持有哪个成员（如果有的话），所以程序员必须自己来跟踪。裸露联合体是类型错误的来源。

##### 示例，不好的
```cpp
union Value {
    int x;
    double d;
};

Value v;
v.d = 987.654;  // v持有一个double
```
目前为止没什么问题，但我们会容易误用`union`：
```cpp
cout << v.x << '\n';    // 糟糕，未定义行为：v持有一个double，但我们把它当成int来读取
```
要注意，类型错误发生的时候没有任何显式的转换。当我们测试的时候，程序最后打印的值是`1683627180`，这是`987.654`在位模式下的整型值。在这里我们有一个“不可见”的类型错误，它发生时导致的结果很容易看起来是无害的。

而且，说到“不可见”，下面的代码没有产生输出：
```cpp
v.x = 123;
cout << v.d << '\n';    // 糟糕的：未定义行为
```

##### 替代方案
把`union`与一个类型字段一起包装在一个类中。

即将成为标准的`variant`类型（可以在`<variant>`中找到）为你做了这些事情：
```cpp
variant<int, double> v;
v = 123;        // v持有一个int
int x = get<int>(v);
v = 123.456;    // v持有一个double
w = get<double>(v);
```

##### 实施
???

### C.182: 使用匿名的`union`来实现标签联合体
##### 理由
设计良好的标签联合体是类型安全的。匿名的联合体简化了带有一对（标签，联合体）的类的定义。

##### 示例
这个例子大部分从TC++PL4 pp216-218借用过来。你可以看看那里的说明。

这里的代码有点精妙。处理具有用户定义的赋值和析构函数是棘手的。把程序员从必须写这些代码拯救出来是在标准中包含`variant`的一个原因。
```cpp
class Value { // 把两个可选的内部表示表示为一个联合体
private:
    enum class Tag { number, text };
    Tag type; // 用作区分判断

    union { // 内部表示（注意：匿名联合体）
        int i;
        string s; // string有默认构造函数、拷贝构造函数和析构函数
    };
public:
    struct Bad_entry { }; // 用于异常

    ~Value();
    Value& operator=(const Value&);   // 必需的，因为有string变量
    Value(const Value&);
    // ...
    int number() const;
    string text() const;

    void set_number(int n);
    void set_text(const string&);
    // ...
};

int Value::number() const
{
    if (type != Tag::number) throw Bad_entry{};
    return i;
}

string Value::text() const
{
    if (type != Tag::text) throw Bad_entry{};
    return s;
}

void Value::set_number(int n)
{
    if (type == Tag::text) {
        s.~string();      // 显式销毁string
        type = Tag::number;
    }
    i = n;
}

void Value::set_text(const string& ss)
{
    if (type == Tag::text)
        s = ss;
    else {
        new(&s) string{ss};   // placement new：显式构造string
        type = Tag::text;
    }
}

Value& Value::operator=(const Value& e)   // 必需的，因为有string变量
{
    if (type == Tag::text && e.type == Tag::text) {
        s = e.s;    // 普通的字符串赋值
        return *this;
    }

    if (type == Tag::text) s.~string(); // 显式销毁

    switch (e.type) {
    case Tag::number:
        i = e.i;
        break;
    case Tag::text:
        new(&s)(e.s);   // placement new：显式构造
        type = e.type;
    }

    return *this;
}

Value::~Value()
{
    if (type == Tag::text) s.~string(); // 显式销毁
}
```

##### 实施
???

### C.183: 不要使用`union`作为类型双关语
##### 理由
以不同的类型分别读取和写入`union`成员是未定义行为。这种双关语是不可见的，或者至少比使用具名的转换更难发现。使用`union`作为类型双关语是错误的来源。

##### 示例，不好的
```cpp
union Pun {
    int x;
    unsigned char c[sizeof(int)];
};
```
`Pun`的意图是能够查看一个`int`的字符表示。
```cpp
void bad(Pun& u)
{
    u.x = 'x';
    cout << u.c[0] << '\n';     // 未定义行为
}
```
如果你想看看`int`的字节，使用（具名的）转换：
```cpp
void if_you_must_pun(int& x)
{
    auto p = reinterpret_cast<unsigned char*>(&x);
    cout << p[0] << '\n';     // 没问题；好多了
    // ...
}
```
使用`reinterpret_cast`将对象转换成与其声明类型不同的类型，并且访问它的结果是已定义的行为（即使不鼓励使用`reinterpret_cast`），但是至少我们可以看到一些诡异的事情在发生。

##### 注意
不幸的是，`union`通常用做类型双关语。我们不认为“有时候它会如预期执行”是一个强力的论据。

C++17引入了一个不同的类型`std:byte`来促进在原始对象表示上的操作。为这些操作使用该类型来代替`unsigned char`或`char`。

##### 实施
???

## Enum: 枚举
枚举用于定义整型数值的集合，同时为这些值的集合定义类型。枚举有两种类型，“纯”`enum`和`class enum`。

枚举准则概要：
* Enum.1: 优先使用枚举而不是宏
* Enum.2: 使用枚举来表示相关的具名常量集合
* Enum.3: 优先使用`enum class`而不是“纯”`enum`
* Enum.4: 为了安全和简易使用，在枚举上定义操作
* Enum.5: 不要为枚举值使用`ALL_CAPS`名称
* Enum.6: 避免没有名称的枚举
* Enum.7: 只在必要的时候指定枚举的基础类型
* Enum.8: 只在必要的时候指定枚举值

### Enum.1: 优先使用枚举而不是宏
##### 理由
宏不遵守作用域和类型规则。而且，宏的名称在预处理期间会被移除，所以通常不会在比如调试器的工具中出现。

##### 示例
首先是一些糟糕的旧代码：
```cpp
// webcolors.h (第三方头文件)
#define RED   0xFF0000
#define GREEN 0x00FF00
#define BLUE  0x0000FF

// productinfo.h
// 下面基于颜色定义了产品的子类型
#define RED    0
#define PURPLE 1
#define BLUE   2

int webby = BLUE;   // webby == 2；可能不是预期的结果
```
使用`enum`来代替：
```cpp
enum class Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF };
enum class Product_info { red = 0, purple = 1, blue = 2 };

int webby = blue;   // 错误：要具体指定
Web_color webby = Web_color::blue;
```
我们使用`enum class`来避免名称冲突。

##### 实施
标记出定义了整型数值的宏。

### Enum.2: 使用枚举来表示相关的具名常量集合
##### 理由
枚举展示了有关联、并且可以成为具名类型的枚举值。

##### 示例
```cpp
enum class Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF };
```

##### 注意
把枚举用在`switch`语句中是很常见的，而且编译器会对不寻常的`case`标签模式发出警告。例如：
```cpp
enum class Product_info { red = 0, purple = 1, blue = 2 };

void print(Product_info inf)
{
    switch (inf) {
    case Product_info::red: cout << "red"; break;
    case Product_info::purple: cout << "purple"; break;
    }
}
```
这种缺少一个标签的`switch`语句往往是添加了枚举值并且没有充分测试的结果。

##### 实施
* 标记出在`case`中覆盖了一个枚举大部分但不是全部枚举值的`switch`语句。
* 标记出在`case`中覆盖了一个枚举少量枚举值，但是没有`default`的`switch`语句。

### Enum.3: 优先使用`enum class`而不是“纯”`enum`
##### 理由
最小化意外情况：传统的枚举太容易转换成整型。

##### 示例
```cpp
void Print_color(int color);

enum Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF };
enum Product_info { Red = 0, Purple = 1, Blue = 2 };

Web_color webby = Web_color::blue;

// 显然，这些调用中至少有一个存在问题。
Print_color(webby);
Print_color(Product_info::Blue);
```
使用`enum class`来代替：
```cpp
void Print_color(int color);

enum class Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF };
enum class Product_info { red = 0, purple = 1, blue = 2 };

Web_color webby = Web_color::blue;
Print_color(webby);  // 错误：不能将Web_color转换成int。
Print_color(Product_info::Red);  // 错误：不能将Product_info转换成int。
```

##### 实施
（简单）对任何非`enum class`定义发出警告。

### Enum.4: 为了安全和简易使用，在枚举上定义操作
##### 理由
便于使用，以及避免错误。

##### 示例
```cpp
enum Day { mon, tue, wed, thu, fri, sat, sun };

Day& operator++(Day& d)
{
    return d = (d == Day::sun) ? Day::mon : static_cast<Day>(static_cast<int>(d)+1);
}

Day today = Day::sat;
Day tomorrow = ++today;
```
使用`static_cast`并不好，但像下面那样：
```cpp
Day& operator++(Day& d)
{
    return d = (d == Day::sun) ? Day::mon : Day{++d};    // 错误
}
```
会是无穷的递归，而且假如不用转换，而是在所有分支上使用`switch`则太过冗长。

##### 实施
标记出把数值转换回枚举的重复表达式。

### Enum.5: 不要为枚举值使用`ALL_CAPS`名称
##### 理由
避免与宏冲突。

##### 示例，不好的
```cpp
 // webcolors.h（第三方头文件）
#define RED   0xFF0000
#define GREEN 0x00FF00
#define BLUE  0x0000FF

// productinfo.h
// 下面基于颜色定义产品的子类型
enum class Product_info { RED, PURPLE, BLUE };   // 语法错误
```

##### 实施
标记出所有带有`ALL_CAPS`名称的枚举。

### Enum.6: 避免没有名称的枚举
##### 理由
如果你不能为枚举命名，那么它的值是不相关的。

##### 示例，不好的
```cpp
enum { red = 0xFF0000, scale = 4, is_signed = 1 };
```
在有更方便的替代方法来指定整型常量之前，这种代码并不罕见。

##### 替代方法
使用`constexpr`值来代替。例如：
```cpp
constexpr int red = 0xFF0000;
constexpr short scale = 4;
constexpr bool is_signed = true;
```

##### 实施
标记出没有名称的枚举。

### Enum.7: 只在必要的时候指定枚举的基础类型
##### 理由
默认方式是最容易读和写的。`int`是默认的整型类型。`int`与C的`enum`兼容。

##### 示例
```cpp
enum class Direction : char { n, s, e, w,
                              ne, nw, se, sw };  // 指定基础类型来节省空间

enum class Web_color : int { red   = 0xFF0000,
                             green = 0x00FF00,
                             blue  = 0x0000FF };  // 指定基础类型是冗余的
```

##### 注意
在前置声明枚举的时候，指定基础类型是必要的：
```cpp
enum Flags : char;

void f(Flags);

// ....

enum flags : char { /* ... */ };
```

##### 实施
???

### Enum.8: 只在必要的时候指定枚举值
##### 理由
这是最简单的。它避免了重复的枚举值。默认的做法提供了连续值的集合，对`switch`语句的实现有好处。

##### 示例
```cpp
enum class Col1 { red, yellow, blue };
enum class Col2 { red = 1, yellow = 2, blue = 2 }; // 输入错误
enum class Month { jan = 1, feb, mar, apr, may, jun,
                   jul, august, sep, oct, nov, dec }; // 从1开始连续的
enum class Base_flag { dec = 1, oct = dec << 1, hex = dec << 2 }; // 位的集合
```
为了匹配惯用的值（例如`Month`），并且不希望使用连续值的时候（例如，像`Base_flag`那样获定义单独的位），指定枚举值是必要的。

##### 实施
* 标记出重复的枚举值。
* 标记出显式指定了所有连续值的枚举值。

## R: 资源管理
这部分包含与资源相关的准则。资源是任何必须获取以及（显式或隐式）释放的东西，例如内存、文件句柄、套接字和锁。资源必须释放的原因通常是由于它是短缺的，因此即便是延迟释放也会带来损害。这里基本的目标是要保证我们不会泄露任何资源，以及我们持有资源的时间不会比我们真正需要的长。负责释放资源的实体称为所有者。

有些情况下，泄露是可接受的，甚至是一种优化：如果你正在写一个程序，它单纯地基于输入来产生输出，而且所需的内存与输入的大小是成比例的，在这种情况下，优化策略（为了性能以及编程的便利）有时会简单地不删除任何东西。如果你有足够的内存来处理最大的输入，那就让它泄露，但要确保如果你做错了的话，会给出良好的错误信息。在这里，我们忽略这类情况。

* 资源管理准则概要：
	* R.1: 使用资源句柄和RAII（资源获取即初始化）自动地管理资源
	* R.2: 在接口中，（只）使用原始指针来指示单独的对象
	* R.3: 原始指针（`T*`）不具有所有权
	* R.4: 原始引用（`T&`）不具有所有权
	* R.5: 优先使用作用域对象，避免不必要的堆分配
	* R.6: 避免非`const`全局变量
* 分配的释放准则概要：
	* R.10: 避免`malloc()`和`free()`
	* R.11: 避免显式地调用`new`和`delete`
	* R.12: 立即把显式资源分配的结果赋予管理对象
	* R.13: 在单个表达式语句中至多执行一次显式资源分配
	* R.14: ??? 数组与指针参数
	* R.15: 总是重载配对的分配/释放
* 智能指针准则概要：
	* R.20: 使用`unique_ptr`或`shared_ptr`来表示所有权
	* R.21: 优先使用`unique_ptr`而不是`shared_ptr`，除非你需要共享所有权
	* R.22: 使用`make_shared()`来生成`shared_ptr`
	* R.23: 使用`make_unique()`来生成`unique_ptr`
	* R.24: 使用`std::weak_ptr`来破除`shared_ptr`的循环
	* R.30: 只有在显式表达生命周期语义的时候才使用智能指针作为参数
	* R.31: 如果你有不属于`std`的智能指针，遵守`std`中的基本模式
	* R.32: 使用`unique_ptr<widget>`作为参数，来表示函数要获取`widget`的所有权
	* R.33: 使用`unique_ptr<widget>&`作为参数，来表示函数要重设`widget`
	* R.34: 使用`shared_ptr<widget>`作为参数，来表示函数是部分所有者
	* R.35: 使用`shared_ptr<widget>&`作为参数，来表示函数可能会重设共享的指针
	* R.36: 使用`const shared_ptr<widget>&`作为参数，来表示函数可能会持有对象的引用计数???
	* R.37: 不要传递从别名智能指针获取的指针或引用

### R.1: 使用资源句柄和RAII（资源获取即初始化）自动地管理资源
##### 理由
避免泄露和手动管理资源的复杂性。C++语言保证执行的构造函数/析构函数的对称性与资源的获取/释放函数的对称性吻合，例如`fopen`/`fclose`、`lock`/`unlock`和`new`/`delete`。不论何时，当你要处理那些需要配对的获取/释放函数调用的资源时，把资源封装到对象中，让它为你确保执行了配对的函数——在它的构造函数中获取资源，然后在它的析构函数中释放资源。

##### 示例，不好的
考虑以下代码：
```cpp
void send(X* x, cstring_span destination)
{
    auto port = open_port(destination);
    my_mutex.lock();
    // ...
    send(port, x);
    // ...
    my_mutex.unlock();
    close_port(port);
    delete x;
}
```
在这里的代码中，你必须记住在所有路径上调用`unlock`、`close_port`和`delete`，而且每个函数只调用一次。另外，如果标记为`...`中的任意代码抛出了异常，那么`x`会被泄露，`my_mutex`会维持上锁状态。

##### 示例
考虑以下代码：
```cpp
void send(unique_ptr<X> x, cstring_span destination)  // x拥有X
{
    Port port{destination};            // port拥有PortHandle
    lock_guard<mutex> guard{my_mutex}; // guard拥有锁
    // ...
    send(port, x);
    // ...
} // 自动解锁my_mutex和删除x的指针
```
现在所有资源的清理都是自动的，在所有路径上都只执行一次，不管有没有发生异常。作为额外的好处，该函数现在声明了它会接管指针的所有权。

`Port`是什么？它是封装了资源的一个便利的包装类：
```cpp
class Port {
    PortHandle port;
public:
    Port(cstring_span destination) : port{open_port(destination)} { }
    ~Port() { close_port(port); }
    operator PortHandle() { return port; }

    // 端口句柄一般不能克隆，因此如果有必要的话禁用拷贝和赋值
    Port(const Port&) = delete;
    Port& operator=(const Port&) = delete;
};
```

##### 注意
当一个“表现不正常”的资源没有表示成具有析构函数的类时，把它包装到一个类中或者使用`finally`。

*另见*：RAII

### R.2: 在接口中，（只）使用原始指针来指示单独的对象
##### 理由
数组最好通过容器类型（例如`vector`（有所有权））或者`span`（无所有权）来表示。这类容器和视图持有足够的信息来做范围检查。

##### 示例，不好的
```cpp
void f(int* p, int n)   // n是p[]中元素的数量
{
    // ...
    p[2] = 7;   // 不好的：对原始指针取下标
    // ...
}
```
编译器不会阅读注释，而且没有阅读其它代码的话，你不知道`p`是否真的指向`n`个元素。应使用`span`来代替。

##### 示例
```cpp
void g(int* p, int fmt)   // 使用#fmt的格式打印*p
{
    // ... 只使用*p和p[0] ...
}
```

##### 例外
C风格的字符串用单个指向以零结尾的字符序列的指针来传递。使用`zstring`而不是`char*`来指示你依赖于这个约定。

##### 注意
目前许多指向单个元素的指针用法可以使用引用。然而，当`nullptr`是可能的取值时，引用也许不是合理的选择。

##### 实施
* 标记出作用于指针上的指针算术（包括`++`），该指针不是容器、视图或者迭代器的一部分。如果应用于老的代码库，该准则会生成大量错误。
* 标记出以单个指针传递的数组名称。

### R.3: 原始指针（`T*`）不具有所有权
##### 理由
（在C++标准或者在大部分代码中）不存在与这个说法不同的东西，而且大部分原始指针都是不拥有资源的。我们希望拥有资源的指针能够被辨识出来，因而我们可以可靠且有效地删除被所有者指针指向的对象。

##### 示例
```cpp
void f()
{
    int* p1 = new int{7};           // 不好的：原始的所有者指针
    auto p2 = make_unique<int>(7);  // 好的：int由唯一的指针所拥有
    // ...
}
```
`unique_ptr`通过保证对象的删除来防止泄露（即使在发生了异常的情况下）。而`T*`不能。

##### 示例
```cpp
template<typename T>
class X {
    // ...
public:
    T* p;   // 不好的：p是否具有所有权是不清晰的
    T* q;   // 不好的：q是否具有所有权是不清晰的
};
```
我们可以通过显式指定所有权来修复这个问题：
```cpp
template<typename T>
class X2 {
    // ...
public:
    owner<T*> p;  // 没问题：p具有所有权
    T* q;         // 没问题：q不具有所有权
};
```

##### 例外
一个主要的例外类别是遗留代码，特别是必须与C维持兼容的代码，或者通过ABI在C和C风格的C++之间维持兼容接口的代码。事实上，有数十亿行的代码违反了该准则关于`T*`的所有权，这些代码不能被忽略。我们喜于看到程序转换工具把20年历史的“遗留”代码转换成焕然一新的现代代码， 我们鼓励开发、部署以及使用这类工具，我们希望这些指南能帮助这类工具的开发，我们甚至收到在这个领域研究和开发的贡献（同时也主动贡献）。然而，这会消耗时间：“遗留代码”产生的速度快于我们翻新旧代码的速度，因此这将需要好几年时间。

这些代码不能全部重写（即使是假设在有好的代码转换软件的情况下），尤其是不能快速地重写。这个问题不能通过把全部所有者指针转换成`unique_ptr`和`shared_ptr`来（成规模地）解决，部分是因为在我们基础的资源句柄的实现中需要/使用具有所有权的“原始指针”以及简单指针。例如，常见的`vector`实现有一个具有所有权的指针和两个无所有权的指针。许多ABI（基本上所有针对C代码的接口）都使用`T*`，有些是具有所有权的。有些接口不能简单地用`owner`作标记，因为它们需要维持与C的兼容（虽然这里可以使用宏来实现，它只在C++模式下展开成`owner`。这种正确使用宏的场景是罕见的）。

##### 注意
`owner<T*>`没有超出`T*`的默认语义。使用它不需要修改任何代码，也不会影响ABI。它只是给程序员和分析工具的指示器。例如，如果`owner<T*>`是类的成员，那个类最好有析构函数来用`delete`删除它。

##### 示例，不好的
返回一个（原始）指针给调用者强加了不确定的生命周期管理；也就是说，应该由谁来删除被指向的对象？
```cpp
Gadget* make_gadget(int n)
{
    auto p = new Gadget{n};
    // ...
    return p;
}

void caller(int n)
{
    auto p = make_gadget(n);   // 记得删除p
    // ...
    delete p;
}
```
除了会遇到泄露的问题外，这也增加了无谓的分配和释放操作，而且是不必要地啰嗦。如果Gadget从函数中移动出来是廉价的（例如它很小型或者有一个高效的移动操作），那么只要以“值”返回它就行了（参阅“输出”返回值）：
```cpp
Gadget make_gadget(int n)
{
    Gadget g{n};
    // ...
    return g;
}
```

##### 注意
这个准则适用于工厂函数。

##### 注意
如果需要指针语义（例如，由于返回类型需要指向类层次结构中的基类（一个接口）），那么返回一个“智能指针”。

##### 实施
* （简单）对作用于不是`owner<T>`的原始指针上的`delete`发出警告。
* （中等）对于没有在每个代码路径上调用`reset`或者显式用`delete`删除`owner<T>`指针的情况发出警告。
* （简单）如果`new`的返回值赋值给原始指针，发出警告。
* （简单）如果一个函数返回的对象是在函数内分配的，而且有移动构造函数，发出警告。建议考虑以值返回它来代替。

### R.4: 原始引用（`T&`）不具有所有权
##### 理由
（在C++标准或者在大部分代码中）不存在与这个说法不同的东西，而且大部分原始引用都是不具有所有权的。我们希望所有者能够被辨识出来，因而我们可以可靠且有效地删除被所有者指针指向的对象。

##### 示例
```cpp
void f()
{
    int& r = *new int{7};  // 不好的：原始的具有所有权的引用
    // ...
    delete &r;             // 不好的：违反了删除原始指针的准则
}
```
*另见*：原始指针准则

##### 实施
参阅原始指针准则。

### R.5: 优先使用作用域对象，避免不必要的堆分配
##### 理由
作用域对象是局部对象、全局对象或者成员。这意味着除了用于包含它的作用域或对象的成本之外，没有单独的分配和释放开销。作用域对象的成员自身也是在作用域中的，而且作用域对象的构造函数和析构函数管理成员的生命周期。

##### 示例
下面的例子是低效的（因为它有不必要的分配和释放），极容易受到在`...`部分中抛出异常和返回（导致泄露），而且是啰嗦的：
```cpp
void f(int n)
{
    auto p = new Gadget{n};
    // ...
    delete p;
}
```
相反，应使用局部变量：
```cpp
void f(int n)
{
    Gadget g{n};
    // ...
}
```

##### 实施
* （中等）如果一个对象在函数的所有路径中分配然后又释放，发出警告。建议应该把它定义成局部的`auto`栈对象来代替。
* （简单）如果一个局部的`unique_ptr`或者`shared_ptr`在它的生命周期结束之前没有被移动、拷贝、重新赋值或者调用`reset`，发出警告。

### R.6: 避免非`const`全局变量
##### 理由
全局变量可以在任何地方访问，因此它们会在明显无关的对象之间引入意料之外的依赖。它们是著名的错误源头。

*警告*：全局对象的初始化不是完全有序的。如果你使用了全局对象，要用常量来初始化它。要注意，即使对于`const`对象，也有可能出现未定义的初始化顺序。

##### 例外
全局对象通常比单例更好。

##### 例外
一个不可变（`const`）的全局变量不会引入我们尝试通过禁用全局对象避免的问题。

##### 实施
（??? NM: 显然我们可以对非`const`的静态变量进行警告……我们想要这样做吗？）

## R.alloc: 分配和释放
### R.10: 避免`malloc()`和`free()`
##### 理由
`malloc()`和`free()`不支持构造函数和析构函数，也不能很好地与`new`和`delete`混合使用。

##### 示例
```cpp
class Record {
    int id;
    string name;
    // ...
};

void use()
{
    // p1可能为nullptr
    // *p1没有被初始化；特别是，它的string不是一个string，而是一个
    // 与string同等大小的位结构
    Record* p1 = static_cast<Record*>(malloc(sizeof(Record)));

    auto p2 = new Record;

    // 除非抛出了异常，*p2是经过默认初始化的
    auto p3 = new(nothrow) Record;
    // p3可能为nullptr；否则，*p3是经过默认初始化的

    // ...

    delete p1;    // 错误：不能用delete删除由malloc()分配的对象
    free(p2);    // 错误：不能用free()释放由new分配的对象
}
```
在一些实现中，上面的`delete`和`free()`也许能执行，否则可能他们会导致运行时错误。

##### 例外
在有些程序和部分代码中，异常是不可接受的。一些这类最好的例子是在生命攸关的硬实时代码中。要注意许多禁止使用异常的情况是基于迷信（很糟糕），或者担心存在杂乱资源管理的旧代码库（很不幸，但有时这是必要的）。在这种情况下，考虑使用带`nothrow`版本的`new`。

##### 实施
标记出显式使用的`malloc`和`free`。

### R.11: 避免显式的调用`new`和`delete`
##### 理由
`new`返回的指针应该属于资源句柄（它可以调用`delete`）。如果`new`返回的指针被赋值给纯的/裸露的指针，该对象可能会泄露。

##### 注意
在大型程序中，裸露的`delete`（即应用代码中的`delete`，而不是用于资源管理代码中的）很可能是缺陷：如果你有N个`delete`，你如何确定你不需要N+1或者N-1个呢？这个缺陷可能是潜在的：它可能只会在维护期间出现。如果你有一个裸露的`new`，你可能在其它地方需要一个裸露的`delete`，因此你可能有一个缺陷。

##### 实施
（简单）对任何显式使用的`new`和`delete`发出警告。建议使用`make_unique`来代替。

### R.12: 立即把显式资源分配的结果赋予管理对象
##### 理由
如果你不这样做，异常或者返回会导致泄露。

##### 示例，不好的
```cpp
void f(const string& name)
{
    FILE* f = fopen(name, "r");            // 打开文件
    vector<char> buf(1024);
    auto _ = finally([f] { fclose(f); });  // 记得关闭文件
    // ...
}
```
`buf`的分配可能会失败，导致泄露了文件句柄。

##### 示例
```cpp
void f(const string& name)
{
    ifstream f{name};   // 打开文件
    vector<char> buf(1024);
    // ...
}
```
（在`ifstream`中）对文件句柄的使用是简单、高效而且安全的。

##### 实施
* 标记出用来初始化指针的显式分配（问题：我们能够识别多少直接的资源分配？）。

### R.13: 在单个表达式语句中至多执行一次显式资源分配
##### 理由
如果你在一个语句中执行了两次显式资源分配，你可能会泄露资源，因为许多子表达式，包括函数参数的求值顺序是不确定的。

##### 示例
```cpp
void fun(shared_ptr<Widget> sp1, shared_ptr<Widget> sp2);
```
这个`fun`函数可能会被这样调用：
```cpp
// 糟糕的：潜在的泄露
fun(shared_ptr<Widget>(new Widget(a, b)), shared_ptr<Widget>(new Widget(c, d)));
```
这是异常不安全地，因为编译器可能会对创建函数两个参数的表达式重新排序。特别是，编译器会交叉执行两个表达式：两个对象的内存分配（通过调用`operator new`）可能会首先执行，接着会调用两个`Widget`的构造函数。如果其中一个构造函数抛出了异常，那么另一个对象的内存永远不会释放！

这个微妙的问题有简单的解决方法：永远不要在单个表达式语句中执行多于一次的显式资源分配。例如：
```cpp
shared_ptr<Widget> sp1(new Widget(a, b)); // 好多了，但有点杂乱
fun(sp1, new Widget(c, d));
```
最好的解决方法是使用返回具有所有权对象的工厂函数来完全避免显式分配：
```cpp
fun(make_shared<Widget>(a, b), make_shared<Widget>(c, d)); // 最好的
```
如果没有这样的工厂包裹函数，那么写一个你自己的。

##### 实施
* 标记出有多个显式资源分配的表达式（问题：我们可以识别多少直接的资源分配？）。

### R.14: ??? 数组与指针参数
##### 理由
数组会衰变成指针，因而丢失了它的大小，为范围错误敞开了机会。

##### 示例
```cpp
??? 我们建议使用哪种：f(int*[]) 还是 f(int**) ???
```

*替代方案*：使用`span`来保留大小信息。

##### 实施
标记出`[]`参数。

### R.15: 总是重载配对的分配/释放
##### 理由
否则你会遇到不匹配的操作和混乱。

##### 示例
```cpp
class X {
    // ...
    void* operator new(size_t s);
    void operator delete(void*);
    // ...
};
```

##### 注意
如果你想要不能被释放的内存，用`=delete`删除释放操作。不要让它未声明。

##### 实施
标记出不完整的配对。

## R.smart: 智能指针

### R.20: 使用`unique_ptr`或`shared_ptr`来表示所有权

##### 理由

它们可以防止资源泄露。

##### 示例

考虑以下代码：

```cpp
void f()
{
    X x;
    X* p1 { new X };              // 参阅：???
    unique_ptr<T> p2 { new X };   // 唯一的所有权；参阅???
    shared_ptr<T> p3 { new X };   // 共享的所有权；参阅???
    auto p4 = make_unique<X>();   // 唯一的所有权，比显式使用“new”更好
    auto p5 = make_shared<X>();   // 共享的所有权，比显式使用“new”更好
}
```

这里（只）会泄露用来初始化`p1`的对象。

##### 实施

（简单）如果`new`的返回值或者返回值为指针类型的函数调用被赋值给原始指针，发出警告。

### R.21: 优先使用`unique_ptr`而不是`shared_ptr`，除非你需要共享所有权

##### 理由

`unique_ptr`在概念上更简单，更可预见（你知道什么时候发生析构），以及更快（你不用隐式地维护使用计数）。

##### 示例，不好的

这里不必要地添加和维护了一个引用计数。

```cpp
void f()
{
    shared_ptr<Base> base = make_shared<Derived>();
    // 局部地使用base，没有拷贝它——引用计数永远不会超过1
} // 销毁base
```

##### 示例

这样会更加高效：

```cpp
void f()
{
    unique_ptr<Base> base = make_unique<Derived>();
    // 局部地使用base
} // 销毁base
```

##### 实施

（简单）如果一个函数将`shared_ptr`与一个在函数内分配的对象一起使用，但永远不会返回这个`shared_ptr`，或者把它传递给需要`shared_ptr&`的函数，那么发出警告。建议使用`unique_ptr`来代替。

### R.22: 使用`make_shared()`来生成`shared_ptr`

##### 理由

如果你先创建一个对象然后把它传给`shared_ptr`的构造函数，比起使用`make_shared()`，你（很可能）会执行了一次额外的分配（以及稍后的释放），因为引用计数必须在对象之外另外分配。

##### 示例

考虑以下代码：

```cpp
shared_ptr<X> p1 { new X{2} }; // 不好
auto p = make_shared<X>(2);    // 好
```

`make_shared()`版本只需提及`X`一次，所以比起用显式`new`的版本它通常更短（也更快）。

##### 实施

（简单）如果`shared_ptr`由`new`的结果而不是`make_shared`来构造，发出警告。

### R.23: 使用`make_unique()`来生成`unique_ptr`

##### 理由

为了方便，以及与`shared_ptr`保持一致。

##### 注意

`make_unique()`是在C++14中的，但普遍都可以使用（同时也容易自己写出来）。

##### 实施

（简单）如果`unique_ptr`由`new`的结果而不是`make_unique`来构造，发出警告。

### R.24: 使用`std::weak_ptr`来破除`shared_ptr`的循环

##### 理由

`shared_ptr`依赖使用计数，而在环形结构中使用计数永远不会降到0，因此我们需要一个机制来打破环形结构。

##### 示例

```cpp
#include <memory>

class bar;

class foo
{
public:
    explicit foo(const std::shared_ptr<bar>& forward_reference)
    : forward_reference_(forward_reference)
    { }
private:
    std::shared_ptr<bar> forward_reference_;
};

class bar
{
public:
    explicit bar(const std::weak_ptr<foo>& back_reference)
    : back_reference_(back_reference)
    { }
    void do_something()
    {
    if (auto shared_back_reference = back_reference_.lock()) {
        // 使用 *shared_back_reference
    }
    }
private:
    std::weak_ptr<foo> back_reference_;
};
```

##### 注意

???（HS：很多人说“要打破循环”，但我认为“临时的共享所有权”更关键）
???（BS：打破循环是你必须要做的事情；临时地共享所有权是你如何去做这个事情）
你可以通过简单地使用另一个`shared_ptr`来“临时地共享所有权”。

##### 实施

??? 也许是不可能的。如果我们可以静态地检测出循环，我们就不需要`weak_ptr`。

### R.30: 只有在显式表达生命周期语义的时候才使用智能指针作为参数

##### 理由

如果函数只需要`widget`本身，那么它接受一个`widget`的智能指针是错误的。它应该能够接受任意`widget`对象，不仅仅是那些由特定智能指针管理生命周期的对象。不需要维护生命周期的函数应该使用原始指针或者引用来代替。

##### 示例，不好的

```cpp
// 被调用者
void f(shared_ptr<widget>& w)
{
    // ...
    use(*w); // 只使用了w——生命周期根本没有使用
    // ...
};

// 调用者
shared_ptr<widget> my_widget = /* ... */;
f(my_widget);

widget stack_widget;
f(stack_widget); // 出错
```

##### 示例，好的

```cpp
// 被调用者
void f(widget& w)
{
    // ...
    use(w);
    // ...
};

// 调用者
shared_ptr<widget> my_widget = /* ... */;
f(*my_widget);

widget stack_widget;
f(stack_widget); // 没问题——现在正常了
```

##### 实施

* （简单）如果一个函数接受智能指针类型（重载了`operator->`或者`operator*`的类型）作为参数，该类型是可拷贝的，但函数只调用了`operator*`、`operator->`或`get()`中的一个，那么发出警告。建议使用`T*`或`T&`来代替。
* 标记出这样的智能指针类型参数（重载了`operator->`或者`operator*`的类型）：它可拷贝/可移动，但从来不在函数体中拷贝/移动，而且从来不被修改，也不会被传递给其它会这样做的函数。这意味着所有权语义没有使用。建议使用`T*`或`T&`来代替。

### R.31: 如果你有不属于`std`的智能指针，遵守`std`中的基本模式

##### 理由

下面的规则同样适用于任何类型的的第三方和自定义智能指针，而且对诊断那些常见的导致性能和正确性问题的智能指针错误很有用。你会希望这些规则适用于你使用的所有智能指针上。

任何类型（包括主模板或者特化类型）如果重载了一元的`*`和`->`，就会认为是一个智能指针：

* 如果它是可拷贝的，它会被当作基于引用计数的`shared_ptr`。
* 如果它不可拷贝，它会被当作唯一的`unique_ptr`。

##### 示例

```cpp
// 使用Boost的intrusive_ptr
#include <boost/intrusive_ptr.hpp>
void f(boost::intrusive_ptr<widget> p)  // 在“shared_ptr参数”的准则下是错误的
{
    p->foo();
}

// 使用Microsoft的CComPtr
#include <atlbase.h>
void f(CComPtr<widget> p)               // 在“shared_ptr参数”的准则下是错误的
{
    p->foo();
}
```

这两个例子在“shared_ptr参数”准则下都是错误的：`p`是一个`shared_ptr`，但它的共享特性没有在这里使用，而且按值来传递它是隐含的劣化；这些函数应该只在它们需要参与`widget`的生命周期管理时才接受智能指针。否则，它们应该接受`widget*`，如果参数可以为`nullptr`的话。否则，更理想的是，这些函数应该接受`widget&`。这些智能指针符合`shared_ptr`的概念，因此相关指南的实施规则可以立即应用于这些智能指针上，同时可以暴露出这些常见的劣化。

### R.32: 使用`unique_ptr<widget>`作为参数，来表示函数要获取`widget`的所有权

##### 理由

以这种方式使用`unique_ptr`，可以同时说明和保证函数调用的所有权转移。

##### 示例

```cpp
void sink(unique_ptr<widget>); // 消费widget

void uses(widget*);            // 只是使用widget
```

##### 示例，不好的

```cpp
void thinko(const unique_ptr<widget>&); // 通常不是你想要的
```

##### 实施

* （简单）如果一个函数以左值引用接受`unique_ptr<T>`作为参数，而没有至少在一个代码路径上对它赋值或者调用它的`reset()`，发出警告。建议接受`T*`或者`T&`代替。
* （简单）（（基本的））如果一个函数以`const`引用接受`unique_ptr<T>`参数，发出警告。建议接受`const T*`或者`const T&`代替。

### R.33: 使用`unique_ptr<widget>&`作为参数，来表示函数要重设`widget`

##### 理由

以这种方式使用`unique_ptr`，可以同时说明和保证函数调用的重设语义。

##### 注意

“重设”的意思是“使指针或智能指针指向另一个对象”。

##### 示例

```cpp
void reseat(unique_ptr<widget>&); // “将会”或者“可能”重设指针
```

##### 示例，不好的

```cpp
void thinko(const unique_ptr<widget>&); // 通常不是你想要的
```

##### 实施

* （简单）如果一个函数以左值引用接受`unique_ptr<T>`作为参数，而没有至少在一个代码路径上对它赋值或者调用它的`reset()`，发出警告。建议接受`T*`或者`T&`代替。
* （简单）（（基本的））如果一个函数以`const`引用接受`unique_ptr<T>`参数，发出警告。建议接受`const T*`或者`const T&`代替。

### R.34: 使用`shared_ptr<widget>`作为参数，来表示函数是部分所有者

##### 理由

这会使得函数的所有权共享意图更清晰。

##### 示例，好的

```cpp
void share(shared_ptr<widget>);            // 共享——“将会”持有引用计数

void may_share(const shared_ptr<widget>&); // “可能”持有引用计数

void reseat(shared_ptr<widget>&);          // “可能”重设指针
```

##### 实施

* （简单）如果一个函数以左值引用接受`shared_ptr<T>`作为参数，而没有至少在一个代码路径上对它赋值或者调用它的`reset()`，发出警告。建议接受`T*`或者`T&`代替。
* （简单）（（基本的））如果一个函数以值或者以`const`引用接受`shared_ptr<T>`参数，而没有至少在一个代码路径上拷贝或移动给另一个`shared_ptr`，发出警告。建议接受`T*`或者`T&`代替。
* （简单）（（基本的））如果一个函数以右值引用接受`shared_ptr<T>`，发出警告。建议以值来接受。

### R.35: 使用`shared_ptr<widget>&`作为参数，来表示函数可能会重设共享的指针

##### 理由

这会使得函数的重设意图更清晰。

##### 注意

“重设”的意思是“使指针或智能指针指向另一个对象”。

##### 示例，好的

```cpp
void share(shared_ptr<widget>);            // 共享——“将会”持有引用计数

void reseat(shared_ptr<widget>&);          // “可能”重设指针

void may_share(const shared_ptr<widget>&); // “可能”持有引用计数
```

##### 实施

* （简单）如果一个函数以左值引用接受`shared_ptr<T>`作为参数，而没有至少在一个代码路径上对它赋值或者调用它的`reset()`，发出警告。建议接受`T*`或者`T&`代替。
* （简单）（（基本的））如果一个函数以值或者以`const`引用接受`shared_ptr<T>`参数，而没有至少在一个代码路径上拷贝或移动给另一个`shared_ptr`，发出警告。建议接受`T*`或者`T&`代替。
* （简单）（（基本的））如果一个函数以右值引用接受`shared_ptr<T>`，发出警告。建议以值来接受。

### R.36: 使用`const shared_ptr<widget>&`作为参数，来表示函数可能会持有对象的引用计数???

##### 理由

这会使得函数的???意图更清晰。

##### 示例，好的

```cpp
void share(shared_ptr<widget>);            // 共享——“将会”持有引用计数

void reseat(shared_ptr<widget>&);          // “可能”重设指针

void may_share(const shared_ptr<widget>&); // “可能”持有引用计数
```

##### 实施

* （简单）如果一个函数以左值引用接受`shared_ptr<T>`作为参数，而没有至少在一个代码路径上对它赋值或者调用它的`reset()`，发出警告。建议接受`T*`或者`T&`代替。
* （简单）（（基本的））如果一个函数以值或者以`const`引用接受`shared_ptr<T>`参数，而没有至少在一个代码路径上拷贝或移动给另一个`shared_ptr`，发出警告。建议接受`T*`或者`T&`代替。
* （简单）（（基本的））如果一个函数以右值引用接受`shared_ptr<T>`，发出警告。建议以值来接受。

### R.37: 不要传递从别名智能指针获取的指针或引用

##### 理由

违反该准则是导致丢失引用计数和遇到悬挂指针的头号原因。在调用链上，函数应该优先传递原始指针和引用。在你从保持对象存活的智能指针中获得原始指针或引用的调用树顶端，你需要确保这个智能指针在调用树的下方不会被意外地重置或者赋值。

##### 注意

为了做到这一点，有时你需要获取智能指针的局部拷贝，在函数和调用树的过程中它稳固地保持对象存活。

##### 示例

考虑以下代码：

```cpp
// 全局变量（静态分配或者堆分配），或者是另一个局部变量的别名…
shared_ptr<widget> g_p = ...;

void f(widget& w)
{
    g();
    use(w);  // A
}

void g()
{
    g_p = ...; // 糟糕，如果这是最后一个指向widget的shared_ptr，会销毁widget
}
```

下面的代码不应该通过代码评审：

```cpp
void my_code()
{
    // 不好的：传递从非局部智能指针获取的指针或引用，
    // 该智能指针可能会在f内部或者它调用的函数中意外地重置
    f(*g_p);

    // 不好的：相同的原因，只作为“this”指针来传递它
    g_p->func();
}
```

修复方法很简单——获取指针的局部拷贝来为你的调用树“保持引用计数”：

```cpp
void my_code()
{
    // 廉价的：增加1个计数可以覆盖整个函数以及其下的全部调用树
    auto pin = g_p;

    // 没问题：传递从局部的、非别名的智能指针获取的指针或引用
    f(*pin);

    // 没问题：相同的原因
    pin->func();
}
```

##### 实施

* （简单）如果一个用于函数调用的指针或引用是从智能指针变量（`unique_ptr`或`shared_ptr`）获取的，而该变量是非局部的，或者它是局部的但可能是其它变量的别名，发出警告。如果智能指针是`shared_ptr`，那么建议获取智能指针的局部拷贝，然后从这个拷贝获取指针或引用。